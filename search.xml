<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react源码学习之ReactDOM.render</title>
      <link href="/2020/02/13/react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8BReactDOM.render/"/>
      <url>/2020/02/13/react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8BReactDOM.render/</url>
      
        <content type="html"><![CDATA[<p>基于16.12.0。</p><p>ReactDOM.render是将react元素和dom节点对象绑定的api。整个流程主要负责三件事：</p><ol><li>创建ReactRoot</li><li>创建FiberRoot和Fiber对象</li><li>创建更新</li></ol><p>目前还不明白上面三个对象的逻辑含义。</p><p>再之后将进入调度过程。进入调度之后，不论是通过setState还是ReactDOM.render，在创建完更新后，它们的后续操作都是由调度器管理的，和创建更新调用的哪个api没有任何关系。</p><a id="more"></a><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/images/react/ReactDOM.render流程图.png" alt="ReactDOM.render流程"></p><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><ol><li>ReactDOM.render</li></ol><p>位置：packages/react-dom/src/client/ReactDOMLegacy.js</p><p>常用参数：</p><ul><li>element：React元素，</li><li>container：DOM节点对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除dev的条件判断和不相关的判断代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: React$Element&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>legacyRenderSubtreeIntoContainer</li></ol><p>这里的两个重要函数：</p><ul><li>legacyCreateRootFromDOMContainer：创建了root对象，并将其_internalRoot属性赋值给fiberRoot</li><li>updateContainer：在这个函数中将创建”更新”，更新用来标记React应用中用来更新的地点</li></ul><p>在这个函数中调用上面两个函数完成开头说的三个对象的创建工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除dev的条件判断和不相关的判断代码</span></span><br><span class="line"><span class="comment">// 仅显示首次渲染的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> root: RootType = (container._reactRootContainer: any);</span><br><span class="line">  <span class="keyword">let</span> fiberRoot;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// Initial mount</span></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line">    <span class="comment">// Initial mount should not be batched.</span></span><br><span class="line">    unbatchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>legacyCreateRootFromDOMContainer</li></ol><p>这个函数先是清除了container DOM节点中的所有子元素，然后用这个处理过的dom节点对象，创建root对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除dev的条件判断和不相关的判断代码</span></span><br><span class="line"><span class="comment">// 其中，关于hydrate的属性值均为false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyCreateRootFromDOMContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RootType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldHydrate =</span><br><span class="line">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">  <span class="comment">// First clear any existing content.</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">    <span class="keyword">let</span> warned = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> rootSibling;</span><br><span class="line">    <span class="keyword">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createLegacyRoot(</span><br><span class="line">    container,</span><br><span class="line">    shouldHydrate</span><br><span class="line">      ? &#123;</span><br><span class="line">          hydrate: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="literal">undefined</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>createLegacyRoot</li></ol><p>注意这个函数调用ReactDOMBlockingRoot函数使用<code>new</code>关键字的，也就是说这里会返回一个对象，一直返回到<code>legacyRenderSubtreeIntoContainer</code>函数中，成为root。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLegacyRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: RootOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RootType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMBlockingRoot(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>ReactDOMBlockingRoot</li></ol><p>关于命名有个疑问，为啥要带Blocking？</p><p>legacyRenderSubtreeIntoContainer函数中的root对象是下面这种结构的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _internalRoot: &#123;</span><br><span class="line">    <span class="comment">// 这里的内容详见第9个函数处</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMBlockingRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: void | RootOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._internalRoot = createRootImpl(container, tag, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>createRootImpl</li></ol><p>和hydrate相关的都是false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRootImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: void | RootOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class="line">  <span class="keyword">const</span> hydrate = options != <span class="literal">null</span> &amp;&amp; options.hydrate === <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> hydrationCallbacks =</span><br><span class="line">    (options != <span class="literal">null</span> &amp;&amp; options.hydrationOptions) || <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = createContainer(container, tag, hydrate, hydrationCallbacks);</span><br><span class="line">  <span class="comment">// 这里root.current表示的是一个Fiber对象</span></span><br><span class="line">  <span class="comment">// 其中包含的属性见 函数12</span></span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line">  <span class="keyword">if</span> (hydrate &amp;&amp; tag !== LegacyRoot) &#123;</span><br><span class="line">    <span class="keyword">const</span> doc =</span><br><span class="line">      container.nodeType === DOCUMENT_NODE</span><br><span class="line">        ? container</span><br><span class="line">        : container.ownerDocument;</span><br><span class="line">    eagerlyTrapReplayableEvents(doc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>createContainer</li></ol><p>不太明白为啥要把<code>createFiberRoot</code>函数放进<code>createContainer</code>中。。。直接调不香么(手动扶额)</p><p>返回的是带有Fiber对象的FiberRoot对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">OpaqueRoot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>createFiberRoot</li></ol><p>到这里<code>containerInfo</code>依然是dom节点对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = (<span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    root.hydrationCallbacks = hydrationCallbacks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line">  <span class="comment">// stateNode is any.</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line"></span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>FiberRootNode</li></ol><p>这里创建的是FiberRoot</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  <span class="keyword">this</span>.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.containerInfo = containerInfo;</span><br><span class="line">  <span class="keyword">this</span>.pendingChildren = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.pingCache = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.finishedExpirationTime = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.timeoutHandle = noTimeout;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.pendingContext = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.hydrate = hydrate;</span><br><span class="line">  <span class="keyword">this</span>.callbackNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.callbackPriority = NoPriority;</span><br><span class="line">  <span class="keyword">this</span>.firstPendingTime = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.firstSuspendedTime = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.lastSuspendedTime = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.nextKnownPendingLevel = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.lastPingedTime = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.lastExpiredTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class="line">    <span class="keyword">this</span>.memoizedInteractions = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">this</span>.pendingInteractionMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hydrationCallbacks = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>createHostRootFiber</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">createHostRootFiber(tag: RootTag): Fiber &#123;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class="line">    mode = ConcurrentMode | BlockingMode | StrictMode;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === BlockingRoot) &#123;</span><br><span class="line">    mode = BlockingMode | StrictMode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 会到这个分支</span></span><br><span class="line">    mode = NoMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">    <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">    <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">    <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">    mode |= ProfileMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里的 HostRoot = 3</span></span><br><span class="line">  <span class="keyword">return</span> createFiber(HostRoot, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>createFiber</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createFiber = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="12"><li>FiberNode</li></ol><p>这里创建的是Fiber</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除dev的条件判断和不相关的判断代码</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">    pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">    mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Instance</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.elementType = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.stateNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fiber</span></span><br><span class="line">    <span class="keyword">this</span>.return = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.child = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.sibling = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.pendingProps = pendingProps;</span><br><span class="line">    <span class="keyword">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Effects</span></span><br><span class="line">    <span class="keyword">this</span>.effectTag = NoEffect;</span><br><span class="line">    <span class="keyword">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.lastEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.expirationTime = NoWork;</span><br><span class="line">    <span class="keyword">this</span>.childExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">      <span class="keyword">this</span>.actualDuration = <span class="built_in">Number</span>.NaN;</span><br><span class="line">      <span class="keyword">this</span>.actualStartTime = <span class="built_in">Number</span>.NaN;</span><br><span class="line">      <span class="keyword">this</span>.selfBaseDuration = <span class="built_in">Number</span>.NaN;</span><br><span class="line">      <span class="keyword">this</span>.treeBaseDuration = <span class="built_in">Number</span>.NaN;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class="line">      <span class="comment">// This won't trigger the performance cliff mentioned above,</span></span><br><span class="line">      <span class="comment">// and it simplifies other profiler code (including DevTools).</span></span><br><span class="line">      <span class="keyword">this</span>.actualDuration = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.actualStartTime = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">this</span>.selfBaseDuration = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.treeBaseDuration = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableUserTimingAPI) &#123;</span><br><span class="line">      <span class="keyword">this</span>._debugID = debugCounter++;</span><br><span class="line">      <span class="keyword">this</span>._debugIsCurrentlyTiming = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="13"><li>markContainerAsRoot</li></ol><p>hostRoot是Container DOM对象对应的Fiber对象</p><p>node是Container DOM对象</p><p>这个函数的作用是给Container DOM对象添加一个属性，属性值是Container DOM对象对应的Fiber对象，通过Fiber对象的stateNode属性能够拿到对应的FiberRoot对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markContainerAsRoot</span>(<span class="params">hostRoot, node</span>) </span>&#123;</span><br><span class="line">  node[internalContainerInstanceKey] = hostRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li>updateContainer</li></ol><p>到此开始创建更新。</p><ul><li>expirationTime：过期时间的创建是个重点</li><li>context：不太重要，可忽略</li><li>update: 是用来标记React应用中需要更新的地点</li><li>enqueueUpdate: 在同一个节点上会产生多个更新，这个用来对更新排序</li><li>scheduleWork: 开始进入任务调度，根据优先级来确定更新的先后顺序</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除dev的条件判断和不相关的判断代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class="line">  <span class="keyword">const</span> expirationTime = computeExpirationForFiber(</span><br><span class="line">    currentTime,</span><br><span class="line">    current,</span><br><span class="line">    suspenseConfig,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = getContextForSubtree(parentComponent);</span><br><span class="line">  <span class="keyword">if</span> (container.context === <span class="literal">null</span>) &#123;</span><br><span class="line">    container.context = context;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    container.pendingContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime, suspenseConfig);</span><br><span class="line">  <span class="comment">// Caution: React DevTools currently depends on this property</span></span><br><span class="line">  <span class="comment">// being called "element".</span></span><br><span class="line">  update.payload = &#123;element&#125;;</span><br><span class="line"></span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li>createUpdate</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除dev的条件判断和不相关的判断代码</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Update</span>&lt;*&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> update: Update&lt;*&gt; = &#123;</span><br><span class="line">      expirationTime,</span><br><span class="line">      suspenseConfig,</span><br><span class="line"></span><br><span class="line">      tag: UpdateState,</span><br><span class="line">      payload: <span class="literal">null</span>,</span><br><span class="line">      callback: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      next: (<span class="literal">null</span>: any),</span><br><span class="line">    &#125;;</span><br><span class="line">    update.next = update;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="16"><li>getPublicRootInstance</li></ol><p>会走第一个分支，返回null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPublicRootInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">React$Component</span>&lt;<span class="title">any</span>, <span class="title">any</span>&gt; | <span class="title">PublicInstance</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> containerFiber = container.current;</span><br><span class="line">  <span class="keyword">if</span> (!containerFiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (containerFiber.child.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> getPublicInstance(containerFiber.child.stateNode);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> containerFiber.child.stateNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数所在文件路径"><a href="#函数所在文件路径" class="headerlink" title="函数所在文件路径"></a>函数所在文件路径</h3><p><img src="/images/react/ReactDOM.render函数路径图.png" alt="ReactDOM.render函数路径图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> ReactDOM.render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react源码学习之mapChildren</title>
      <link href="/2020/02/08/react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8BmapChildren/"/>
      <url>/2020/02/08/react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8BmapChildren/</url>
      
        <content type="html"><![CDATA[<p>基于16.12.0。</p><p>我们都知道children是react元素对象的一个属性，用来承载一个父组件所有包含的子组件。react官方推出了一套api用来处理children对象，这篇就是用来记录学习react对map函数的实现。</p><a id="more"></a><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/images/react/react-children.png" alt="mapChildren的实现流程"></p><p>（参考自慕课网教程）</p><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><ol><li><p>mapChildren</p><p> 好像没啥好写的。。。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapChildren</span>(<span class="params">children, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, <span class="literal">null</span>, func, context);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapIntoWithKeyPrefixInternal</p><p> 第一步是从对象池中获取一个包含特定属性的对象，这个对象可以认为是处理同一级各个child的一个环境对象；</p><p> 第二步是利用这个环境对象做具体的child的遍历处理；</p><p> 第三步是释放这个对象，如果对象池中已经有10个了，就彻底释放，如果不到10个就存入对象池。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapIntoWithKeyPrefixInternal</span>(<span class="params">children, array, prefix, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> escapedPrefix = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">    escapedPrefix = escapeUserProvidedKey(prefix) + <span class="string">'/'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> traverseContext = getPooledTraverseContext(</span><br><span class="line">    array,</span><br><span class="line">    escapedPrefix,</span><br><span class="line">    func,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 之所以使用对象池，是因为map在执行的过程中，会涉及声明大量对象及再释放，这些操作是一个消耗性能的过程，可能会导致js引擎积塞，引发内存抖动。</p></li><li><p>getPooledTraverseContext和releaseTraverseContext</p><p> 一个特定traverseContext对象的发挥作用的阶段对应处理同一层级的所有child的过程。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> traverseContextPool = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPooledTraverseContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  mapResult,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> traverseContext = traverseContextPool.pop();</span><br><span class="line">    traverseContext.result = mapResult;</span><br><span class="line">    traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">    traverseContext.func = mapFunction;</span><br><span class="line">    traverseContext.context = mapContext;</span><br><span class="line">    traverseContext.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      result: mapResult,</span><br><span class="line">      keyPrefix: keyPrefix,</span><br><span class="line">      func: mapFunction,</span><br><span class="line">      context: mapContext,</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">releaseTraverseContext</span>(<span class="params">traverseContext</span>) </span>&#123;</span><br><span class="line">  traverseContext.result = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.keyPrefix = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.func = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.context = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length &lt; POOL_SIZE) &#123;</span><br><span class="line">    traverseContextPool.push(traverseContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>traverseAllChildren</p><p> 这个函数会返回处理了的同一层级的child的数量。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span>(<span class="params">children, callback, traverseContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>traverseAllChildrenImpl</p><p> 这段函数里有一个递归的过程，对应流程图中的那个小环。整个children的处理过程都使用同一个traverseContext对象。</p><p> 元素的key属性也是在这个函数中计算得出。</p><p> 可以看出能处理的类型包含：普通字符串、数字、虚拟dom对象、迭代器、前面说的这些类型组成的数组。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span> || type === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> invokeCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">let</span> nextName;</span><br><span class="line">  <span class="keyword">let</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line">  <span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">    nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iteratorFn = getIteratorFn(children);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> iterator = iteratorFn.call(children);</span><br><span class="line">      <span class="keyword">let</span> step;</span><br><span class="line">      <span class="keyword">let</span> ii = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> addendum = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">const</span> childrenString = <span class="string">''</span> + children;</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">'Objects are not valid as a React child (found: %s).%s'</span>,</span><br><span class="line">        childrenString === <span class="string">'[object Object]'</span></span><br><span class="line">          ? <span class="string">'object with keys &#123;'</span> + <span class="built_in">Object</span>.keys(children).join(<span class="string">', '</span>) + <span class="string">'&#125;'</span></span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapSingleChildIntoContext</p><p> 首先判断经过使用者传入函数的处理后返回的是不是一个数组，如果是，则递归mapIntoWithKeyPrefixInternal，重复上述过程，对应流程图中的大环；</p><p> 如果是单个元素，则将上一步生成的key和这一步计算后得到的child一同传入ReactElement函数中，返回一个普通的虚拟dom元素，推入结果池中。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapSingleChildIntoContext</span>(<span class="params">bookKeeping, child, childKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        <span class="comment">// Keep both the (mapped) and old keys if they differ, just as</span></span><br><span class="line">        <span class="comment">// traverseAllChildren used to do for objects as children</span></span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + <span class="string">'/'</span></span><br><span class="line">            : <span class="string">''</span>) +</span><br><span class="line">          childKey,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数所在文件路径"><a href="#函数所在文件路径" class="headerlink" title="函数所在文件路径"></a>函数所在文件路径</h3><p><img src="/images/react/React-Children函数路径图.png" alt="React-Children函数路径图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> mapChildren </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux源码学习</title>
      <link href="/2019/10/22/react-redux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/22/react-redux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>暂停</p><p>新的react-router大量使用了react的hook，本文主要参考<a href="http://xzfyu.com/2018/07/08/react/react%E7%9B%B8%E5%85%B3/react-redux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">参考资料1</a>和<a href="https://juejin.im/post/5c0e2a616fb9a049a9798997" target="_blank" rel="noopener">参考资料4</a>，这两篇还比较新。</p><a id="more"></a><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p><a href="https://juejin.im/post/5b32f145f265da596a3682b4" target="_blank" rel="noopener">参考资料2</a>在讲context的时候说道有使用<code>getChildContext</code>函数，但是在react文档<a href="https://reactjs.org/docs/legacy-context.html#updating-context" target="_blank" rel="noopener">参考资料3</a>中有下面的描述：</p><blockquote><p>Don’t do it.</p></blockquote><blockquote><p>React has an API to update context, but it is fundamentally broken and you should not use it.</p></blockquote><p>有点尴尬。<a href="https://juejin.im/post/5b32f145f265da596a3682b4" target="_blank" rel="noopener">参考资料2</a>中描述了不建议使用的原因，就是：context里面的数据能被随意地接触修改，导致程序运行的不可预料。而redux却能做到修改数据的行为可预测可追踪。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://xzfyu.com/2018/07/08/react/react%E7%9B%B8%E5%85%B3/react-redux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://xzfyu.com/2018/07/08/react/react%E7%9B%B8%E5%85%B3/react-redux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></li><li><a href="https://juejin.im/post/5b32f145f265da596a3682b4" target="_blank" rel="noopener">https://juejin.im/post/5b32f145f265da596a3682b4</a></li><li><a href="https://reactjs.org/docs/legacy-context.html#updating-context" target="_blank" rel="noopener">https://reactjs.org/docs/legacy-context.html#updating-context</a></li><li><a href="https://juejin.im/post/5c0e2a616fb9a049a9798997" target="_blank" rel="noopener">https://juejin.im/post/5c0e2a616fb9a049a9798997</a></li><li><a href="https://codar.club/blogs/analysis-of-connect-method-of-react-redux.html" target="_blank" rel="noopener">https://codar.club/blogs/analysis-of-connect-method-of-react-redux.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> react-redux </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辅助理解react-router的知识点</title>
      <link href="/2019/10/20/%E8%BE%85%E5%8A%A9%E7%90%86%E8%A7%A3react-router%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/10/20/%E8%BE%85%E5%8A%A9%E7%90%86%E8%A7%A3react-router%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>本文主要是记录html5原生history的属性和方法以及React的Context、Provider、Consumer、Children、HOC相关概念。</p><a id="more"></a><h2 id="使用html5的history"><a href="#使用html5的history" class="headerlink" title="使用html5的history"></a>使用html5的history</h2><h3 id="popstate事件"><a href="#popstate事件" class="headerlink" title="popstate事件"></a>popstate事件</h3><p>下面摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate" target="_blank" rel="noopener">参考资料3</a>。</p><p>每当处于激活状态的历史记录条目发生变化时，popstate事件就会在对应的window对象上触发。如果当前处于激活状态的历史记录条目是由history.pushState()方法创建，或者由histoary.replaceState()方法修改过，则popstate事件对象的state属性包含了这个历史条目的state对象的一个拷贝。</p><p><strong>调用history.pushState()或者history.replaceState()不会触发popstate事件。popstate事件只会在浏览器某些行为下触发，比如点击后退、前进按钮，或者调用history.back()、history.forward()、history.go()方法。</strong></p><p>当网页加载时，各浏览器对popstate事件是否触发会有不同的表现，Chrome和Safari会触发popstate事件，而Firefox不会。</p><p>即便进入了那些非pushState和replaceState方法作用过的没有state对象关联的那些网页，popstate事件也仍然会被触发。</p><hr><h3 id="pushState"><a href="#pushState" class="headerlink" title="pushState()"></a>pushState()</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API" target="_blank" rel="noopener">参考资料2</a>中给出的例子： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(stateObj, <span class="string">"page 2"</span>, <span class="string">"bar.html"</span>);</span><br></pre></td></tr></table></figure><p>调用history.pushState()将导致地址栏的地址变为<code>http://mozilla.org/bar.html</code>，但是浏览器不会加载<code>bar.html</code>，甚至不会检查<code>bar.html</code>是否存在。</p><p>假设现在用户又访问了 <code>http://google.com</code>，然后点击了返回按钮。此时，地址栏将显示 <code>http://mozilla.org/bar.html</code>，history.state 中包含了 stateObj 的一份拷贝。页面此时展现为bar.html。且因为页面被重新加载了，所以popstate事件将不会被触发。（这里有个问题：根据上面的描述，这里说popstate不会触发是FF不会触发？Chrome还是会触发吧？）</p><p>如果我们再次点击返回按钮，页面URL会变为<code>http://mozilla.org/foo.html</code>，文档对象document会触发另外一个 popstate 事件，这一次的事件对象state object为null。 这里也一样，返回并不改变文档的内容，尽管文档在接收 popstate 事件时可能会改变自己的内容，其内容仍与之前的展现一致。</p><p>pushState()需要三个参数：状态、标题（忽略）、url。</p><ol><li>状态对象：是一个js的普通对象，通过pushState()创建新的历史条目。无论什么时候用户导航到新的状态，popstate时间会被触发，且该时间的state属性包含该历史记录条目状态对象的副本。</li></ol><h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState()"></a>replaceState()</h3><p>和pushState()方法非常相似，区别在于replaceState()是修修改了当前的历史记录项而不是新建一个，但是这并不会阻止其在全局浏览器历史中创建一个新的历史记录项。</p><p>这个函数的使用场景在于为了响应用户操作，想要更新状态对象或者当前历史记录的URL。</p><hr><h2 id="React部分"><a href="#React部分" class="headerlink" title="React部分"></a>React部分</h2><p>关于Context、Provider、Consumer可以看<a href="https://juejin.im/post/5a90e0545188257a63112977" target="_blank" rel="noopener">参考资料4</a>和<a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener">参考资料5</a>，目前先知道怎么用，用来帮助理解react-router，后续看react原理和源码的时候再来深入。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/History_API</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate</a></li><li><a href="https://juejin.im/post/5a90e0545188257a63112977" target="_blank" rel="noopener">https://juejin.im/post/5a90e0545188257a63112977</a></li><li><a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener">https://reactjs.org/docs/context.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> react-router </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router常用组件原理学习</title>
      <link href="/2019/10/17/react-router%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/17/react-router%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>react-router的功能实现感觉可以分为两部分：</p><ol><li>html5的history，这个api提供了浏览器地址栏的地址变化的一系列控制。</li><li>路由和组件的匹配，react-router主要是实现了这一部分，涉及context、provider、高阶组件等。</li></ol><p>react-redux中应该也会涉及到2中说的这些概念和用法，但猜测应该更侧重于组件更新的优化上。这次先试探一波，除了路由的实现外，熟悉下这些概念。</p><p>p.s. 这段写于看完下面说的几部分之后</p><p>看完之后，感觉react-router的实现原理并不难，需要着重掌握的反而是history和React中的几个概念：Context、Provider、Consumer、Children、HOC。这几个概念还真不熟悉，所以决定再起一篇，用来着重记录。</p><a id="more"></a><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>react-router以<a href="https://github.com/ReactTraining/history" target="_blank" rel="noopener">history</a>为基础库，所以先来看一下history的实现。</p><p>history主要是对html5提供的history API做了进一步封装，提供了针对浏览器和node.js环境的不同实现，这次主要是看了针对浏览器的实现。</p><p>源码不算难，这里记录一下本次的阅读顺序，方便日后参考：可以先看<a href="https://github.com/fi3ework/blog/issues/21" target="_blank" rel="noopener">参考资料2</a>，熟悉使用history实现路由的机制，再参考<a href="https://juejin.im/post/5c049f23e51d455b5a4368bd#heading-7" target="_blank" rel="noopener">参考资料1</a>进一步阅读源码。</p><p>看history库除了明白库自身的实现原理，还能帮助复习下html5提供的history中关键的属性(length,state)、事件(popstate及触发条件)以及方法(go(),pushState(),replaceState())。关于原生history的属性文档，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">参考资料3</a>或<a href="https://zhuanlan.zhihu.com/p/55837818" target="_blank" rel="noopener">参考资料5的第一部分</a>，方法文档详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">参考资料4</a>。</p><p>关于这一部分，在下一篇中有详细记录。</p><hr><h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h3><p>这次主要看react-router和react-router-dom两个文件夹的文件代码。<a href="https://github.com/fi3ework/blog/issues/21" target="_blank" rel="noopener">参考资料2</a>中有讲：</p><blockquote><p>react-router 负责通用的路由逻辑，react-router-dom 负责浏览器的路由管理</p></blockquote><p>但目前着实没感觉出来，手动扶额…感觉<a href="https://reacttraining.com/react-router/web/api/Route" target="_blank" rel="noopener">参考资料6</a>说的更靠谱一些，react-router提供了底层的实现，react-router-dom在其基础上封装了更常用的方法。</p><hr><h3 id="Router-js"><a href="#Router-js" class="headerlink" title="Router.js"></a>Router.js</h3><p>这个文件位于react-router中，源码能看明白，就不写了，这里想写一下相关的内容：</p><ol><li><p>Router这个组件的作用</p><p>看过源码后，感觉Router是为创建Context，提供Provider存在的。Router是一个很基础的组件，后面要看的BrowserRouter就是在Router的基础上构造的。具体的用途就是包裹其他组件，方便被包裹的组件获取参数，以及这些参数有更新时，控制被包括组件更新。</p></li><li><p>context</p><p>首先，context这个东西的存在就是为了避免嵌套组件层层传参数的繁琐。相当于一个全局的池子，其中的属性，满足<code>条件</code>的组件都可以访问，而不需要层层传递。</p><p>React有这样一个<a href="https://reactjs.org/docs/context.html#reactcreatecontext" target="_blank" rel="noopener">api</a>：<code>React.createContext</code>，用来创建一个context，react-router没有直接使用这个api，而是用了一个pollifill，功能应该是一样的。</p></li><li><p>Provider</p><p>Provider是一个组件，通过上面的<code>React.createContext</code>创建的context会返回一个Provider。这个组件就是上面2中所说的条件，被这个Provider组件包裹后，才能访问context中的属性。同时，Provider还负责当有属性更新时，驱动子组件更新。<a href="https://reactjs.org/docs/context.html#contextprovider" target="_blank" rel="noopener">文档</a>中还说道，使用这种方式的驱动更新不受<code>shouldComponentUpdate</code>的干预。</p></li></ol><hr><h3 id="BrowserRouter-js"><a href="#BrowserRouter-js" class="headerlink" title="BrowserRouter.js"></a>BrowserRouter.js</h3><p>这个组件就是把上面说的history库的一个实例对象传入Router组件中，创建所需的全局池子，更新方式以及注入路由相关的属性。</p><p>源码很简单，不写。</p><hr><h3 id="Route-js"><a href="#Route-js" class="headerlink" title="Route.js"></a>Route.js</h3><p>这个组件用来实现路由和业务组件的匹配。</p><p>使用Route组件的方式是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=<span class="string">"/"</span>&gt;</span><br><span class="line">      &lt;Home /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Route path="/</span>news<span class="string">"&gt;</span></span><br><span class="line"><span class="string">      &lt;NewsFeed /&gt;</span></span><br><span class="line"><span class="string">    &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure><p>传入一个path属性，如果当前url和path匹配，就渲染其包裹的组件。</p><p>Route源码就是是做了上述的两件事，第一件是判断当前url和path是否匹配，第二件是处理渲染的组件。但实现感觉有点乱…<a href="https://reacttraining.com/react-router/web/api/Route" target="_blank" rel="noopener">参考资料6</a>中关于这一部分的代码有详细的说明。</p><hr><h3 id="Switch-js"><a href="#Switch-js" class="headerlink" title="Switch.js"></a>Switch.js</h3><p>这个组件的作用是当有多个path属性相近(比如都包含’/‘)的时候，多个Route组件都会渲染，而Switch做的事情是使用循环迭代其包裹的子组件，将匹配成功的第一个Route赋值给中间变量，最后再渲染这个。有一个疑问是，为何源码没有在找到第一个满足条件的Route后就停止迭代？</p><hr><h3 id="Link-js"><a href="#Link-js" class="headerlink" title="Link.js"></a>Link.js</h3><p>Link的源码同样不难，本质是调用了history.push()。</p><p>如果没有传component，Link默认使用LinkAnchor。LinkAnchor底层就是a标签，一开始没细看，有一点让我很困惑，就是a标签点击后同样会触发url的改变，这样就会脱离history的管理。然而实际上，LinkAnchor中有这样一行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br><span class="line">navigate();</span><br></pre></td></tr></table></figure><p>第一行代码阻止了a标签被点击时的默认行为，路由的管理由history接手。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://juejin.im/post/5c049f23e51d455b5a4368bd#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5c049f23e51d455b5a4368bd#heading-7</a> (history源码解析，讲的很清楚)</li><li><a href="https://github.com/fi3ework/blog/issues/21" target="_blank" rel="noopener">https://github.com/fi3ework/blog/issues/21</a> (第一部分讲了前端路由的两种实现方式，第二部分讲了react-router的实现方式，可以先看下这个熟悉下history的大概实现原理)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/History</a> (mdn 关于history属性的文档)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/History_API</a> (mdn 关于history方法的文档)</li><li><a href="https://zhuanlan.zhihu.com/p/55837818" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55837818</a> (第一部分是关于history属性的总结)</li><li><a href="https://reacttraining.com/react-router/web/api/Route" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/api/Route</a> (分析了代码的作用，但感觉么有灵魂)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> react-router </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-saga源码学习</title>
      <link href="/2019/10/04/redux-saga%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/04/redux-saga%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>上一篇整明白了redux-saga的原理，现在来具体看看代码实现。</p><p>讲redux-saga源码的资料真是少的可怜，英文完全没搜到…中文就搜到两篇有价值的，第二篇对整个redux-saga的代码实现做了比较详细的描述。</p><p>然而现在的水准做不到完全掌握，能学多少是多少。</p><a id="more"></a><hr><h3 id="辅助理解的变量名"><a href="#辅助理解的变量名" class="headerlink" title="辅助理解的变量名"></a>辅助理解的变量名</h3><ol><li><p>cont</p><p>continuation 缩写，一般用于表示 Task / MainTask / ForkQueue 的后继</p></li><li><p>cb</p><p>callback 缩写 或是 currCb 应该是 currentCallback 的缩写。一般用于 effect 的后继/回调函数</p></li><li><p>next</p><p>就是前边的递归函数</p></li></ol><h3 id="fork-model"><a href="#fork-model" class="headerlink" title="fork model"></a>fork model</h3><ul><li><p>parent task: the parent tasks is the aggregation of the main tasks + all its forked tasks</p></li><li><p>main task: main task is the main flow of the current Genarator</p></li></ul><h3 id="主线"><a href="#主线" class="headerlink" title="主线"></a>主线</h3><ol><li>关联redux和redux-saga</li></ol><p>使用redux中的applyMiddleware将redux中的dispatch注入到redux-saga的sagaMiddleware中</p><p>redux的applyMiddleware文件中的这几行代码完成了主要工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure><p>下面是使用redux和redux-saga关联的实际使用示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; helloSaga &#125; <span class="keyword">from</span> <span class="string">'./sagas'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware()</span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(sagaMiddleware)</span><br><span class="line">)</span><br><span class="line">sagaMiddleware.run(helloSaga)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = <span class="function"><span class="params">type</span> =&gt;</span> store.dispatch(&#123;type&#125;)</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>middleware.js</li></ol><p>关联后，控制权移入sagaMiddleware函数中，接入redux-saga最终要的一行代码是：<code>channel.put(action)</code>，这行代码背后的含义是当出现action的操作时，会执行提前绑定好的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sagaMiddleware</span>(<span class="params">&#123; getState, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">  boundRunSaga = runSaga.bind(<span class="literal">null</span>, &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    context,</span><br><span class="line">    channel,</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    sagaMonitor,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果仅redux-saga和redux一起使用</span></span><br><span class="line">  <span class="comment">// 那么此处的next等于dispatch</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (sagaMonitor &amp;&amp; sagaMonitor.actionDispatched) &#123;</span><br><span class="line">      sagaMonitor.actionDispatched(action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处执行reducer</span></span><br><span class="line">    <span class="comment">// 如果action在reducer中有对应的处理类型</span></span><br><span class="line">    <span class="comment">// 则返回对应的处理结果</span></span><br><span class="line">    <span class="comment">// 没有的话直接返回state</span></span><br><span class="line">    <span class="keyword">const</span> result = next(action) <span class="comment">// hit reducers</span></span><br><span class="line">    <span class="comment">// 异步的则走下面这行代码</span></span><br><span class="line">    <span class="comment">// 同步action不存在对应的处理过程</span></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="comment">// const sagaMiddleware = createSagaMiddleware()</span></span><br><span class="line">    <span class="comment">// const store = createStore(</span></span><br><span class="line">    <span class="comment">//   reducer,</span></span><br><span class="line">    <span class="comment">//   applyMiddleware(sagaMiddleware)</span></span><br><span class="line">    <span class="comment">// )</span></span><br><span class="line">    <span class="comment">// 的时候还没有action传进来</span></span><br><span class="line">    <span class="comment">// 所以最里面的这个函数并没有执行</span></span><br><span class="line">    channel.put(action)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>channel.js</li></ol><p>这个文件中的部分源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multicastChannel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> closed = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> currentTakers = []</span><br><span class="line">  <span class="keyword">let</span> nextTakers = currentTakers</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkForbiddenStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed &amp;&amp; nextTakers.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> internalErr(CLOSED_CHANNEL_WITH_TAKERS)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ensureCanMutateNextTakers = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextTakers !== currentTakers) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    nextTakers = currentTakers.slice()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> close = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkForbiddenStates()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closed = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> takers = (currentTakers = nextTakers)</span><br><span class="line">    nextTakers = []</span><br><span class="line">    takers.forEach(<span class="function"><span class="params">taker</span> =&gt;</span> &#123;</span><br><span class="line">      taker(END)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最重要的两个方法put和take</span></span><br><span class="line">  <span class="comment">// take接收保存回调函数</span></span><br><span class="line">  <span class="comment">// put触发</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [MULTICAST]: <span class="literal">true</span>,</span><br><span class="line">    put(input) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        checkForbiddenStates()</span><br><span class="line">        check(input, is.notUndef, UNDEFINED_INPUT_ERROR)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isEnd(input)) &#123;</span><br><span class="line">        close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> takers = (currentTakers = nextTakers)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = takers.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> taker = takers[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (taker[MATCH](input)) &#123;</span><br><span class="line">          taker.cancel()</span><br><span class="line">          taker(input)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// take函数在两个effect中有调用</span></span><br><span class="line">    <span class="comment">// runChannelEffect</span></span><br><span class="line">    <span class="comment">// 以及</span></span><br><span class="line">    <span class="comment">// runTakeEffect</span></span><br><span class="line">    take(cb, matcher = matchers.wildcard) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        checkForbiddenStates()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        cb(END)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      cb[MATCH] = matcher</span><br><span class="line">      ensureCanMutateNextTakers()</span><br><span class="line">      nextTakers.push(cb)</span><br><span class="line"></span><br><span class="line">      cb.cancel = once(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ensureCanMutateNextTakers()</span><br><span class="line">        remove(nextTakers, cb)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    close,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stdChannel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chan = multicastChannel()</span><br><span class="line">  <span class="keyword">const</span> &#123; put &#125; = chan</span><br><span class="line">  <span class="comment">// 这里重写了put方法</span></span><br><span class="line">  chan.put = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input[SAGA_ACTION]) &#123;</span><br><span class="line">      put(input)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    asap(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      put(input)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>runSaga.js</li></ol><p><code>sagaMiddleware.run(helloSaga)</code>是在启动Generator函数，这里的boundRunSaga是一个偏函数，是绑定了一堆基本参数的runSaga：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">boundRunSaga = runSaga.bind(<span class="literal">null</span>, &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    context,</span><br><span class="line">    channel,</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    sagaMonitor,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sagaMiddleware.run = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !boundRunSaga) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundRunSaga(...args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的runSaga出自runSaga.js文件。</p><p>runSaga函数的最后是下面这几行代码，其中调用proc函数，启动了saga，生成了一个task并返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> immediately(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = proc(env, iterator, context, effectId, getMetaInfo(saga), <span class="comment">/* isRoot */</span> <span class="literal">true</span>, <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sagaMonitor) &#123;</span><br><span class="line">      sagaMonitor.effectResolved(effectId, task)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>首先看一下immediately函数，这个函数位于scheduler.js文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">immediately</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    suspend()</span><br><span class="line">    <span class="keyword">return</span> task()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体内的代码执行顺序是</span></span><br><span class="line">    <span class="comment">// 1. suspend()</span></span><br><span class="line">    <span class="comment">// 2. flush()</span></span><br><span class="line">    <span class="comment">// 3. return task()</span></span><br><span class="line">    <span class="comment">// 首次执行的时刻</span></span><br><span class="line">    <span class="comment">// 是在执行sagaMiddleware.run触发的</span></span><br><span class="line">    <span class="comment">// 此处queue中没有任何task</span></span><br><span class="line">    <span class="comment">// 所以此处的flush相当于白执行</span></span><br><span class="line">    <span class="comment">// 重点在上面的task</span></span><br><span class="line">    <span class="comment">// 当执行sagaMiddleware.run时，task为</span></span><br><span class="line">    <span class="comment">// () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   const task = proc(env, iterator, context, effectId, getMetaInfo(saga), /* isRoot */ true, undefined)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//   if (sagaMonitor) &#123;</span></span><br><span class="line">    <span class="comment">//     sagaMonitor.effectResolved(effectId, task)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//   return task</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 也就是触发了proc函数</span></span><br><span class="line">    flush()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>proc.js</li></ol><p>proc函数的主要代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proc</span>(<span class="params">env, iterator, parentContext, parentEffectId, meta, isRoot, cont</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一般情况下env.finalizeRunEffect是identity</span></span><br><span class="line">  <span class="keyword">const</span> finalRunEffect = env.finalizeRunEffect(runEffect)</span><br><span class="line">  next.cancel = noop</span><br><span class="line">  <span class="comment">// mainTask如上面核心概念中描述的</span></span><br><span class="line">  <span class="comment">// 表示当前Generator的执行状态</span></span><br><span class="line">  <span class="keyword">const</span> mainTask = &#123; meta, <span class="attr">cancel</span>: cancelMain, <span class="attr">status</span>: RUNNING &#125;</span><br><span class="line">  <span class="comment">// newTask详见newTask.js文件</span></span><br><span class="line">  <span class="keyword">const</span> task = newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont)</span><br><span class="line">  <span class="comment">// executingContext用在effect runner函数中</span></span><br><span class="line">  <span class="keyword">const</span> executingContext = &#123;</span><br><span class="line">    task,</span><br><span class="line">    digestEffect,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancelMain</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mainTask.status === RUNNING) &#123;</span><br><span class="line">      mainTask.status = CANCELLED</span><br><span class="line">      next(TASK_CANCEL)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> task</span><br><span class="line">  <span class="comment">// next函数是完成Generator运行的地方</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">arg, isErr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result</span><br><span class="line">      <span class="keyword">if</span> (isErr) &#123;</span><br><span class="line">        result = iterator.throw(arg)</span><br><span class="line">        <span class="comment">// user handled the error, we can clear bookkept values</span></span><br><span class="line">        sagaError.clear()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldCancel(arg)) &#123;</span><br><span class="line">        <span class="comment">// 取消会对表示状态的status设置值CANCELLED</span></span><br><span class="line">        mainTask.status = CANCELLED</span><br><span class="line">        <span class="comment">// next.cancel是在下面的digestEffect函数中具体设置的</span></span><br><span class="line">        <span class="comment">// 执行取消命令</span></span><br><span class="line">        <span class="comment">// 不同的effect的cancel不同</span></span><br><span class="line">        <span class="comment">// take类型的表示从回调池子中删除对应的回调</span></span><br><span class="line">        next.cancel()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置done: true</span></span><br><span class="line">        result = is.func(iterator.return) ? iterator.return(TASK_CANCEL) : &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: TASK_CANCEL &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldTerminate(arg)) &#123;</span><br><span class="line">        <span class="comment">// 设置done: true</span></span><br><span class="line">        result = is.func(iterator.return) ? iterator.return() : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 经过上面各层的剥离</span></span><br><span class="line">        <span class="comment">// 迭代器对象在此处给出下一次Generator运行时的值</span></span><br><span class="line">        <span class="comment">// 赋给result</span></span><br><span class="line">        result = iterator.next(arg)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有结束</span></span><br><span class="line">      <span class="comment">// 将值交付予digestEffect函数</span></span><br><span class="line">      <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">        digestEffect(result.value, parentEffectId, next)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainTask.status !== CANCELLED) &#123;</span><br><span class="line">          mainTask.status = DONE</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处执行mainTask的回调</span></span><br><span class="line">        mainTask.cont(result.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mainTask.status === CANCELLED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> error</span><br><span class="line">      &#125;</span><br><span class="line">      mainTask.status = ABORTED</span><br><span class="line"></span><br><span class="line">      mainTask.cont(error, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的effect就是上面传入的result.value</span></span><br><span class="line">  <span class="comment">// 经由内部的类型判断</span></span><br><span class="line">  <span class="comment">// 进入不同的分之</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">runEffect</span>(<span class="params">effect, effectId, currCb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is.promise(effect)) &#123;</span><br><span class="line">      resolvePromise(effect, currCb)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.iterator(effect)) &#123;</span><br><span class="line">      <span class="comment">// resolve iterator</span></span><br><span class="line">      proc(env, effect, task.context, effectId, meta, <span class="comment">/* isRoot */</span> <span class="literal">false</span>, currCb)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (effect &amp;&amp; effect[IO]) &#123;</span><br><span class="line">      <span class="keyword">const</span> effectRunner = effectRunnerMap[effect.type]</span><br><span class="line">      effectRunner(env, effect.payload, currCb, executingContext)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// anything else returned as is</span></span><br><span class="line">      currCb(effect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">digestEffect</span>(<span class="params">effect, parentEffectId, cb, label = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> effectId = nextEffectId()</span><br><span class="line">    env.sagaMonitor &amp;&amp; env.sagaMonitor.effectTriggered(&#123; effectId, parentEffectId, label, effect &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个变量用来标识当前effect的执行状态，完成和取消两种状态不能并存  </span></span><br><span class="line">    <span class="keyword">let</span> effectSettled</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">currCb</span>(<span class="params">res, isErr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (effectSettled) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      effectSettled = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 此处的cb是上面定义的next函数</span></span><br><span class="line">      cb.cancel = noop</span><br><span class="line">      <span class="keyword">if</span> (env.sagaMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isErr) &#123;</span><br><span class="line">          env.sagaMonitor.effectRejected(effectId, res)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          env.sagaMonitor.effectResolved(effectId, res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isErr) &#123;</span><br><span class="line">        sagaError.setCrashedEffect(effect)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里递归执行了next</span></span><br><span class="line">      cb(res, isErr)</span><br><span class="line">    &#125;</span><br><span class="line">    currCb.cancel = noop</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s此处给next函数的cancel属性赋予了明确的执行函数</span></span><br><span class="line">    cb.cancel = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// prevents cancelling an already completed effect</span></span><br><span class="line">      <span class="keyword">if</span> (effectSettled) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      effectSettled = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// currCb.cancel的定义由它的下级更具体的执行函数定义</span></span><br><span class="line">      <span class="comment">// 比如take类型的effect，cancel()定义在channel中</span></span><br><span class="line">      <span class="comment">// fork类型的effect，是不可取消的类型，所以没有cancel()函数</span></span><br><span class="line">      currCb.cancel()</span><br><span class="line">      currCb.cancel = noop <span class="comment">// defensive measure</span></span><br><span class="line"></span><br><span class="line">      env.sagaMonitor &amp;&amp; env.sagaMonitor.effectCancelled(effectId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finalRunEffect(effect, effectId, currCb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>newTask.js</li></ol><p>在saga的启动函数proc函数中，会创建一个task对象，</p><p>下面是创建task对象的主要代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newTask创建的对象用途和上面的mainTask类似</span></span><br><span class="line"><span class="comment">// 都是用来控制一个流程的</span></span><br><span class="line"><span class="comment">// 但newTask创建的对象更为强大</span></span><br><span class="line"><span class="comment">// 它同时创建了一个数组</span></span><br><span class="line"><span class="comment">// 用于保存后续fork的task</span></span><br><span class="line"><span class="comment">// 控制main task 和后续fork task的关系</span></span><br><span class="line"><span class="comment">// 感觉这个newTask返回的对象就是上面核心概念中说的parent task</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span>(<span class="params">env, mainTask, parentContext, parentEffectId, meta, isRoot, cont = noop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> status = RUNNING</span><br><span class="line">  <span class="keyword">let</span> taskResult</span><br><span class="line">  <span class="keyword">let</span> taskError</span><br><span class="line">  <span class="keyword">let</span> deferredEnd = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cancelledDueToErrorTasks = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(parentContext)</span><br><span class="line">  <span class="comment">// 该函数是fork model的具体实现</span></span><br><span class="line">  <span class="comment">// 由此创建了fork的多分支</span></span><br><span class="line">  <span class="comment">// 具体见forkQueue函数</span></span><br><span class="line">  <span class="keyword">const</span> queue = forkQueue(</span><br><span class="line">    mainTask,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onAbort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      cancelledDueToErrorTasks.push(...queue.getTasks().map(<span class="function"><span class="params">t</span> =&gt;</span> t.meta.name))</span><br><span class="line">    &#125;,</span><br><span class="line">    end,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   This may be called by a parent generator to trigger/propagate cancellation</span></span><br><span class="line"><span class="comment">   cancel all pending tasks (including the main task), then end the current task.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Cancellation propagates down to the whole execution tree held by this Parent task</span></span><br><span class="line"><span class="comment">   It's also propagated to all joiners of this task and their execution tree/joiners</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Cancellation is noop for terminated/Cancelled tasks tasks</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status === RUNNING) &#123;</span><br><span class="line">      <span class="comment">// Setting status to CANCELLED does not necessarily mean that the task/iterators are stopped</span></span><br><span class="line">      <span class="comment">// effects in the iterator's finally block will still be executed</span></span><br><span class="line">      status = CANCELLED</span><br><span class="line">      queue.cancelAll()</span><br><span class="line">      <span class="comment">// Ending with a TASK_CANCEL will propagate the Cancellation to all joiners</span></span><br><span class="line">      end(TASK_CANCEL, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">result, isErr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isErr) &#123;</span><br><span class="line">      <span class="comment">// The status here may be RUNNING or CANCELLED</span></span><br><span class="line">      <span class="comment">// If the status is CANCELLED, then we do not need to change it here</span></span><br><span class="line">      <span class="keyword">if</span> (result === TASK_CANCEL) &#123;</span><br><span class="line">        status = CANCELLED</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status !== CANCELLED) &#123;</span><br><span class="line">        status = DONE</span><br><span class="line">      &#125;</span><br><span class="line">      taskResult = result</span><br><span class="line">      deferredEnd &amp;&amp; deferredEnd.resolve(result)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status = ABORTED</span><br><span class="line">      sagaError.addSagaFrame(&#123; meta, <span class="attr">cancelledTasks</span>: cancelledDueToErrorTasks &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (task.isRoot) &#123;</span><br><span class="line">        <span class="keyword">const</span> sagaStack = sagaError.toString()</span><br><span class="line">        <span class="comment">// we've dumped the saga stack to string and are passing it to user's code</span></span><br><span class="line">        <span class="comment">// we know that it won't be needed anymore and we need to clear it</span></span><br><span class="line">        sagaError.clear()</span><br><span class="line">        env.onError(result, &#123; sagaStack &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      taskError = result</span><br><span class="line">      deferredEnd &amp;&amp; deferredEnd.reject(result)</span><br><span class="line">    &#125;</span><br><span class="line">    task.cont(result, isErr)</span><br><span class="line">    task.joiners.forEach(<span class="function"><span class="params">joiner</span> =&gt;</span> &#123;</span><br><span class="line">      joiner.cb(result, isErr)</span><br><span class="line">    &#125;)</span><br><span class="line">    task.joiners = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setContext</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      check(props, is.object, createSetContextWarning(<span class="string">'task'</span>, props))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assignWithSymbols(context, props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deferredEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> deferredEnd.promise</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferredEnd = deferred()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status === ABORTED) &#123;</span><br><span class="line">      deferredEnd.reject(taskError)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status !== RUNNING) &#123;</span><br><span class="line">      deferredEnd.resolve(taskResult)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deferredEnd.promise</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> task = &#123;</span><br><span class="line">    <span class="comment">// fields</span></span><br><span class="line">    [TASK]: <span class="literal">true</span>,</span><br><span class="line">    id: parentEffectId,</span><br><span class="line">    meta,</span><br><span class="line">    isRoot,</span><br><span class="line">    context,</span><br><span class="line">    joiners: [],</span><br><span class="line">    queue,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    cancel,</span><br><span class="line">    cont,</span><br><span class="line">    end,</span><br><span class="line">    setContext,</span><br><span class="line">    toPromise,</span><br><span class="line">    isRunning: <span class="function"><span class="params">()</span> =&gt;</span> status === RUNNING,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      This method is used both for answering the cancellation status of the task and answering for CANCELLED effects.</span></span><br><span class="line"><span class="comment">      In most cases, the cancellation of a task propagates to all its unfinished children (including</span></span><br><span class="line"><span class="comment">      all forked tasks and the mainTask), so a naive implementation of this method would be:</span></span><br><span class="line"><span class="comment">        `() =&gt; status === CANCELLED || mainTask.status === CANCELLED`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      But there are cases that the task is aborted by an error and the abortion caused the mainTask to be cancelled.</span></span><br><span class="line"><span class="comment">      In such cases, the task is supposed to be aborted rather than cancelled, however the above naive implementation</span></span><br><span class="line"><span class="comment">      would return true for `task.isCancelled()`. So we need make sure that the task is running before accessing</span></span><br><span class="line"><span class="comment">      mainTask.status.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      There are cases that the task is cancelled when the mainTask is done (the task is waiting for forked children</span></span><br><span class="line"><span class="comment">      when cancellation occurs). In such cases, you may wonder `yield io.cancelled()` would return true because</span></span><br><span class="line"><span class="comment">      `status === CANCELLED` holds, and which is wrong. However, after the mainTask is done, the iterator cannot yield</span></span><br><span class="line"><span class="comment">      any further effects, so we can ignore such cases.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      See discussions in #1704</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    isCancelled: <span class="function"><span class="params">()</span> =&gt;</span> status === CANCELLED || (status === RUNNING &amp;&amp; mainTask.status === CANCELLED),</span><br><span class="line">    isAborted: <span class="function"><span class="params">()</span> =&gt;</span> status === ABORTED,</span><br><span class="line">    result: <span class="function"><span class="params">()</span> =&gt;</span> taskResult,</span><br><span class="line">    error: <span class="function"><span class="params">()</span> =&gt;</span> taskError,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="7"><li>forkQueue.js</li></ol><p>forkQueue是fork模型的实现，感觉代码实现很直观。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forkQueue</span>(<span class="params">mainTask, onAbort, cont</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tasks = []</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">let</span> completed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  addTask(mainTask)</span><br><span class="line">  <span class="keyword">const</span> getTasks = <span class="function"><span class="params">()</span> =&gt;</span> tasks</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    onAbort()</span><br><span class="line">    cancelAll()</span><br><span class="line">    cont(err, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addTask</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">    tasks.push(task)</span><br><span class="line">    task.cont = <span class="function">(<span class="params">res, isErr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      remove(tasks, task)</span><br><span class="line">      task.cont = noop</span><br><span class="line">      <span class="keyword">if</span> (isErr) &#123;</span><br><span class="line">        abort(res)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task === mainTask) &#123;</span><br><span class="line">          result = res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tasks.length) &#123;</span><br><span class="line">          completed = <span class="literal">true</span></span><br><span class="line">          cont(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancelAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    completed = <span class="literal">true</span></span><br><span class="line">    tasks.forEach(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</span><br><span class="line">      t.cont = noop</span><br><span class="line">      t.cancel()</span><br><span class="line">    &#125;)</span><br><span class="line">    tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addTask,</span><br><span class="line">    cancelAll,</span><br><span class="line">    abort,</span><br><span class="line">    getTasks,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="8"><li>resolvePromise.js</li></ol><p>proc函数中的runEffect函数中的第一种情况是用来处理promise，比如发ajax请求数据，处理promise使用了resolvePromise，代码如下，也很直观：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cancelPromise = promise[CANCEL]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is.func(cancelPromise)) &#123;</span><br><span class="line">    cb.cancel = cancelPromise</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.then(cb, error =&gt; &#123;</span><br><span class="line">    cb(error, <span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="9"><li>io.js</li></ol><p>runEffect函数中的第三种请求是如果判断传入的参数是effect，则执行effectRunner，先看下effect的工厂函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeEffect = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> (&#123;</span><br><span class="line">  [IO]: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// this property makes all/race distinguishable in generic manner from other effects</span></span><br><span class="line">  <span class="comment">// currently it's not used at runtime at all but it's here to satisfy type systems</span></span><br><span class="line">  combinator: <span class="literal">false</span>,</span><br><span class="line">  type,</span><br><span class="line">  payload,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>makeEffect返回一个纯对象，对象的属性包含了相关信息用于在effectRunner中执行。</p><p>call、put、take、fork、all等effect都是利用在makeEffect构造的。</p><hr><ol start="10"><li>effectRunnerMap.js</li></ol><p>这个函数中包含了各种effect的实际执行环境函数，以runForkEffect函数为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runForkEffect</span>(<span class="params">env, &#123; context, fn, args, detached &#125;, cb, &#123; task: parent &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> taskIterator = createTaskIterator(&#123; context, fn, args &#125;)</span><br><span class="line">  <span class="keyword">const</span> meta = getIteratorMetaInfo(taskIterator, fn)</span><br><span class="line"></span><br><span class="line">  immediately(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行下面这行代码的同时，会启动child的saga</span></span><br><span class="line">    <span class="keyword">const</span> child = proc(env, taskIterator, parent.context, currentEffectId, meta, detached, <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (detached) &#123;</span><br><span class="line">      cb(child)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.isRunning()) &#123;</span><br><span class="line">        <span class="comment">// 此处将fork task装入parent task的queue中</span></span><br><span class="line">        <span class="comment">// 形成多分支</span></span><br><span class="line">        parent.queue.addTask(child)</span><br><span class="line">        cb(child)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.isAborted()) &#123;</span><br><span class="line">        parent.queue.abort(child.error())</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Fork effects are non cancellables</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比下面的runTakeEffect函数，runForkEffect会起一个新的saga，新的saga中有自己的next迭代函数，每一个fork分支对应一个，所以不存在阻塞的问题（这里的阻塞感觉是相对Generator的主执行环境而言，这里没有看到有起其他的工作线程，相对于主线程而言还是要按顺序线性执行）。但其他的effect，比如take，是运行在mainTask所在的那个next中，就出现了等待，常用的call也是这样。另外使用take会使middleware等待出现一个特定的action（其实看源码是通过类型判断的，并没有具体到某一个）这是因为将next传入了channel的队列中，成为了channel的回调，看起来像是middleware的等待。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runTakeEffect</span>(<span class="params">env, &#123; channel = env.channel, pattern, maybe &#125;, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> takeCb = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      cb(input, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnd(input) &amp;&amp; !maybe) &#123;</span><br><span class="line">      cb(TERMINATE)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将next传入channel的队列中</span></span><br><span class="line">    cb(input)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    channel.take(takeCb, is.notUndef(pattern) ? matcher(pattern) : <span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    cb(err, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  cb.cancel = takeCb.cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="卤煮"><a href="#卤煮" class="headerlink" title="卤煮"></a>卤煮</h3><ol><li><code>is</code>文件中有20种对不同类型的判断，感觉多数都用了鸭子类型，鸭子类型牛逼。</li><li><p><code>once</code>，这个函数出自<code>utils</code>文件，用来确保一个函数只执行一次，在underscore中也有这个工具函数，但好像写过去就过去了，实际开发中没有用到过，现在拿出来再熟悉一下，用闭包实现的，很好玩：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/30098155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30098155</a> (这篇文章的前半部分介绍的原理，后半部分举例了fork这个effect的实现和takeEvery这个帮助函数的实现)</li><li><a href="https://zhuanlan.zhihu.com/p/37356948" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37356948</a> (这篇文章讲的很好，只是结构有问题，感觉分块儿来讲第一次看起来一头雾水，但瑕不掩瑜)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redux-saga </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-saga原理学习</title>
      <link href="/2019/09/28/redux-saga%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/28/redux-saga%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这几天看redux-saga的实现原理，英文资料几乎没搜到有讲redux-saga的原理的，基本都是对saga这个概念做了解释。中文资料倒是很多对redux-saga进行原理解释的，看了好多篇，最后留下两篇，记录在文尾的参考资料中。后面再翻看redux-saga的实现原理，先看<a href="https://www.twblogs.net/a/5d037e74bd9eee487be98be1" target="_blank" rel="noopener">参考资料2</a>，再看<a href="https://zhuanlan.zhihu.com/p/30098155" target="_blank" rel="noopener">参考资料1</a>。</p><a id="more"></a><hr><h3 id="effects"><a href="#effects" class="headerlink" title="effects"></a>effects</h3><p>从redux-saga文档的学习中得知，effects就是js的纯对象，是发送给middleware的指令，这些指令描述了middleware应该进行的操作信息，middleware实际执行完毕，将结果返回给Generator。</p><p><a href="https://www.twblogs.net/a/5d037e74bd9eee487be98be1" target="_blank" rel="noopener">参考资料2</a>中讲到这样做的好处是：</p><ul><li>集中处理异步操作，更好的表达复杂的流程控制</li><li>保证action是个纯粹的js对象，风格保持统一</li><li>声明式指令，无需在generator中立即执行，只需通知middleware让其执行；借助generator的next方法，向外部暴露每一个步骤</li></ul><p><a href="https://www.twblogs.net/a/5d037e74bd9eee487be98be1" target="_blank" rel="noopener">参考资料2</a>中总结的常用effect指令：</p><ul><li>put，用来命令middleware向store发起一个action</li><li>take，用来命令middleware在store上等待指定的action。在发起与pattern匹配的action之前，Generator将暂停</li><li>call，用来命令middleware以参数args调用函数fn</li><li>fork，用来命令middleware以非阻塞的形式执行fn</li><li>race，用来命令middleware在多个effect间运行，相当于Promise.race</li><li>all，用来命令middleware并行地运行多个effect，并等待它们全部完成，相当于Promise.all</li></ul><h3 id="Saga中的辅助函数"><a href="#Saga中的辅助函数" class="headerlink" title="Saga中的辅助函数"></a>Saga中的辅助函数</h3><p>看过那么多篇，感觉<a href="https://www.twblogs.net/a/5d037e74bd9eee487be98be1" target="_blank" rel="noopener">参考资料2</a>是唯一对这个做清晰分类总结的，思路是真的牛逼。辅助函数本质是基于各种effect实现的。</p><ul><li>takeEvery(take + fork)</li><li>takeLatest(take + fork + cancel)</li><li>takeLeading(take + call)</li><li>throttle(take + fork + delay)</li><li>debounce(take + fork + delay)</li><li>retry(call + delay)</li></ul><h3 id="redux-saga原理"><a href="#redux-saga原理" class="headerlink" title="redux-saga原理"></a>redux-saga原理</h3><p>下面这张图片出自<a href="https://www.twblogs.net/a/5d037e74bd9eee487be98be1" target="_blank" rel="noopener">参考资料2</a>。</p><p><img src="/images/redux_saga/redux-saga-mechanism.png" alt="redux-saga原理"></p><p>redux-saga的核心包括两部分：channel和task。</p><p>channel用来触发action，以及注册action的回调函数。</p><p>task是Generator函数实际执行的函数，结合递归和Generator的yield以及next完成流程控制。</p><p>下面代码实现了这两个核心模块，出自<a href="https://zhuanlan.zhihu.com/p/30098155" target="_blank" rel="noopener">参考资料1</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">channel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> taker;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">take</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    taker = cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (taker) &#123;</span><br><span class="line">      <span class="keyword">const</span> tempTaker = taker;</span><br><span class="line">      taker = <span class="literal">null</span>;</span><br><span class="line">      tempTaker(input);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    put,</span><br><span class="line">    take,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chan = channel();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">take</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'take'</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">mainSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> action = <span class="keyword">yield</span> take();</span><br><span class="line">  <span class="built_in">console</span>.log(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runTakeEffect</span>(<span class="params">effect, cb</span>) </span>&#123;</span><br><span class="line">  chan.take(<span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">    cb(input);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params">iterator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> iter = iterator();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = iter.next(args);</span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="keyword">const</span> effect = result.value;</span><br><span class="line">      <span class="keyword">if</span> (effect.type === <span class="string">'take'</span>) &#123;</span><br><span class="line">        runTakeEffect(result.value, next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task(mainSaga);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">$btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> action =<span class="string">`action data<span class="subst">$&#123;i++&#125;</span>`</span>;</span><br><span class="line">  chan.put(action);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/30098155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30098155</a> (这个写的很好，九浅一深，手动滑稽)</li><li><a href="https://www.twblogs.net/a/5d037e74bd9eee487be98be1" target="_blank" rel="noopener">https://www.twblogs.net/a/5d037e74bd9eee487be98be1</a> （这个讲的特别清楚，赞！）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redux-saga </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-saga文档学习</title>
      <link href="/2019/09/17/redux-sage%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/17/redux-sage%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>redux-saga学习中。</p><a id="more"></a><h3 id="redux-saga中的重要概念"><a href="#redux-saga中的重要概念" class="headerlink" title="redux-saga中的重要概念"></a>redux-saga中的重要概念</h3><ol><li>saga</li></ol><p>官网中关于saga有这样的描述:</p><blockquote><p>a saga is like a separate thread in your application that’s solely responsible for side effects. </p></blockquote><p><a href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/" target="_blank" rel="noopener">资料2</a>和<a href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part-2/" target="_blank" rel="noopener">资料3</a>中描述了在微服务中的saga模型,我的理解是<code>saga</code>像是一个单位，用于完成一个完整功能,这个完整功能依赖多个有先后依存顺序的事务的执行。文中描述了两种<code>saga</code>的实现，一种是每一个事务顺序执行，当前事务执行完毕向后一个事务发出事件；另一种实现是建立一个saga的协调中心，协调中心负责调度各个事务。</p><p>感觉上面的描述没有指出saga的重点，<a href="https://zhuanlan.zhihu.com/p/41661402" target="_blank" rel="noopener">资料4</a>描述saga的一个特点：</p><blockquote><p>saga需要一个“从中间开始执行”的模式。</p></blockquote><blockquote><p>本质上其实是事务的异常中止和恢复。解决起来也并不复杂：随时保存saga的当前状态，并在异常结束之后恢复状态。</p></blockquote><ol start="2"><li>Effect</li></ol><blockquote><p>Effects are plain JavaScript objects which contain instructions to be fulfilled by the middleware.</p></blockquote><p>Effects的类型是js的空白对象，包含能被middleware执行的指令(原文没写，但感觉就是一个action)。在redux-saga中使用<code>put</code>来发动一个Effect。</p><hr><h3 id="redux-saga的使用"><a href="#redux-saga的使用" class="headerlink" title="redux-saga的使用"></a>redux-saga的使用</h3><p>现在公司的框架使用了antd pro，其中的dva对redux-saga进行了封装，不太清楚原生redux-saga如何使用，现在来学一波，参考资料为<a href="https://redux-saga.js.org/" target="_blank" rel="noopener">redux-saga官网教程</a>，主要目的是：</p><ul><li>熟悉redux-saga中的概念</li><li>熟悉用法，为后面学习设计思想和源码实现打基础</li></ul><ol><li><p>使用saga的步骤</p><ol><li>在单独的文件中创建saga</li><li>向主文件中导入saga，如<code>helloSaga</code></li><li>使用从<code>redux-saga</code>中导入的工厂函数<code>createSagaMiddleware</code>创建中间件<code>sagaMiddleware</code></li><li>使用从<code>redux</code>中导入的<code>applyMiddleware</code>连接第三步创建的中间件<code>sagaMiddleware</code></li><li>使用<code>sagaMiddleware.run(helloSaga)</code>启动saga</li></ol></li><li><p>创建saga</p></li></ol><p><a href="https://redux-saga.js.org/docs/introduction/BeginnerTutorial.html" target="_blank" rel="noopener">参考资料1</a>中有下面的描述：</p><blockquote><p>Sagas are implemented as Generator functions that yield objects to the redux-saga middleware. The yielded objects are a kind of instruction to be interpreted by the middleware. When a Promise is yielded to the middleware, the middleware will suspend the Saga until the Promise completes.</p></blockquote><p>saga这种东西是由生成器函数实现的，生成器函数会给redux-saga的中间件yield（这里没有翻译，是为了表示生成器的运行过程，防止日后再回来看有误解）对象。中间件会将yield的对象翻译成指令。当saga yield一个Promise给中间件的时候，中间件将暂停这个saga的直到Promise有了结果。</p><blockquote><p>Once the Promise is resolved, the middleware will resume the saga, executing code until the next yield.</p></blockquote><p>一旦一个Promise被成功解析，中间件将重启这个saga，执行下一个yield。</p><blockquote><p>put is one example of what we call an Effect. Effects are plain Javascript objects which contain instructions to be fulfilled by the middleware. When a middleware retrives an Effect yielded by a saga, the saga is paused until the Effect is fulfilled.</p></blockquote><p>上面的重点在当一个中间件获得一个saga yield的Effect，saga也会暂停执行直到这个yielded的Effect执行完成(Effect的概念见上)。</p><p>一个列子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> delay(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 下面这行代码指示中间件分发一个`INCREMENT`action</span></span><br><span class="line">  <span class="keyword">yield</span> put(&#123;</span><br><span class="line">    type: <span class="string">'INCREAMENT'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码从saga的视角描述是：incrementAsync这个saga通过调用delay(1000)睡了1s，然后分发了INCREMENT action。</p><ol start="3"><li><p>api</p><ol><li>put：发出一个Effect</li><li>takeEvery：redux-saga提供的辅助函数，作用感觉是监控saga的启动，允许多个fetchData实例同时存在。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'FETCH_REQUESTED'</span>, fetchData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>takeLatest：功能和takeEvery类似，但同时只允许一个saga在运行。</li><li>all：返回由运行多个saga产生的结果组成的数组，多个saga会并行执行。</li><li>call：类似put，返回一个Effect指示中间件使用给定的参数调用给定的函数。事实上，put或call本身不执行dispatch或是异步调用，它们只是返回js中的空对象(plain object)。具体的执行是由中间件来决定，如果Effect的类型是<code>put</code>，中间件就向store分发一个action，如果是一个<code>call</code>类型，就调用这个给定函数。</li><li>take：先看两个例子：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- take --&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; take, put &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFirstThreeTodosCreation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">'TODO_CREATED'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: <span class="string">'SHOW_CONGRATULATION'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- takeEvery --&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; select, takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchAndLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>* <span class="title">logger</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="keyword">yield</span> select()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'action'</span>, action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'state after'</span>, state)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take的工作方式是将暂停这个迭代器，直到一个匹配action被分发。</p><p>官网关于takeEvery的工作原理的说明：</p><blockquote><p>In the case of takeEvery, the invoked tasks have no control on when they’ll be called. They will be invoked again and again on each matching action. They also have no control on when to stop the observation.</p></blockquote><p>翻译：被调用的任务(logger)控制不了它们何时被调用。只要满足匹配项，它们就会一次一次被调用。它们也控制不了何时终止观察过程。</p><p>官网关于take的工作原理的说明：</p><blockquote><p>In the case of take, the control is inverted. Instead of the actions being pushed to the handler tasks, the saga is pulling the action by itself. It looks as if the saga is performing a normal function call action=getNextAction(), which will resolve when the action is dispatched.</p></blockquote><p>翻译：在take的使用中，action是由take主动发起的（这里类似put或者call），和takeEvery将action推向处理任务不同，这个saga(watchFirstThreeTodosCreation)是自己拉取(take)action，就好像调用了一个普通的函数：action=getNextAction()，当action被分发后完成解析。</p><p>看上面的第一个例子，watchFirstThreeTodosCreation运行后，会进入一个次数为三次的循环，每次循环的开始都会暂停在：const action = yield take(‘TODO_CREATED’)处，当这个action(TODO_CREATED)完成分发后，这一行代码执行完，进入下一个循环，重复同样的过程，直到三次结束，最后调用：yield put({type: ‘SHOW_CONGRATULATION’})发出一个Effect，然后就退出了监控，这个迭代器也可以被垃圾回收。</p><p>另外，可以并发的观察多个action：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> take([<span class="string">'LOGOUT'</span>, <span class="string">'LOGIN_ERROR'</span>])</span><br></pre></td></tr></table></figure><ol start="7"><li>fork：当fork一个任务时，这项任务会在后台启动，后续的任务无需等待fork的这项任务完成，实现无阻塞工作流程。</li><li>cancel：取消一个fork的任务</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loginFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;user, password&#125; = <span class="keyword">yield</span> take(<span class="string">'LOGIN_REQUEST'</span>)</span><br><span class="line">    <span class="comment">// fork return a Task object</span></span><br><span class="line">    <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(authorize, user, password)</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take([<span class="string">'LOGOUT'</span>, <span class="string">'LOGIN_ERROR'</span>])</span><br><span class="line">    <span class="keyword">if</span> (action.type === <span class="string">'LOGOUT'</span>)</span><br><span class="line">      <span class="keyword">yield</span> cancel(task)</span><br><span class="line">    <span class="keyword">yield</span> call(Api.clearItem, <span class="string">'token'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cancel一个task，会向下传递，将任务中的任务也取消，比如下例，取消了subtask，同时会取消subtask2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(subtask)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// later</span></span><br><span class="line">  <span class="keyword">yield</span> cancel(task)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">subtask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">yield</span> call(subtask2) <span class="comment">// currently blocked on this call</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">subtask2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">yield</span> call(someApi) <span class="comment">// currently blocked on this call</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>all：并发执行任务，这个在项目中已经接触过了， 如果有一个任务失败了，其他的都会被取消</li><li>race：第一个执行完毕的任务作为最后的结果，其他任务将被自动取消</li></ol></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://redux-saga.js.org/" target="_blank" rel="noopener">https://redux-saga.js.org/</a></li><li><a href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/" target="_blank" rel="noopener">https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/</a></li><li><a href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part-2/" target="_blank" rel="noopener">https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part-2/</a></li><li><a href="https://zhuanlan.zhihu.com/p/41661402" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41661402</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redux-saga </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程学习</title>
      <link href="/2019/09/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>正在学习redux的源码，感觉redux的实现很多地方都是基于函数式编程，函数式编程思想好像也在前端的很多库中都有广泛使用。为了更好的理解redux的源码，加深实现的记忆，也为了帮助日后学习其他库，现在插个空儿，入个函数式编程的门儿。</p><p>学习材料是列在最后的《JS函数式编程指南》的中文译本。</p><a id="more"></a><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="第二章-一等公民的函数"><a href="#第二章-一等公民的函数" class="headerlink" title="第二章 一等公民的函数"></a>第二章 一等公民的函数</h4><p>看过这一章，有两点需要在日后的开发中注意：</p><ol><li>使用函数无论在赋值给变量还是作为参数传入函数，都要注意函数是一等公民</li><li>变量、函数命名时要更具有通用性</li></ol><p>关于上述第一点的理解，若日后不记得，可参考这里的<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#%E4%B8%BA%E4%BD%95%E9%92%9F%E7%88%B1%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91" target="_blank" rel="noopener">例子</a>。</p><hr><h4 id="第三章-纯函数"><a href="#第三章-纯函数" class="headerlink" title="第三章 纯函数"></a>第三章 纯函数</h4><p>这一章主要讲了函数式编程中的重要概念，纯函数，以及纯函数的优点。</p><!-- TODO 这里可以把之前看的redux中关于纯函数的使用放进来 --><ol><li>纯函数的定义</li></ol><blockquote><p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p></blockquote><ol start="2"><li>作用</li></ol><blockquote><p>作用，我们可以理解为一切除结果计算之外发生的事情。</p></blockquote><ol start="3"><li>副作用</li></ol><blockquote><p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p></blockquote><p>副作用可能包含但不限于：</p><ul><li>更改文件系统</li><li>往数据库插入记录</li><li>发送一个http请求</li><li>可变数据</li><li>打印/log</li><li>获取用户输入</li><li>DOM查询</li><li>访问系统状态</li><li>。。。</li></ul><p>概括来讲，只要是跟函数外部环境发生的交互就都是副作用。</p><hr><h4 id="第四章-函数柯里化"><a href="#第四章-函数柯里化" class="headerlink" title="第四章 函数柯里化"></a>第四章 函数柯里化</h4><ol><li>curry的概念</li></ol><blockquote><p>只传给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p></blockquote><p>curry的用途是参数复用，降低通用性，提高适用性。</p><!-- TODO 再看下这个 --><p>文中给出的例子可以进一步参考这里：<a href="https://github.com/lodash/lodash/wiki/FP-Guide#capped-iteratee-arguments" target="_blank" rel="noopener">https://github.com/lodash/lodash/wiki/FP-Guide#capped-iteratee-arguments</a></p><p>文中给出了这样一段:</p><blockquote><p>只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码（boilerplate code）。</p></blockquote><p>未能体会,留下作为未解之谜…</p><ol><li>curry函数的实现</li></ol><p>实现代码来自<a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">参考资料2</a>第二版（使用占位符的第三版判断条件较多，过于复杂）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现方式1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sub_curry的作用就是用一个新的函数包裹原函数，然后给原函数传入之前的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub_curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处实际已经执行</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, length</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">const</span> combined = [fn].concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">      <span class="comment">// 注意：此处sub_curry.apply(this.combined)是执行了</span></span><br><span class="line">      <span class="comment">// 返回一个包裹了原函数和参数的新函数</span></span><br><span class="line">      <span class="comment">// 这个新函数用于获取后续参数</span></span><br><span class="line">      <span class="keyword">return</span> curry(sub_curry.apply(<span class="keyword">this</span>, combined), length - <span class="built_in">arguments</span>.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, aruments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行步骤分析</span></span><br><span class="line"><span class="comment">// 这里fn0是一个纯函数</span></span><br><span class="line"><span class="comment">// curry函数也是一个纯函数</span></span><br><span class="line"><span class="comment">// 下述步骤分析过程</span></span><br><span class="line"><span class="comment">// 使用了纯函数中的`等式推导`</span></span><br><span class="line"><span class="comment">// 也就是`引用透明`</span></span><br><span class="line"><span class="keyword">const</span> fn0 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = curry(fn0);</span><br><span class="line">fn1(<span class="string">'a'</span>, <span class="string">'b'</span>)(<span class="string">'c'</span>)(<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行fn1('a', 'b')时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fn1('a', 'b')相当于</span></span><br><span class="line">curry(fn0)(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">curry(sub_curry(fn0, <span class="string">'a'</span>, <span class="string">'b'</span>));</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">curry(<span class="function"><span class="keyword">function</span>(<span class="params">..</span>) </span>&#123;<span class="keyword">return</span> fn0(<span class="string">'a'</span>, <span class="string">'b'</span>, ...)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行fn1('a', 'b')('c')时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fn1('a', 'b')('c')返回</span></span><br><span class="line">curry(sub_curry(<span class="function"><span class="keyword">function</span>(<span class="params">..</span>) </span>&#123;<span class="keyword">return</span> fn0(<span class="string">'a'</span>, <span class="string">'b'</span>, ...)&#125;, <span class="string">'c'</span>));</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">curry(<span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123;<span class="keyword">return</span> fn0(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, ...)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行fn1('a', ''b)('c')('d')时，此时arguments.length &lt; length 为false，执行fn(arguments)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn0(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, ...);</span><br><span class="line">&#125;)(<span class="string">'d)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 相当于</span></span><br><span class="line"><span class="string">fn0('</span>a<span class="string">', '</span>b<span class="string">', '</span>c<span class="string">', '</span>d<span class="string">');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 函数执行完毕</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// =================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 实现方式2</span></span><br><span class="line"><span class="string">// 这种方式更直观</span></span><br><span class="line"><span class="string">// 每次只组合参数</span></span><br><span class="line"><span class="string">// 最后一次性传入原函数中</span></span><br><span class="line"><span class="string">// 而实现方式1是每次都会向原函数中传入参数但延迟执行</span></span><br><span class="line"><span class="string">function curry(fn, args) &#123;</span></span><br><span class="line"><span class="string">  const length = fn.length;</span></span><br><span class="line"><span class="string">  args = args || [];</span></span><br><span class="line"><span class="string">  return function() &#123;</span></span><br><span class="line"><span class="string">    const _args = args.slice();</span></span><br><span class="line"><span class="string">    let arg, i;</span></span><br><span class="line"><span class="string">    for (i = 0; i &lt; arguments.length; i++) &#123;</span></span><br><span class="line"><span class="string">      arg = arguments[i];</span></span><br><span class="line"><span class="string">      _args.push(arg);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (_args.length &lt; length) &#123;</span></span><br><span class="line"><span class="string">      return curry.call(this, fn, _args);</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">      return fn.apply(this, _args);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>实现的本质是通过高阶函数，利用闭包递归保存每次传入的参数同时延迟业务函数的执行，只有当参数数量等于业务函数参数数量时，才执行业务函数计算结果。</p><hr><h4 id="第五章-组合"><a href="#第五章-组合" class="headerlink" title="第五章 组合"></a>第五章 组合</h4><ol><li>redux中compose的实现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>结合律</li></ol><p>所有的组合都满足结合律。结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。通过这种方式能够构建出很多有用的组合功能。</p><ol start="3"><li>pointfree模式</li></ol><p>函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> associative = compose(f, compose(g, h)) == compose(compose(f, g), h);</span><br></pre></td></tr></table></figure><hr><h4 id="第六章-示例应用"><a href="#第六章-示例应用" class="headerlink" title="第六章 示例应用"></a>第六章 示例应用</h4><ol><li>map 的组合律</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> law = compose(map(f), map(g)) == map(compose(f, g));</span><br></pre></td></tr></table></figure><ol start="2"><li>示例核心代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">requirejs.config(&#123;</span><br><span class="line">  paths: &#123;</span><br><span class="line">    ramda: <span class="string">'https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min'</span>,</span><br><span class="line">    jquery: <span class="string">'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([</span><br><span class="line">  <span class="string">'ramda'</span>,</span><br><span class="line">  <span class="string">'jquery'</span></span><br><span class="line">],</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">_, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> trace = _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">tag, x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tag, x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> Impure = &#123;</span><br><span class="line">    getJSON: _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">callback, url</span>) </span>&#123;</span><br><span class="line">      $.getJSON(url, callback);</span><br><span class="line">    &#125;),</span><br><span class="line">    setHtml: _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">sel, html</span>) </span>&#123;</span><br><span class="line">      $(sel).html(html);</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> url = <span class="function"><span class="keyword">function</span>(<span class="params">term</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://api.flickr.com/services/feeds/photos_public.gne?tags='</span> + term + <span class="string">'&amp;format=json&amp;jsoncallback=?'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> img = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="string">'&lt;img /&gt;'</span>, &#123; <span class="attr">src</span>: url&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一版代码</span></span><br><span class="line">  <span class="keyword">const</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</span><br><span class="line">  <span class="keyword">const</span> srcs = _.compose(_.map(mediaUrl), _.prop(<span class="string">'items'</span>));</span><br><span class="line">  <span class="keyword">const</span> images = _.compose(_.map(img), srcs);</span><br><span class="line">  <span class="keyword">const</span> renderImages = _.compose(Impure.setHtml(<span class="string">'body'</span>), images);</span><br><span class="line">  <span class="keyword">const</span> app = _.compose(Impure.getJSON(renderImages), url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  利用等式推倒以及纯函数的特性</span></span><br><span class="line">  <span class="comment">//  重构</span></span><br><span class="line">  <span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mediaToImg = _.compose(img, mediaUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> images = _.compose(_.map(mediaToImg), _.prop(<span class="string">'items'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  app(<span class="string">'dog'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>跟着写完这个部分的demo，最大的感受就是函数式编程的本质就是数学等式的变换。函数式的写法是写成声明式的而非命令式的。</p><h4 id="第七章-类型系统"><a href="#第七章-类型系统" class="headerlink" title="第七章 类型系统"></a>第七章 类型系统</h4><p>基本没有get到作者的点。。。</p><hr><h4 id="第八章-容器"><a href="#第八章-容器" class="headerlink" title="第八章 容器"></a>第八章 容器</h4><p>functor：是实现了map函数并遵守一些特定规则的容器类型。</p><p>文章描述了三种functor用来解决不同的问题</p><ol><li>Maybe：用来处理空值</li><li>Either：用来处理两个分支，这两个分支各代表一种状态，其和是所有的状态的集合</li><li>IO：延迟非纯操作的执行，将其启动权利交由调用者，转化为纯操作</li><li>Task：这里用到了task，fork，redux-saga中也有相同的概念</li></ol><hr><h4 id="第九章-Monad"><a href="#第九章-Monad" class="headerlink" title="第九章 Monad"></a>第九章 Monad</h4><p>join：合并容器</p><p>chain：链式调用</p><p>of：向容器中加入值</p><p>map：在不脱离容器的情况下使用态射改变值到新的范畴中</p><p>Monad是阻塞的，可以改变容器类型。</p><p>最后讲了他们之间的关系，同一律和结合律，同一律说实话没咋看明白。</p><hr><h4 id="第十章-Applicative-functor"><a href="#第十章-Applicative-functor" class="headerlink" title="第十章 Applicative functor"></a>第十章 Applicative functor</h4><p>ap：就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。</p><p>一个ap的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container.prototype.ap = <span class="function"><span class="keyword">function</span>(<span class="params">other_container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> other_container.map(<span class="keyword">this</span>.__value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Applicative functor是非阻塞的，不会改变容器类型。</p><p>最后又讲了好几个定律：同一律、同态、互换以及组合。</p><p>由于函数式编程能严格遵循这些定律，推导出不同的代码形式，所以如果要深入的话，这些必须得好好学下。不过，目前只是入个门，这些待议。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/</a> （《JS函数式编程指南》）</li><li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/42</a> （关于柯里化的资料）</li><li><a href="https://github.com/lodash/lodash/wiki/FP-Guide#capped-iteratee-arguments" target="_blank" rel="noopener">https://github.com/lodash/lodash/wiki/FP-Guide#capped-iteratee-arguments</a> （lodash中的fp关于《JS函数式编程指南》纯函数部分举的例子的描述）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux源码学习</title>
      <link href="/2019/09/05/redux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/05/redux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>前后学过好几次redux了，感觉这次终于整明白了，嘿嘿嘿嘿嘿。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><a href="https://div.io/topic/1309" target="_blank" rel="noopener">这篇文章</a>解释<code>action</code>函数是：<code>对数据来源做萃取工作的函数</code>。原因是数据来源的多样性，导致数据结构的多样性，<code>action</code>函数就是用来过滤’脏数据’的预处理函数。既可以返回新的数据，也可以只提供线索(只有type，没有payload)。</p><h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><p><a href="https://div.io/topic/1309" target="_blank" rel="noopener">这篇文章</a>解释<code>reducer</code>函数是：<code>迎接action函数返回的线索的数据再处理函数</code>。<code>reducer</code>只是一个模式匹配，负责调用在其他地方定义好的数据处理函数。</p><blockquote><p>reducer 为什么叫 reducer 呢？因为 action 对象各种各样，每种对应某个 case ，但最后都汇总到 state 对象中，从多到一，这是一个减少( reduce )的过程，所以完成这个过程的函数叫 reducer。</p></blockquote><hr><h3 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h3><h4 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h4><p>这个函数存在的意义是为了<code>state</code>的各个子属性嵌套过深，不方便更新的问题。核心代码（去掉辅助函数）如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="comment">// 此处的思路是每传一个action</span></span><br><span class="line">    <span class="comment">// 都会遍历一遍所有的reducer</span></span><br><span class="line">    <span class="comment">// 用hasChanged属性表示是否更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为reducer的default中会返回参数state</span></span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    hasChanged =</span><br><span class="line">      hasChanged || finalReducerKeys.length !== <span class="built_in">Object</span>.keys(state).length</span><br><span class="line">    <span class="comment">// 这里返回新的state还是返回原state的判断可以用于react中使用prevProps和this.props进行比较来工作的生命周期函数中</span></span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，redux的state只能处理一级属性。</p><p><a href="https://div.io/topic/1309" target="_blank" rel="noopener">参考资料1</a>中，有下面这段叙述：</p><blockquote><p>如果不是返回新 state，只是修改旧 state，我们就很难做到「回退/撤销」以及跟踪全局状态。对比两个数据是否同一，也无法用 ===，而得用 deepEqual 深度遍历来对比值，很耗费性能。</p></blockquote><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>这个函数存在的意义是协调<code>state</code>，<code>reducer</code>以及<code>action</code>这三者。</p><p><code>createStore</code>的返回值是一个对象，这个对象只有方法，没有数据属性，使用<code>JSON.stringify</code>系列化得到的是空对象。而<strong>state</strong>包含在执行<code>createStore</code>函数时创建的闭包中，通过公有方法<code>getState</code>来获取，拿到的是state的引用。</p><p>核心逻辑代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// enhancer后面再看</span></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里创建了createStore函数的内部变量</span></span><br><span class="line">  <span class="comment">// 用于后续创建闭包</span></span><br><span class="line">  <span class="comment">// 实际保存state的地方</span></span><br><span class="line">  <span class="keyword">let</span> currentReducer = reducer</span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState</span><br><span class="line">  <span class="keyword">let</span> currentListeners = []</span><br><span class="line">  <span class="keyword">let</span> nextListeners = currentListeners</span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到当前state的引用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'You may not call store.getState() while the reducer is executing. '</span> +</span><br><span class="line">          <span class="string">'The reducer has already received the state as an argument. '</span> +</span><br><span class="line">          <span class="string">'Pass it down from the top reducer instead of reading it from the store.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅执行dispatch之后的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'You may not call store.subscribe() while the reducer is executing. '</span> +</span><br><span class="line">          <span class="string">'If you would like to be notified after the store has been updated, subscribe from a '</span> +</span><br><span class="line">          <span class="string">'component and invoke store.getState() in the callback to access the latest state. '</span> +</span><br><span class="line">          <span class="string">'See https://redux.js.org/api-reference/store#subscribelistener for more details.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里又是一个闭包</span></span><br><span class="line">    <span class="comment">// 每订阅一次就会产生一个这样的标记</span></span><br><span class="line">    <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">'You may not unsubscribe from a store listener while the reducer is executing. '</span> +</span><br><span class="line">            <span class="string">'See https://redux.js.org/api-reference/store#subscribelistener for more details.'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      ensureCanMutateNextListeners()</span><br><span class="line">      <span class="keyword">const</span> index = nextListeners.indexOf(listener)</span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 这里是为了防止内存泄露</span></span><br><span class="line">      currentListeners = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">          <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">          <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 这里直接改变了currentState的引用，改为新的state引用</span></span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里执行所有的回调listeners</span></span><br><span class="line">    <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">      listener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个暂时不管</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This action has a similiar effect to ActionTypes.INIT.</span></span><br><span class="line">    <span class="comment">// Any reducers that existed in both the new and old rootReducer</span></span><br><span class="line">    <span class="comment">// will receive the previous state. This effectively populates</span></span><br><span class="line">    <span class="comment">// the new state tree with any relevant data from the old one.</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.REPLACE &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个暂时不管</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> outerSubscribe = subscribe</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The minimal observable subscription method.</span></span><br><span class="line"><span class="comment">       * @param &#123;Object&#125; observer Any object that can be used as an observer.</span></span><br><span class="line"><span class="comment">       * The observer object should have a `next` method.</span></span><br><span class="line"><span class="comment">       * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can</span></span><br><span class="line"><span class="comment">       * be used to unsubscribe the observable from the store, and prevent further</span></span><br><span class="line"><span class="comment">       * emission of values from the observable.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      subscribe(observer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> observer !== <span class="string">'object'</span> || observer === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected the observer to be an object.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">observeState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (observer.next) &#123;</span><br><span class="line">            observer.next(getState())</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        observeState()</span><br><span class="line">        <span class="keyword">const</span> unsubscribe = outerSubscribe(observeState)</span><br><span class="line">        <span class="keyword">return</span> &#123; unsubscribe &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      [$$observable]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When a store is created, an "INIT" action is dispatched so that every</span></span><br><span class="line">  <span class="comment">// reducer returns their initial state. This effectively populates</span></span><br><span class="line">  <span class="comment">// the initial state tree.</span></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h3><p>到这个函数的时，模式从最初的<code>reducer(state, action)</code>通过<code>createStore(reducers, initialState)</code>转换为<code>store.dispatch(action)</code>，这一过程从始至终贯彻了函数式编程的思想，从两个参数转换为一个参数。在使用<code>store.dispatch(action)</code>时，面临一个问题，就是<strong>action</strong>可能是一个’action对象’，也可能是一个’action工程函数’，这就又给<code>store.dispatch(action)</code>的使用带来了问题，bindActionCreators函数的出现就是为了解决这个问题。</p><p>下面是这个函数的核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> actionCreators) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可以看出，使用bindActionCreators可以得到真正具有改变全局state能力的许多函数，剩下的事情，就是将这些函数分发到各个地方，由各个event自主调用即可（引自<a href="https://div.io/topic/1309" target="_blank" rel="noopener">参考资料1</a>）。</p><h3 id="redux的工作流程"><a href="#redux的工作流程" class="headerlink" title="redux的工作流程"></a>redux的工作流程</h3><!-- TODO 这里要和antd pro的使用比较一下 --><ol><li>设计全局state的数据结构</li><li>设计更改state数据的actionTypes常量以及其他跟视图展现相关的actionTypes常量</li><li>根据actionTypes常量，书写actionCreator</li><li>根据各个actionCreator的返回值，设计reducer做数据的最后处理</li><li>在有了reducer函数之后，createStore(reducer, initState)得到store对象</li><li>用bindActionCreators函数将actionCreators和store.dispatch绑定起来，得到一组能够修改全局状态的函数</li><li>分发各个状态修改函数到各个DOM事件中</li></ol><h3 id="applyMiddlewares"><a href="#applyMiddlewares" class="headerlink" title="applyMiddlewares"></a>applyMiddlewares</h3><p>关于这部分，主要参考<a href="https://www.beansmile.com/blog/posts/redux-apply-middleware-source-code-analysis" target="_blank" rel="noopener">参考资料3</a></p><ol><li>中间件基本原理</li></ol><p>这里的中间件同样使用了洋葱模型，利用函数式编程中的<em>组合</em>方式，逐层强化dispatch。原理说明见下面的代码（引自<a href="https://www.beansmile.com/blog/posts/redux-apply-middleware-source-code-analysis" target="_blank" rel="noopener">参考资料3</a>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originDispatch = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middleware1 = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware1 before dispatch'</span>)</span><br><span class="line">    dispatch(...args)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware1 after dispatch'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middleware2 = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware2 before dispatch'</span>)</span><br><span class="line">    dispatch(...args)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware2 before dispatch'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">originDispatch = middleware2(middleware1(originDispatch))</span><br><span class="line">originDispatch(<span class="string">'ruby'</span>, <span class="string">'cool'</span>, <span class="string">'language'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// middleware2 before dispatch</span></span><br><span class="line"><span class="comment">// middleware1 before dispatch</span></span><br><span class="line"><span class="comment">// ruby cool language</span></span><br><span class="line"><span class="comment">// middleware1 after dispatch</span></span><br><span class="line"><span class="comment">// middleware2 before dispatch</span></span><br></pre></td></tr></table></figure><ol start="2"><li>compose的工作过程</li></ol><p>下面的代码引自<a href="https://www.beansmile.com/blog/posts/redux-apply-middleware-source-code-analysis" target="_blank" rel="noopener">参考资料3</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compose(f1, f2, f3, f4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作过程</span></span><br><span class="line"><span class="comment">// a: f1, b: f2, return: (...args) =&gt; f1(f2(...args))</span></span><br><span class="line"><span class="comment">// a: (...args) =&gt; f1(f2(...args)), b: f3, return: (...args) =&gt; f1(f2(f3(...args)))</span></span><br><span class="line"><span class="comment">// a: (...args) =&gt; f1(f2(f3(...args))), b: f4, return: (...args) =&gt; f1(f2(f3(f4(...args))))</span></span><br></pre></td></tr></table></figure><p>compose源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述工作过程的描述和源码中可以看出，函数嵌套的顺序和入参散列函数的顺序一致，越靠近左侧，越处于嵌套外层。compose函数在这里的作用就是层层强化dispatch函数。</p><ol start="3"><li>applyMiddleware源码</li></ol><p>这个函数的核心目的就是强化dispatch。</p><p>源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处的createStore入参为上面提到的createStore</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="comment">// 这里的dispatch形成了一个闭包</span></span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Dispatching while constructing your middleware is not allowed. '</span> +</span><br><span class="line">          <span class="string">'Other middleware would not be applied to this dispatch.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args) <span class="comment">// 在此定义处，dispatch函数即是上面定义的函数，抛出一个错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI)) <span class="comment">// 此处返回的middleware(middlewareAPI)表示的是下面叙述中的第二、三层也就是待传入dispatch返回强化后的dispatch函数</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch) <span class="comment">// 在中间件真正执行的时候，传入其中的dispatch都是在此处定义的"全量增强"的dispatch。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是一个dispatch增强了的store</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>一个中间件的示例</li></ol><p>下面示例代码出自<a href="https://www.beansmile.com/blog/posts/redux-apply-middleware-source-code-analysis" target="_blank" rel="noopener">参考资料3</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Logger = <span class="function">(<span class="params">store</span>) =&gt;</span> (dispatch) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> wrappedDispatch = store.dispatch</span><br><span class="line">    <span class="keyword">const</span> getState = store.getState</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before dispatch'</span>, getState())</span><br><span class="line">    dispatch(...args)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after dispatch'</span>, getState())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(dispatch)</span><br><span class="line">    <span class="built_in">console</span>.info(wrappedDispatch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的store入参的结构参考上面<code>middlewareAPI</code>的结构，每个中间件实际是嵌套了三层的函数：</p><ul><li>第一层函数：参数有两个，一个是最外层最初定义的<code>dispatch</code>，一个是获取store中数据的<code>getState</code></li><li>第二层函数：参数有一个，是强化了的dispatch，来源是compose函数中的嵌套函数，当前中间件此处的dispatch来自其入参函数，从applyMiddleware源码中可以看到，最后一个中间件函数的入参函数包裹的是redux原生定义的dispatch。这是第二层中的dispatch和第一层中的dispatch的不同</li><li>第三层函数：这个函数整体作为强化后的disptach函数，传入其他的中间件中，其参数有一个，可以认为是action，这一点可以从上面中间件原理中看出</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://div.io/topic/1309" target="_blank" rel="noopener">https://div.io/topic/1309</a> （applyMiddleware部分没有讲清楚，其他可以）</li><li><a href="https://github.com/ecmadao/Coding-Guide/blob/master/Notes/React/Redux/" target="_blank" rel="noopener">https://github.com/ecmadao/Coding-Guide/blob/master/Notes/React/Redux/</a> Redux%E5%85%A5%E5%9D%91%E8%BF%9B%E9%98%B6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md#applymiddleware （函数式编程部分可以）</li><li><a href="https://www.beansmile.com/blog/posts/redux-apply-middleware-source-code-analysis" target="_blank" rel="noopener">https://www.beansmile.com/blog/posts/redux-apply-middleware-source-code-analysis</a> （专门讲applyMIddleware的，可以）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片上传</title>
      <link href="/2019/08/03/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/03/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>过去一个月开发了公司了图片上传和图片选择两个模块，基本明白了图片上传经历的各个阶段和处理方式，现总结如下。</p><a id="more"></a><h1 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h1><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><ol><li><p>参考</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file</a></li></ul></li><li><p>标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"file"</span> accept=<span class="string">"image/*"</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-图片文件"><a href="#2-图片文件" class="headerlink" title="2. 图片文件"></a>2. 图片文件</h3><ol><li><p>参考</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/File</a></li></ul></li><li><p>属性(只读)</p><ul><li><p>File.lasterModified</p></li><li><p>File.lastModifiedDate</p></li><li><p>File.name</p></li><li><p>File.webkitRelativePath</p></li><li><p>File.size</p></li><li><p>File.type</p></li></ul></li></ol><h3 id="3-图片处理"><a href="#3-图片处理" class="headerlink" title="3. 图片处理"></a>3. 图片处理</h3><ol><li><p>获取图片内容</p><ol><li><p>FileReader</p><ol><li><p>参考</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/FileReader</a></li></ul></li><li><p>用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getBase64 = <span class="function">(<span class="params">img, cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> size = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.src = reader.result;</span><br><span class="line">    image.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      size.width = image.width;</span><br><span class="line">      size.height = image.height;</span><br><span class="line">      cb(reader.result, size, img.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  reader.addEventListener(<span class="string">'error'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;);</span><br><span class="line">  reader.readAsDataURL(img);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>URL.createObjectURL</p><ol><li><p>参考</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a></li></ul></li><li><p>用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.src = <span class="built_in">window</span>.URL.createObjectURL(file);</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>图片压缩</p><ol><li><p>方法</p><ul><li>使用canvas重绘</li><li>图片输出时降低图片质量</li></ul></li><li><p>参考</p><ol><li>压缩：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage</a></li><li>输出为base64： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL</a></li><li>输出为Blob： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob</a></li></ol></li><li><p>用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MEASURE_SIZE = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">previewImage</span>(<span class="params">file: File | Blob</span>): <span class="title">Promise</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isImageFileType(file.type)) &#123;</span><br><span class="line">      resolve(<span class="string">''</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    canvas.width = MEASURE_SIZE;</span><br><span class="line">    canvas.height = MEASURE_SIZE;</span><br><span class="line">    canvas.style.cssText = <span class="string">`position: fixed; left: 0; top: 0; width: <span class="subst">$&#123;MEASURE_SIZE&#125;</span>px; height: <span class="subst">$&#123;MEASURE_SIZE&#125;</span>px; z-index: 9999; display: none;`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line">    <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; width, height &#125; = img;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> drawWidth = MEASURE_SIZE;</span><br><span class="line">      <span class="keyword">let</span> drawHeight = MEASURE_SIZE;</span><br><span class="line">      <span class="keyword">let</span> offsetX = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> offsetY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (width &lt; height) &#123;</span><br><span class="line">        drawHeight = height * (MEASURE_SIZE / width);</span><br><span class="line">        offsetY = -(drawHeight - drawWidth) / <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        drawWidth = width * (MEASURE_SIZE / height);</span><br><span class="line">        offsetX = -(drawWidth - drawHeight) / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ctx!.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);</span><br><span class="line">      <span class="keyword">const</span> dataURL = canvas.toDataURL();</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(canvas);</span><br><span class="line"></span><br><span class="line">      resolve(dataURL);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = <span class="built_in">window</span>.URL.createObjectURL(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>图片输出</p><ol><li>base64：字符串</li><li>Blob：文件对象</li></ol></li><li><p>图片预览</p><ol><li><p>方法</p><ul><li>将base64编码赋值给img.src</li><li>直接画到canvas画布上</li></ul></li><li><p>用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; listType, items, previewFile &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">if</span> (listType !== <span class="string">'picture'</span> &amp;&amp; listType !== <span class="string">'picture-card'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (items || []).forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isValidateFile =</span><br><span class="line">      file.originFileObj <span class="keyword">instanceof</span> File || file.originFileObj <span class="keyword">instanceof</span> Blob;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'undefined'</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ||</span><br><span class="line">      !(<span class="built_in">window</span> <span class="keyword">as</span> any).FileReader ||</span><br><span class="line">      !(<span class="built_in">window</span> <span class="keyword">as</span> any).File ||</span><br><span class="line">      !isValidateFile ||</span><br><span class="line">      file.thumbUrl !== <span class="literal">undefined</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    file.thumbUrl = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (previewFile) &#123;</span><br><span class="line">      previewFile(file.originFileObj <span class="keyword">as</span> File).then(<span class="function">(<span class="params">previewDataUrl: string</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Need append '' to avoid dead loop</span></span><br><span class="line">        file.thumbUrl = previewDataUrl || <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.forceUpdate();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="4-图片上传"><a href="#4-图片上传" class="headerlink" title="4. 图片上传"></a>4. 图片上传</h3><ol><li><p>上传策略</p><ul><li><p>并发无控制传输</p><ul><li><p>http1.1和http2协议下的并发数量限制</p></li><li><p>实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uploadFiles = <span class="function">(<span class="params">files</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> postFiles = <span class="built_in">Array</span>.prototype.slice.call(files);</span><br><span class="line">  postFiles</span><br><span class="line">    .map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">      file.uid = getUid();</span><br><span class="line">      <span class="keyword">return</span> file;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.upload(file, postFiles);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>并发控制</p><ul><li><p>实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(num, data, func, handleSuccess, handleErr, handleEnd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num; <span class="comment">// 这个属性用来控制transmitter的数量</span></span><br><span class="line">    <span class="keyword">this</span>.data = data; <span class="comment">// 这个属性是数组类型，保存任务队列</span></span><br><span class="line">    <span class="keyword">this</span>.func = func; <span class="comment">// 这个函数用来实际处理异步任务</span></span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">-1</span>; <span class="comment">// 这个属性用来存储当前的任务指针</span></span><br><span class="line">    <span class="keyword">this</span>.handleSuccess = handleSuccess || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 所有任务处理完成的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.len = data.length; <span class="comment">// 任务的数量</span></span><br><span class="line">    <span class="keyword">this</span>.handleErr = handleErr || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 任务失败的处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.handleEnd = handleEnd || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 所有任务执行完一次后的处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.currentTask = []; <span class="comment">// 这个属性用来保存当前正在执行的三个任务，随index的变化动态替换</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="number">-1</span>; <span class="comment">// 这个属性用来用来当停止任务时，记录执行到的文件指针，用于后面恢复，此处没有具体用到，仅留出这个字段</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数拆出来是十分有必要的</span></span><br><span class="line">  <span class="comment">// 写成这种形式，就把图片的上传过程单独封装了</span></span><br><span class="line">  <span class="comment">// 上传成功也好，失败也好都封装在自己的过程里</span></span><br><span class="line">  <span class="comment">// 对于整个对列的上传过程而言都是经历了上传并且已经结束</span></span><br><span class="line">  handleTask = <span class="keyword">async</span> (data, index) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; func &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> func(data, index);</span><br><span class="line">      <span class="keyword">this</span>.handleSuccess(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleErr(e, data[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里保存当前队列执行的上传任务</span></span><br><span class="line">  <span class="comment">// 并启动任务</span></span><br><span class="line">  <span class="comment">// 在上传队列没有文件的时候</span></span><br><span class="line">  <span class="comment">// 还会判断所有上传过程是否完成，并执行最终的回调函数</span></span><br><span class="line">  executeTask = <span class="keyword">async</span> (index, data, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTask[i] = <span class="keyword">this</span>.handleTask(data, index);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.currentTask[i];</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> === <span class="keyword">this</span>.len) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.currentTask);</span><br><span class="line">      <span class="keyword">this</span>.handleEnd();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义的每个上传队列执行的规则</span></span><br><span class="line">  <span class="comment">// 有任务时，执行任务并等待任务结束</span></span><br><span class="line">  <span class="comment">// 结束后如果文件队列中还有文件就取文件开始上传</span></span><br><span class="line">  transmit = <span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    <span class="keyword">while</span> (currentData) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.executeTask(<span class="keyword">this</span>.index, currentData, i);</span><br><span class="line">      currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里同步创建上传队列</span></span><br><span class="line">  <span class="comment">// 并启动上传过程</span></span><br><span class="line">  createTransmitor = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; num &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.transmit(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里用来等待已经触发的异步过程</span></span><br><span class="line">  <span class="comment">// 当已经触发的异步过程结束</span></span><br><span class="line">  <span class="comment">// 停止队列操作</span></span><br><span class="line">  stopTransmite = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.index;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="keyword">this</span>.len;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.currentTask);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个方法实现了暂停后继续操作</span></span><br><span class="line">  <span class="comment">// 目前还没有使用</span></span><br><span class="line">  continueTransmite = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="keyword">this</span>.currentIndex;</span><br><span class="line">    <span class="keyword">this</span>.createTransmitor();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Transmition;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>两种方式的比较</p><ul><li>无控制并发不一定快</li><li>并发控制可减小后台压力</li></ul></li><li><p>无并发</p><p>无并发指的是所有图片使用一个请求进行上传。</p><p>使用这种方式有两个不足，详见<a href="https://medium.com/typecode/a-strategy-for-handling-multiple-file-uploads-using-javascript-eb00a77e15f" target="_blank" rel="noopener">参考资料2</a>和<a href="https://my.oschina.net/kisshua/blog/701606" target="_blank" rel="noopener">3</a>：</p><ol><li>一个链接无法最大限度利用网络性能，传输时长会比较长</li><li>错误无法隔离，一个错误会导致整个重传</li></ol></li></ul></li></ol><ol><li><p>传输的数据格式</p><p>传输介质使用FormData，以base64或者Blob的格式都可以，后者方便后端处理。</p></li></ol><h1 id="Antd的图片上传实现"><a href="#Antd的图片上传实现" class="headerlink" title="Antd的图片上传实现"></a>Antd的图片上传实现</h1><h3 id="1-基本结构-1"><a href="#1-基本结构-1" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><ol><li>底层处理逻辑<ul><li>基本结构</li><li>图片文件</li><li>图片上传</li></ul></li><li>上层处理样式、交互及使用场景<ul><li>图片处理</li><li>压缩</li><li>列表展示</li><li>属性添加</li><li>定义传输过程中交互</li></ul></li></ol><h3 id="2-暴露的接口"><a href="#2-暴露的接口" class="headerlink" title="2. 暴露的接口"></a>2. 暴露的接口</h3><p>​    Antd的Upload组件一共暴露了21个接口：</p><table><thead><tr><th style="text-align:left">暴露位置</th><th style="text-align:left">接口</th></tr></thead><tbody><tr><td style="text-align:left">上层</td><td style="text-align:left">defaultFileList、fileList、listType、previewFile、onPreview、showUploadList、onChange、onRemove、supportServerRender</td></tr><tr><td style="text-align:left">底层</td><td style="text-align:left">directory、disabled、multiple、withCredentials、beforeUpload、customRequest、accept、action、data、headers、name、openFileDialogOnClick</td></tr></tbody></table><h3 id="3-传输策略"><a href="#3-传输策略" class="headerlink" title="3. 传输策略"></a>3. 传输策略</h3><ol><li><p>默认并发无控制</p></li><li><p>给出了改变策略的接口</p></li></ol><h3 id="4-Antd中一个详细ajax传输的实现"><a href="#4-Antd中一个详细ajax传输的实现" class="headerlink" title="4. Antd中一个详细ajax传输的实现"></a>4. Antd中一个详细ajax传输的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getError</span>(<span class="params">option, xhr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">`cannot post <span class="subst">$&#123;option.action&#125;</span> <span class="subst">$&#123;xhr.status&#125;</span>'`</span>;</span><br><span class="line">  <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">  err.status = xhr.status;</span><br><span class="line">  err.method = <span class="string">'post'</span>;</span><br><span class="line">  err.url = option.action;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBody</span>(<span class="params">xhr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> text = xhr.responseText || xhr.response;</span><br><span class="line">  <span class="keyword">if</span> (!text) &#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// option &#123;</span></span><br><span class="line"><span class="comment">//  onProgress: (event: &#123; percent: number &#125;): void,</span></span><br><span class="line"><span class="comment">//  onError: (event: Error, body?: Object): void,</span></span><br><span class="line"><span class="comment">//  onSuccess: (body: Object): void,</span></span><br><span class="line"><span class="comment">//  data: Object,</span></span><br><span class="line"><span class="comment">//  filename: String,</span></span><br><span class="line"><span class="comment">//  file: File,</span></span><br><span class="line"><span class="comment">//  withCredentials: Boolean,</span></span><br><span class="line"><span class="comment">//  action: String,</span></span><br><span class="line"><span class="comment">//  headers: Object,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (option.onProgress &amp;&amp; xhr.upload) &#123;</span><br><span class="line">    xhr.upload.onprogress = <span class="function"><span class="keyword">function</span> <span class="title">progress</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        e.percent = e.loaded / e.total * <span class="number">100</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      option.onProgress(e);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (option.data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(option.data).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      formData.append(key, option.data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  formData.append(option.filename, option.file);</span><br><span class="line"></span><br><span class="line">  xhr.onerror = <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    option.onError(e);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> <span class="title">onload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// allow success when 2xx status</span></span><br><span class="line">    <span class="comment">// see https://github.com/react-component/upload/issues/34</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.status &lt; <span class="number">200</span> || xhr.status &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> option.onError(getError(option, xhr), getBody(xhr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    option.onSuccess(getBody(xhr), xhr);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  xhr.open(<span class="string">'post'</span>, option.action, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179</span></span><br><span class="line">  <span class="keyword">if</span> (option.withCredentials &amp;&amp; <span class="string">'withCredentials'</span> <span class="keyword">in</span> xhr) &#123;</span><br><span class="line">    xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> headers = option.headers || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when set headers['X-Requested-With'] = null , can close default XHR header</span></span><br><span class="line">  <span class="comment">// see https://github.com/react-component/upload/issues/33</span></span><br><span class="line">  <span class="keyword">if</span> (headers[<span class="string">'X-Requested-With'</span>] !== <span class="literal">null</span>) &#123;</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'X-Requested-With'</span>, <span class="string">'XMLHttpRequest'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> h <span class="keyword">in</span> headers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (headers.hasOwnProperty(h) &amp;&amp; headers[h] !== <span class="literal">null</span>) &#123;</span><br><span class="line">      xhr.setRequestHeader(h, headers[h]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(formData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    abort() &#123;</span><br><span class="line">      xhr.abort();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ol><li><a href="https://blog.hhking.cn/2018/11/29/html5-img-upload/" target="_blank" rel="noopener">https://blog.hhking.cn/2018/11/29/html5-img-upload/</a></li><li><a href="https://medium.com/typecode/a-strategy-for-handling-multiple-file-uploads-using-javascript-eb00a77e15f" target="_blank" rel="noopener">https://medium.com/typecode/a-strategy-for-handling-multiple-file-uploads-using-javascript-eb00a77e15f</a></li><li><a href="https://my.oschina.net/kisshua/blog/701606" target="_blank" rel="noopener">https://my.oschina.net/kisshua/blog/701606</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu使用配置</title>
      <link href="/2019/08/02/ubuntu%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/08/02/ubuntu%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>这篇用来整理记录ubuntu的当前使用配置，内容包括：</p><ol><li>强化Gnome桌面</li><li>强化触摸板</li><li>优化终端</li><li>快捷键的设置及二狗蛋的配合使用</li><li>bug解决</li><li>待继续探索的区域</li></ol><a id="more"></a><h2 id="1-强化Gnome桌面"><a href="#1-强化Gnome桌面" class="headerlink" title="1. 强化Gnome桌面"></a>1. 强化Gnome桌面</h2><h3 id="gnome-tweaks"><a href="#gnome-tweaks" class="headerlink" title="gnome-tweaks"></a>gnome-tweaks</h3><ul><li><p>外观</p><ul><li>主题库：<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">https://www.gnome-look.org/</a></li><li>使用：下载后，在gnome-tweaks的外观中依次设置<em>主题（目前用的Qogir）</em>、<em>图标(目前用的Newaita)</em>、<em>Shell(目前用的Qogir-dark)</em>（先安装user themes）。</li></ul></li><li><p>字体</p><ul><li>缩放比例：当前1.5</li></ul></li><li><p>工作区</p><ul><li>静态工作区</li><li>数量4</li><li>只在主显示屏上显示工作区</li></ul></li><li><p>开机启动程序</p><ul><li>fusuma</li><li>终端</li></ul></li><li><p>扩展</p><ul><li>chrome中安装：Gnome shell integration，用来方便的安装插件</li><li>ubuntu appindicators：不记得这个干嘛的了…</li><li>Disable workspace switcher popup:用来禁掉switching bar</li><li>ubuntu dock：设置dock</li><li>user themes：加载自定义主题，安装这个才能实现上面说的更改主题</li><li><p>workspace grid: 更改工作区行为</p><p><img src="/images/ubuntu/工作区配置.png" alt="工作区配置"></p></li></ul></li><li><p>桌面</p><p>当前桌面图标打开，其他都关闭</p></li></ul><hr><h3 id="2-强化触摸板"><a href="#2-强化触摸板" class="headerlink" title="2. 强化触摸板"></a>2. 强化触摸板</h3><ul><li>安装fusuma：<a href="https://github.com/iberianpig/fusuma#installation" target="_blank" rel="noopener">https://github.com/iberianpig/fusuma#installation</a></li><li><p>当前配置：</p><ul><li>位置：<code>~/.config/fusuma</code></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">swipe:</span><br><span class="line">  3: </span><br><span class="line">    left: </span><br><span class="line">      shortcut: &apos;alt+Left&apos;</span><br><span class="line">    right: </span><br><span class="line">      shortcut: &apos;alt+Right&apos;</span><br><span class="line">    up: </span><br><span class="line">      shortcut: &apos;ctrl+t&apos;</span><br><span class="line">    down: </span><br><span class="line">      shortcut: &apos;ctrl+w&apos;</span><br><span class="line">  4:</span><br><span class="line">    left: </span><br><span class="line">      shortcut: &apos;ctrl+alt+Down&apos;</span><br><span class="line">    right: </span><br><span class="line">      shortcut: &apos;ctrl+alt+Up&apos;</span><br><span class="line">    up: </span><br><span class="line">      shortcut: &apos;alt+Tab&apos;</span><br><span class="line">    down: </span><br><span class="line">      shortcut: &apos;super&apos;</span><br><span class="line">pinch:</span><br><span class="line">  in:</span><br><span class="line">    shortcut: &apos;&apos;</span><br><span class="line">  out:</span><br><span class="line">    shortcut: &apos;&apos;</span><br><span class="line">  </span><br><span class="line">threshold:</span><br><span class="line">  swipe: 0.6</span><br><span class="line">  pinch: 1</span><br><span class="line"></span><br><span class="line">interval:</span><br><span class="line">  swipe: 0.5</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="3-优化终端"><a href="#3-优化终端" class="headerlink" title="3. 优化终端"></a>3. 优化终端</h2><ul><li><p>安装oh-my-zsh</p><ul><li>字符不能正确显示需要先安装powerline</li><li>当前配置<ul><li>位置：<code>~/.zshrc</code></li><li>配置：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"># If you come from bash you might have to change your $PATH.</span><br><span class="line"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span><br><span class="line">export PATH=$PATH:/opt/google/chrome</span><br><span class="line"></span><br><span class="line"># java alg4.jar 环境变量</span><br><span class="line">export CLASSPATH=$CLASSPATH:~/algs4/algs4.jar</span><br><span class="line"></span><br><span class="line"># Path to your oh-my-zsh installation.</span><br><span class="line">  export ZSH=&quot;/home/yangyin/.oh-my-zsh&quot;</span><br><span class="line">  export CLASSPATH=$CLASSPATH:/home/yangyin/others/algs4.jar</span><br><span class="line"></span><br><span class="line"># Set name of the theme to load --- if set to &quot;random&quot;, it will</span><br><span class="line"># load a random theme each time oh-my-zsh is loaded, in which case,</span><br><span class="line"># to know which specific one was loaded, run: echo $RANDOM_THEME</span><br><span class="line"># See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span><br><span class="line"># ZSH_THEME=&quot;robbyrussell&quot;</span><br><span class="line">ZSH_THEME=&quot;agnoster&quot;</span><br><span class="line"></span><br><span class="line"># Set list of themes to pick from when loading at random</span><br><span class="line"># Setting this variable when ZSH_THEME=random will cause zsh to load</span><br><span class="line"># a theme from this variable instead of looking in ~/.oh-my-zsh/themes/</span><br><span class="line"># If set to an empty array, this variable will have no effect.</span><br><span class="line"># ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to use case-sensitive completion.</span><br><span class="line"># CASE_SENSITIVE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to use hyphen-insensitive completion.</span><br><span class="line"># Case-sensitive completion must be off. _ and - will be interchangeable.</span><br><span class="line"># HYPHEN_INSENSITIVE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to disable bi-weekly auto-update checks.</span><br><span class="line"># DISABLE_AUTO_UPDATE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to change how often to auto-update (in days).</span><br><span class="line"># export UPDATE_ZSH_DAYS=13</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to disable colors in ls.</span><br><span class="line"># DISABLE_LS_COLORS=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to disable auto-setting terminal title.</span><br><span class="line"># DISABLE_AUTO_TITLE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to enable command auto-correction.</span><br><span class="line"># ENABLE_CORRECTION=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to display red dots whilst waiting for completion.</span><br><span class="line"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line if you want to disable marking untracked files</span><br><span class="line"># under VCS as dirty. This makes repository status check for large repositories</span><br><span class="line"># much, much faster.</span><br><span class="line"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line if you want to change the command execution time</span><br><span class="line"># stamp shown in the history command output.</span><br><span class="line"># You can set one of the optional three formats:</span><br><span class="line"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span><br><span class="line"># or set a custom format using the strftime function format specifications,</span><br><span class="line"># see &apos;man strftime&apos; for details.</span><br><span class="line"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span><br><span class="line"></span><br><span class="line"># Would you like to use another custom folder than $ZSH/custom?</span><br><span class="line"># ZSH_CUSTOM=/path/to/new-custom-folder</span><br><span class="line"></span><br><span class="line"># Which plugins would you like to load?</span><br><span class="line"># Standard plugins can be found in ~/.oh-my-zsh/plugins/*</span><br><span class="line"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span><br><span class="line"># Example format: plugins=(rails git textmate ruby lighthouse)</span><br><span class="line"># Add wisely, as too many plugins slow down shell startup.</span><br><span class="line">plugins=(git)</span><br><span class="line"></span><br><span class="line">source $ZSH/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"># User configuration</span><br><span class="line"></span><br><span class="line"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span><br><span class="line"></span><br><span class="line"># You may need to manually set your language environment</span><br><span class="line"># export LANG=en_US.UTF-8</span><br><span class="line"></span><br><span class="line"># Preferred editor for local and remote sessions</span><br><span class="line"># if [[ -n $SSH_CONNECTION ]]; then</span><br><span class="line">#   export EDITOR=&apos;vim&apos;</span><br><span class="line"># else</span><br><span class="line">#   export EDITOR=&apos;mvim&apos;</span><br><span class="line"># fi</span><br><span class="line"></span><br><span class="line"># If not running interactively, do not do anything</span><br><span class="line"># 自启动tmux</span><br><span class="line">[[ $- != *i* ]] &amp;&amp; return</span><br><span class="line">[[ -z &quot;$TMUX&quot; ]] &amp;&amp; exec tmux</span><br><span class="line"></span><br><span class="line"># Compilation flags</span><br><span class="line"># export ARCHFLAGS=&quot;-arch x86_64&quot;</span><br><span class="line"></span><br><span class="line"># ssh</span><br><span class="line"># export SSH_KEY_PATH=&quot;~/.ssh/rsa_id&quot;</span><br><span class="line"></span><br><span class="line"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span><br><span class="line"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span><br><span class="line"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span><br><span class="line"># For a full list of active aliases, run `alias`.</span><br><span class="line">#</span><br><span class="line"># Example aliases</span><br><span class="line"># alias zshconfig=&quot;mate ~/.zshrc&quot;</span><br><span class="line"># alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># ydict查词</span><br><span class="line">alias dd=&quot;ydict&quot;</span><br><span class="line">#启动微信小程序工具</span><br><span class="line">alias ww=&quot;bash ~/ginnko/wechat_web_devtools/bin/wxdt&quot;</span><br><span class="line">#启动mongodb可视化工具Robomongo</span><br><span class="line"># 二进制程序使用 exec 关键字</span><br><span class="line">alias ro=&quot;exec /home/yangyin/ginnko/robo3t/bin/robo3t&quot;</span><br><span class="line">#mongodb的启动、停止和重启</span><br><span class="line">alias mgstart=&quot;sudo service mongod start&quot;</span><br><span class="line">alias mgstop=&quot;sudo service mongod stop&quot;</span><br><span class="line">alias mgrestart=&quot;sudo service mongod restart&quot;</span><br><span class="line"># 设置、取消全局代理</span><br><span class="line">alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080&quot;</span><br><span class="line">alias unsetproxy=&quot;unset ALL_PROXY&quot;</span><br><span class="line"></span><br><span class="line">export DEFAULT_USER=$USER</span><br><span class="line">source ~/.nvm/nvm.sh</span><br><span class="line">source /home/yangyin/ginnko/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>安装Tmux</p><ul><li><p>当前配置</p><ul><li>位置：<code>~/.tmux.conf</code></li><li><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># remap prefix from &apos;C-b&apos; to &apos;C-a&apos;</span><br><span class="line">unbind C-b</span><br><span class="line">set-option -g prefix C-a</span><br><span class="line">bind-key C-a send-prefix</span><br><span class="line"></span><br><span class="line"># reload config file (change file location to your the tmux.conf you want to use)</span><br><span class="line">bind r source-file ~/.tmux.conf</span><br><span class="line"></span><br><span class="line"># split panes using | and -</span><br><span class="line">bind \ split-window -h</span><br><span class="line">bind - split-window -v</span><br><span class="line">unbind &apos;&quot;&apos;</span><br><span class="line">unbind %</span><br><span class="line"></span><br><span class="line"># switch panes using Alt-arrow without prefix</span><br><span class="line">bind -n M-Left select-pane -L</span><br><span class="line">bind -n M-Right select-pane -R</span><br><span class="line">bind -n M-Up select-pane -U</span><br><span class="line">bind -n M-Down select-pane -D</span><br><span class="line"></span><br><span class="line"># Enable mouse mode (tmux 2.1 and above)</span><br><span class="line">set -g mouse on</span><br><span class="line"></span><br><span class="line"># status</span><br><span class="line">set -g status-right &apos;&apos;</span><br><span class="line">set -g status-left &apos;&apos;</span><br><span class="line">set -g status off</span><br><span class="line"></span><br><span class="line">######################</span><br><span class="line">### DESIGN CHANGES ###</span><br><span class="line">######################</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h2 id="4-快捷键的设置及二狗蛋的配合使用"><a href="#4-快捷键的设置及二狗蛋的配合使用" class="headerlink" title="4. 快捷键的设置及二狗蛋的配合使用"></a>4. 快捷键的设置及二狗蛋的配合使用</h2><ul><li>系统默认快捷键查询：设备&gt;键盘</li><li>自定义快捷键：<ul><li>将窗口移入上一个屏幕：ctrl+up</li><li>将窗口移入下一个屏幕：ctrl+down</li><li>直接切换窗口：ctrl+tab</li><li>shutter：ctrl+shift+a</li></ul></li><li><p>二狗蛋目前键位设定</p><p><img src="/images/ubuntu/二狗蛋键位设定.png" alt="二狗蛋键位设定"></p></li></ul><hr><h2 id="5-bug解决"><a href="#5-bug解决" class="headerlink" title="5. bug解决"></a>5. bug解决</h2><ul><li>问题：终端右上角的终端图标尺寸巨大，且显示不完整<blockquote><p>解决办法：将gnome-tweaks中的顶栏&gt;应用程序菜单 打开，即可隐藏图标。</p></blockquote></li></ul><hr><h2 id="6-待继续探索的区域"><a href="#6-待继续探索的区域" class="headerlink" title="6. 待继续探索的区域"></a>6. 待继续探索的区域</h2><ul><li>指定特定程序到特定工作区</li><li>触摸板手势优化（看到fusuma的readme有了重大更新）</li><li>Tmux的使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> gnome-tweaks </tag>
            
            <tag> Tmux </tag>
            
            <tag> fusuma </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命周期函数getDerivedStateFromProps的使用</title>
      <link href="/2019/07/21/getDerivedStateFromProps/"/>
      <url>/2019/07/21/getDerivedStateFromProps/</url>
      
        <content type="html"><![CDATA[<p>以前写的代码，遇到<code>组件内的状态即来自组件外部props，也来自组件内部的state更新</code>这种情况，都是在生命周期函数<code>componentDidUpdate</code>中解决的，在其他地方看到<code>getDerivedStateFromProps</code>函数的使用，突然发现这个函数才是真正为这个场景而生的。</p><a id="more"></a><h2 id="这个函数使用的场景是"><a href="#这个函数使用的场景是" class="headerlink" title="这个函数使用的场景是"></a>这个函数使用的场景是</h2><p><strong>组件内的状态即来自组件外部props，也来自组件内部的state更新。</strong></p><p>这个函数是静态函数，在<code>render()</code>之前执行，<code>setState()</code>和<code>forceUpstate()</code>会触发<code>getDerivedStateFromProps</code>函数。</p><h2 id="注意使用条件"><a href="#注意使用条件" class="headerlink" title="注意使用条件"></a>注意使用条件</h2><ol><li>在使用此生命周期时，要注意把传入的 prop 值和之前传入的 prop 进行比较。</li><li>因为这个生命周期是静态方法，同时要保持它是纯函数，不要产生副作用。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/5c3ad49be51d45521053fde0" target="_blank" rel="noopener">https://juejin.im/post/5c3ad49be51d45521053fde0</a></li><li><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state" target="_blank" rel="noopener">https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 生命周期函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法作业翻译</title>
      <link href="/2019/07/07/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/07/07/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>应某位在国外学习多年的大神要求，翻译斯坦福算法课程第一道算法作业（percolation），原文点<a href="https://coursera.cs.princeton.edu/algs4/assignments/percolation/specification.php" target="_blank" rel="noopener">这里</a>。</p><p>ps.这位大神说每个单词都能看懂，连在一起就看不懂了。大神亲自提出要求，我这个没见过市面的土包子只好硬着头皮翻译了。。。</p><a id="more"></a><p><em>来都来，点下广告吧</em></p><h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>假设一种由随机分布的绝缘材料和金属材料组成的复合系统：材料中的哪些部分得是金属的才能让这个复合系统成为导体呢？假设一种表面有水（或下面是油）的多空的景观，在什么条件下，水能排到底部（或油能喷到表面）？科学家抽象出了一个被称为渗透的过程来模拟上面描述的这类情况。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>我们使用<code>n×n</code>的网格模拟渗流系统，网格中的每一个位都是两种状态中的一种，或是开放的，或是关闭的。一个<code>完整位</code>得是一个开放位，并且能够通过一系列相邻（上下左右）的开放位连通到最上面一行的某个开放位。当在最下面一行存在一个完整位时，我们说这个系统是可<code>渗透</code>的。换句话说，如果我们填充所有连通顶行的开放位，并且这个过程能填充位于最下面一行的开放位，那么这个系统渗透。（在绝缘体/金属复合材料的例子中，开放位对应于金属材料的部分，复合材料<code>导电（渗透）</code>意味着它有一条从上到下连通的金属路径。在有孔介质的例子中，开放为对应空的空间，水能通过这些空间流动，介质<code>渗流（渗透）</code>意味着水能顺着这些空的空间从顶部流动到底部。）</p><p><img src="/images/web/percolation_model.png" alt="模型"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在一个有名的科学问题中，科学家对下面的问题超感兴趣：如果一个系统中的位相互独立地以几率P（关闭状态的几率就是1-P）被设为开放状态，整个系统渗透的几率是多少呢。当P=0，这个系统完全不渗透，当P=1，这个系统肯定渗透。下面两张图给出了P和系统渗透几率的关系，横坐标表示P，纵坐标表示系统渗透的几率（上图是20×20的网格系统，下图是100×100的网格系统）。</p><p><img src="/images/web/estimate_thread.png" alt="estimate thread"></p><p>当网格的基数n足够大，就会有一个阈值P<sup><code>*</code></sup>，当P&lt;P<sup><code>*</code></sup>时，一个随机的n×n系统几乎总是不能渗透，当P&gt;P<sup><code>*</code></sup>时，一个随机的n×n系统几乎总是能渗透。到现在，还没能从数学的角度算出阈值P<sup><em></em></sup>。你的任务就是写一个程序来估算出P<sup>``</sup>。</p><h2 id="渗透类"><a href="#渗透类" class="headerlink" title="渗透类"></a>渗透类</h2><p>要模拟一个渗透系统，需要写一个包含下面接口的渗透类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creates n-by-n grid, with all sites initially blocked</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// opens the site (row, col) if it is not open already</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// is the site (row, col) open?</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// is the site (row, col) full?</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// returns the number of open sites</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// does the system percolate?</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// test client (optional)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>边界情况：通常来说，行和列的索引是介于1和n之间的整数比如（1,1）表示网格的左上角位。任何传入<code>open()</code>，<code>isOpen()</code>， <code>isFull()</code>的参数如果超出的了刚才描述的这个位，都要抛出<code>java.lang.IllegalArgumentException</code>异常。<br>如果n≤0，构造函数应抛出<code>java.lang.IllegalArgumentException</code>。</p></li><li><p>性能要求：构造函数初始化花费的时间要正比于n<sup>2</sup>；所有的方法都应该采用常量时间加上对<code>union-find</code>方法union()，find()，connected(),count()的常数次数的调用。</p></li></ol><h2 id="Monte-Carlo-模拟"><a href="#Monte-Carlo-模拟" class="headerlink" title="Monte Carlo 模拟"></a>Monte Carlo 模拟</h2><p>要估计渗透阈值，考虑下面的计算试验：</p><ol><li>初始化所有的位为关闭状态</li><li><p>重复下面的过程，直至系统渗透</p><ul><li>在所有为关闭状态的位中随机选择一个位</li><li>修改这个位为开放状态</li></ul></li><li>当系统渗透时，开放状态的位的比例就能提供一个对渗透阈值的估测</li></ol><p>比如，根据下面的快照，在一个20×20的网格里打开位，那么我们对逾渗阈值的估计值为204/400 = 0.51，因为系统在第204个站点打开时渗透。</p><p><img src="/images/web/experiment.png" alt="experiment"></p><p>重复上面这个计算试验T次取平均值，我们获得的渗透阈值会更精确。x<sub>t</sub>表示在第t次试验中开放位的比例。样本平均值</p><p><img src="/images/web/stats1.png" alt="stats1"></p><p>假设T足够大（比如至少30），下面的公式提供了渗透阈值95%的置信区间。</p><p><img src="/images/web/stats2.png" alt="stats2"></p><p>为了实现一系列的计算试验，创建一个带有如下接口的渗透统计类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// perform independent trials on an n-by-n grid</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> trials)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// sample mean of percolation threshold</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// sample standard deviation of percolation threshold</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// low endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// high endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="comment">// test client (see below)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：如果n或者trials&lt;=0，构造函数要抛出<code>java.lang.IllegalArgumentException</code>异常。</p><p>另外，这个类中要有一个<code>main()</code>函数，这个函数接受两个来自命令行的采纳数n和T，这个函数用来实现在n×n的网格中执行T次上面描述的计算试验，并输出阈值的样本平均值，标准差以及95%的置信区间。使用<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/StdRandom.html" target="_blank" rel="noopener">StdRandom</a>生成随机数，用<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/StdStats.html" target="_blank" rel="noopener">StdStats</a>计算样本的平均值和标准差。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">~/Desktop/percolation&gt; java-algs4 PercolationStats 200 100</span><br><span class="line">mean                    = 0.5929934999999997</span><br><span class="line">stddev                  = 0.00876990421552567</span><br><span class="line"><span class="meta">95%</span> confidence interval = [0.5912745987737567, 0.5947124012262428]</span><br><span class="line"></span><br><span class="line">~/Desktop/percolation&gt; java-algs4 PercolationStats 200 100</span><br><span class="line">mean                    = 0.592877</span><br><span class="line">stddev                  = 0.009990523717073799</span><br><span class="line"><span class="meta">95%</span> confidence interval = [0.5909188573514536, 0.5948351426485464]</span><br><span class="line"></span><br><span class="line">~/Desktop/percolation&gt; java-algs4 PercolationStats 2 10000</span><br><span class="line">mean                    = 0.666925</span><br><span class="line">stddev                  = 0.11776536521033558</span><br><span class="line"><span class="meta">95%</span> confidence interval = [0.6646167988418774, 0.6692332011581226]</span><br><span class="line"></span><br><span class="line">~/Desktop/percolation&gt; java-algs4 PercolationStats 2 100000</span><br><span class="line">mean                    = 0.6669475</span><br><span class="line">stddev                  = 0.11775205263262094</span><br><span class="line"><span class="meta">95%</span> confidence interval = [0.666217665216461, 0.6676773347835391]</span><br></pre></td></tr></table></figure><h2 id="分析运行时间和内存使用情况（可选不参与打分）"><a href="#分析运行时间和内存使用情况（可选不参与打分）" class="headerlink" title="分析运行时间和内存使用情况（可选不参与打分）"></a>分析运行时间和内存使用情况（可选不参与打分）</h2><p>使用<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/QuickFindUF.html" target="_blank" rel="noopener">QuickFindUF</a>中的<code>quick find</code>算法来操控渗透类型。</p><ul><li><p>使用<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/Stopwatch.html" target="_blank" rel="noopener">Stopwatch</a>测量PercolationStats类型对于n和T各种值的总运行时间。n加倍如何影响总运行时间？T加倍如何影响总运行时间？给出在你的计算机上总运行时间和n以及T的关系（using tilde notation（这不知道是个啥））（以秒位单位）。</p></li><li><p>使用讲座中提到的64位内存成本模型，给出Percolation对象用于模拟n×n渗透系统所使用的总内存量（using tilde notation）。计算包括<code>union-find</code>数据结构占用内存在内的所有内存使用量。</p></li></ul><p>现在使用<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/WeightedQuickUnionUF.html" target="_blank" rel="noopener">WeightedQuickUnionUF</a>中的<code>weighted quick union</code>算法来执行Percolation类回答上篇中提到的问题。</p><h2 id="网上提交"><a href="#网上提交" class="headerlink" title="网上提交"></a>网上提交</h2><p>提交且仅提交一个包含<code>Percolation.java</code>（使用<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/WeightedQuickUnionUF.html" target="_blank" rel="noopener">WeightedQuickUnionUF</a>中的<code>weighted quick-union</code>算法）和<code>PercolationStats.java</code>的<code>.zip</code>压缩包。我们提供<code>algs4.jar</code>。你的提交中不能使用下面给出的函数以外的库函数，可用函数包括：<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/StdIn.html" target="_blank" rel="noopener">StdIn</a>，<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/StdOut.html" target="_blank" rel="noopener">StdOut</a>，<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/StdRandom.html" target="_blank" rel="noopener">StdRandom</a>，<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/StdStats.html" target="_blank" rel="noopener">StdStats</a>，<a href="https://algs4.cs.princeton.edu/code/javadoc/edu/princeton/cs/algs4/WeightedQuickUnionUF.html" target="_blank" rel="noopener">WeightedQuickUnionUF</a>以及java.lang。</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 翻译 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用队列并发上传图片</title>
      <link href="/2019/07/05/%E4%B8%80%E7%A7%8D%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E7%AD%96%E7%95%A5/"/>
      <url>/2019/07/05/%E4%B8%80%E7%A7%8D%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在写图片上传功能，使用antd提供的<a href="https://ant.design/components/upload-cn/" target="_blank" rel="noopener">upload组件</a>，并使用<code>beforeUpload</code>函数拦截，再批量读进浏览器之后手动上传。</p><h2 id="第一次实现"><a href="#第一次实现" class="headerlink" title="第一次实现"></a>第一次实现</h2><p>传输使用的协议是http2，如果不做处理，并发传输的数量没有限制。第一次的实现使用<code>Promise.all</code>，并发传输，测试时，使用单张16.7M的图片，同时上传20张，会给后端带来不小的压力，多次测试中都会有部分图片上传失败，返回502或504。</p><p>使用<code>Promise.all</code>的实现方式带来的问题是：</p><ol><li>没有并发的数量限制，会占用大量带宽，同时给后端带来压力；</li><li><code>Promise.all</code>的执行方式是全部成功才算成功，有一个失败即算失败，就会将这个失败的结果返回，不管其他的项是否完成，这带来的问题是每一个失败的err没有办法单独隔离处理，导致没有办法进行后续操作，比如单独重新上传，也就是说，使用<code>Promise.all</code>没有办法单独对每一项进行操作，限制了灵活度。</li></ol><h2 id="优化的上传策略"><a href="#优化的上传策略" class="headerlink" title="优化的上传策略"></a>优化的上传策略</h2><p>改进的实现使用下面这种传输策略：</p><p><strong>创建比如3个transmitter，点击发送按钮时，三个transmitter并发发出一张图片，哪个transmitter完成自己的发送任务，就去任务队列中拿下一张图片发送，直至全部图片发送完成。</strong></p><p>下面是传输策略的实现。</p><a id="more"></a><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><ol><li>第一版</li></ol><p>下面这版代码有个缺点，在所有文件处理完成（可能的情况有全部完成，部分完成，全部失败），没有回调函数，由于业务需求，修改代码到第二版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(num, data, func, handleSuccess, handleErr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num; <span class="comment">// 这个属性用来控制transmitter的数量</span></span><br><span class="line">    <span class="keyword">this</span>.data = data; <span class="comment">// 这个属性是数组类型，保存任务队列</span></span><br><span class="line">    <span class="keyword">this</span>.func = func; <span class="comment">// 这个函数用来实际处理异步任务</span></span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">-1</span>; <span class="comment">// 这个属性用来存储当前的任务指针</span></span><br><span class="line">    <span class="keyword">this</span>.handleSuccess = handleSuccess; <span class="comment">// 所有任务处理完成的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.len = data.length; <span class="comment">// 任务的数量</span></span><br><span class="line">    <span class="keyword">this</span>.handleErr = handleErr; <span class="comment">// 任务失败的处理函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数是用来实际执行任务的异步处理</span></span><br><span class="line">  <span class="comment">// 最开始写进了transmit函数中</span></span><br><span class="line">  <span class="comment">// 但要写闭包保存index</span></span><br><span class="line">  <span class="comment">// 为了更清晰，单独拿出来写成一个函数</span></span><br><span class="line">  executeTask = <span class="keyword">async</span> (index, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; func &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> func(data, index);</span><br><span class="line">      <span class="keyword">this</span>.handleSuccess();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleErr(e, data[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数表示的是单个transmitter的执行情况</span></span><br><span class="line">  <span class="comment">// await在这里很重要</span></span><br><span class="line">  transmit = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    <span class="keyword">while</span> (currentData) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.executeTask(<span class="keyword">this</span>.index, currentData);</span><br><span class="line">      currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据num创建相应数量的transmitter</span></span><br><span class="line">  <span class="comment">// 并发启动</span></span><br><span class="line">  createTransmitter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; num &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.transmit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> Transmition;</span><br></pre></td></tr></table></figure><p><em>注：transmit中的await关键字很重要，如果没写，会导致下图中的情景。</em></p><p><img src="/images/js/multipleCore.jpeg" alt="多核"></p><ol start="2"><li>第二版</li></ol><p>为了增加上述的回调函数，一个难点：<em>这里有三个执行队列A，B，C，当执行到最后三个文件的时候，假设A执行完毕且成功了，B和C还在等待回调中，这个时候如果仅用文件队列中没有文件了来做判断条件执行最后的handleEnd()，就可能导致handleEnd()函数执行完，B和C的回调函数才开始执行，带来意想不到的结果</em></p><p>有两种方法避免上面的问题：</p><p><strong>第一种</strong>：在func函数外定义一个数组endPoint，在func函数中的onError和onSuccess函数中，将异步执行的过程封装成Promise推入endPoint中，将endPoint传入Transmition函数中，在try…catch…finally的finally中执行下面的检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.timeId = setInterval(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.endPoint.length === <span class="keyword">this</span>.len) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.endPoint);</span><br><span class="line">    <span class="keyword">this</span>.handleEnd();</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timeId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>即可避免上面的问题，但这样会有一个持续的轮寻，可能会带来代码执行上的堵塞和性能问题。</p><p><strong>第二种</strong>：记录每个队列执行的当前任务，当满足队列中没有剩余文件的时候，<code>await Promise.all(currentTask())</code>来保证所有的异步过程都已经执行完毕。其他细节详见代码注释。</p><p>代码修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(num, data, func, handleSuccess, handleErr, handleEnd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.func = func;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>.handleSuccess = handleSuccess;</span><br><span class="line">    <span class="keyword">this</span>.len = data.length;</span><br><span class="line">    <span class="keyword">this</span>.handleErr = handleErr;</span><br><span class="line">    <span class="keyword">this</span>.handleEnd = handleEnd;</span><br><span class="line">    <span class="keyword">this</span>.currentTask = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数拆出来是十分有必要的</span></span><br><span class="line">  <span class="comment">// 写成这种形式，就把图片的上传过程单独封装了</span></span><br><span class="line">  <span class="comment">// 上传成功也好，失败也好都封装在自己的过程里</span></span><br><span class="line">  <span class="comment">// 对于整个对列的上传过程而言都是经历了上传并且已经结束</span></span><br><span class="line">  handleTask = <span class="keyword">async</span> (data, index)=&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; func &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> func(data, index);</span><br><span class="line">      <span class="keyword">this</span>.handleSuccess(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleErr(e, data[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里保存当前队列执行的上传任务</span></span><br><span class="line">  <span class="comment">// 并启动任务</span></span><br><span class="line">  <span class="comment">// 在上传队列没有文件的时候</span></span><br><span class="line">  <span class="comment">// 还会判断所有上传过程是否完成，并执行最终的回调函数</span></span><br><span class="line">  executeTask = <span class="keyword">async</span> (index, data, i) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentTask[i] = <span class="keyword">this</span>.handleTask(data, index);</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.currentTask[i];</span><br><span class="line">      <span class="keyword">if</span> (index + <span class="number">1</span> === <span class="keyword">this</span>.len) &#123;</span><br><span class="line">          <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.currentTask);</span><br><span class="line">          <span class="keyword">this</span>.handleEnd();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义的每个上传队列执行的规则</span></span><br><span class="line">  <span class="comment">// 有任务时，执行任务并等待任务结束</span></span><br><span class="line">  <span class="comment">// 结束后如果文件队列中还有文件就取文件开始上传</span></span><br><span class="line">  transmit = <span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    <span class="keyword">while</span> (currentData) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.executeTask(<span class="keyword">this</span>.index, currentData, i);</span><br><span class="line">      currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里同步创建上传队列</span></span><br><span class="line">  <span class="comment">// 并启动上传过程</span></span><br><span class="line">  createTransmitor = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; num &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.transmit(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Transmition;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三版</li></ol><p>增加了队列停止的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(num, data, func, handleSuccess, handleErr, handleEnd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num; <span class="comment">// 这个属性用来控制transmitter的数量</span></span><br><span class="line">    <span class="keyword">this</span>.data = data; <span class="comment">// 这个属性是数组类型，保存任务队列</span></span><br><span class="line">    <span class="keyword">this</span>.func = func; <span class="comment">// 这个函数用来实际处理异步任务</span></span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">-1</span>; <span class="comment">// 这个属性用来存储当前的任务指针</span></span><br><span class="line">    <span class="keyword">this</span>.handleSuccess = handleSuccess || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 所有任务处理完成的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.len = data.length; <span class="comment">// 任务的数量</span></span><br><span class="line">    <span class="keyword">this</span>.handleErr = handleErr || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 任务失败的处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.handleEnd = handleEnd || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 所有任务执行完一次后的处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.currentTask = []; <span class="comment">// 这个属性用来保存当前正在执行的三个任务，随index的变化动态替换</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="number">-1</span>; <span class="comment">// 这个属性用来用来当停止任务时，记录执行到的文件指针，用于后面恢复，此处没有具体用到，仅留出这个字段</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数拆出来是十分有必要的</span></span><br><span class="line">  <span class="comment">// 写成这种形式，就把图片的上传过程单独封装了</span></span><br><span class="line">  <span class="comment">// 上传成功也好，失败也好都封装在自己的过程里</span></span><br><span class="line">  <span class="comment">// 对于整个对列的上传过程而言都是经历了上传并且已经结束</span></span><br><span class="line">  handleTask = <span class="keyword">async</span> (data, index) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; func &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> func(data, index);</span><br><span class="line">      <span class="keyword">this</span>.handleSuccess(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleErr(e, data[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里保存当前队列执行的上传任务</span></span><br><span class="line">  <span class="comment">// 并启动任务</span></span><br><span class="line">  <span class="comment">// 在上传队列没有文件的时候</span></span><br><span class="line">  <span class="comment">// 还会判断所有上传过程是否完成，并执行最终的回调函数</span></span><br><span class="line">  executeTask = <span class="keyword">async</span> (index, data, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTask[i] = <span class="keyword">this</span>.handleTask(data, index);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.currentTask[i];</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> === <span class="keyword">this</span>.len) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.currentTask);</span><br><span class="line">      <span class="keyword">this</span>.handleEnd();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义的每个上传队列执行的规则</span></span><br><span class="line">  <span class="comment">// 有任务时，执行任务并等待任务结束</span></span><br><span class="line">  <span class="comment">// 结束后如果文件队列中还有文件就取文件开始上传</span></span><br><span class="line">  transmit = <span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    <span class="keyword">while</span> (currentData) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.executeTask(<span class="keyword">this</span>.index, currentData, i);</span><br><span class="line">      currentData = data[++<span class="keyword">this</span>.index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里同步创建上传队列</span></span><br><span class="line">  <span class="comment">// 并启动上传过程</span></span><br><span class="line">  createTransmitor = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; num &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.transmit(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里用来等待已经触发的异步过程</span></span><br><span class="line">  <span class="comment">// 当已经触发的异步过程结束</span></span><br><span class="line">  <span class="comment">// 停止队列操作</span></span><br><span class="line">  stopTransmite = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.index;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="keyword">this</span>.len;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.currentTask);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个方法实现了暂停后继续操作</span></span><br><span class="line">  <span class="comment">// 目前还没有使用</span></span><br><span class="line">  continueTransmite = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="keyword">this</span>.currentIndex;</span><br><span class="line">    <span class="keyword">this</span>.createTransmitor();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Transmition;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><del>在写这篇的时候，突然想到，图片读进浏览器的过程是不是也可以使用这个策略实现，这样可以降低读入文件的压力，读完的文件也可以先显示，在交互上有比较好的反馈。</del></p><p>上面这个想法已经实现，在浏览器读图的时候，能够拿到图片列表，在调用上面的上传类处理，实现和往服务器传图片相同的节奏控制。另外，在读图的过程中，如果关闭组件，就需要调用第三版中的停止方法。停止方法的出现为上传暂停继续提供了基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> html5 </tag>
            
            <tag> upload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析概念及常见增长数量级</title>
      <link href="/2019/05/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A2%9E%E9%95%BF%E6%95%B0%E9%87%8F%E7%BA%A7/"/>
      <url>/2019/05/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A2%9E%E9%95%BF%E6%95%B0%E9%87%8F%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>本文记录了书中讲述的几个关于算法分析的概念和自己的理解，以及常见的增长数量级，方便日后查阅。 </p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>成本模型：这个模型定义了我们所研究的算法中的基本操作。通过明确成本模型，使给定的实现所需的运行时间增长数量级和它背后算法的成本的增长数量级相同（换句话说，成本模型应该和内循环中的操作有关。）</li><li>命题：表示在某个成本模型下算法的数学性质。</li><li>内循环：执行最频繁的指令决定了程序执行的总时间，我们将这些指令成为程序的内循环。</li><li>问题的规模：问题的规模可以是输入的大小或是某个命令行参数的值。</li></ul><h1 id="常见增长数量级及对应算法"><a href="#常见增长数量级及对应算法" class="headerlink" title="常见增长数量级及对应算法"></a>常见增长数量级及对应算法</h1><p>按从快到慢列出</p><ul><li>常数级别～普通语句</li><li>对数级别～二分查找</li><li>线性级别～使用常数时间处理输入数据中的所有元素或是基于单个for循环的程序</li><li>线性对数级别～归并排序、快排</li><li>平方级别～一般都有两个嵌套的for循环，比如选择排序、插入排序</li><li>立方级别～一般含有三个嵌套的for循环，比如ThreeSum</li><li>指数级别</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《算法》p108-p130</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 《算法》 </tag>
            
            <tag> 算法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于链表的下压堆栈的实现</title>
      <link href="/2019/05/07/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%8B%E5%8E%8B%E5%A0%86%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/07/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%8B%E5%8E%8B%E5%A0%86%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>链表</strong>在java中是非直接支持的数据结构。<strong>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</strong></p><a id="more"></a><h1 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h1><ul><li><p>结点记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  Item item;</span><br><span class="line">  Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码：</p><ol><li>Node类型的实例变量显示了这种数据结构的<strong>链式</strong>本质</li><li>记录：为了强调我们在组织数据时只使用了Node类，没有定义任何方法且会在代码中直接引用实例变量，这种类型的类有时也被称为记录。<strong>在我们的实现中，Node和它的用例代码都会被封装在相同的类中且无法被该类的用例访问。</strong></li></ol></li></ul><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node first;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">    Node oldfirst = first;</span><br><span class="line">    first = <span class="keyword">new</span> Node();</span><br><span class="line">    first.item = item;</span><br><span class="line">    first.next = oldfirst;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item item = first.item;</span><br><span class="line">    first = first.next;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 待补充iterator()的实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; s = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!StdIn.isEmpty()) &#123;</span><br><span class="line">      String item = StdIn.readString();</span><br><span class="line">      <span class="keyword">if</span> (!item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">        s.push(item);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">        StdOut.print(s.pop() + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StdOut.println(<span class="string">"("</span> + s.size() + <span class="string">" left on stack)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="上述实现的特性"><a href="#上述实现的特性" class="headerlink" title="上述实现的特性"></a>上述实现的特性</h1><p>  满足上述描述的实现几乎达到了任意集合类数据类型的实现的最佳性能：</p><ul><li>每项操作的用时都与集合大小无关</li><li>空间需求总是不超过集合大小乘以一个常数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《算法》p89-p94</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 《算法》 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于链表的背包实现</title>
      <link href="/2019/05/07/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E8%83%8C%E5%8C%85%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/07/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E8%83%8C%E5%8C%85%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文记录java中基于链表包的实现。有数据类型通用性，链表的大小可调整，能够迭代。</p><a id="more"></a><h1 id="迭代的实现描述"><a href="#迭代的实现描述" class="headerlink" title="迭代的实现描述"></a>迭代的实现描述</h1><p>  在集合数据类型中实现迭代的步骤：</p><ol><li>添加并引用java的接口：<code>import java.util.Iterator</code></li><li>在类声明中添加<code>implements Iterable&lt;Item&gt;</code>，这行代码保证了类必然会提供一个<code>iterator()</code>的方法。</li><li><p>在背包结构的具体实现中，<code>iterator()</code>方法本身只是简单地从实现了Iterator借口的类中返回了一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面这段代码保证了类必然会实现方法<code>hasNext()</code>，<code>next()</code>以及<code>remove()</code>供用例的foreach语法使用，这也在下面的实现中表明。</p></li></ol><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node first;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">    Node oldfirst = first;</span><br><span class="line">    first = <span class="keyword">new</span> Node();</span><br><span class="line">    first.item = item;</span><br><span class="line">    first.next = oldfirst;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node current = first;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Item item = current.item;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bag&lt;String&gt; b = <span class="keyword">new</span> Bag&lt;String&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!StdIn.isEmpty()) &#123;</span><br><span class="line">      String item = StdIn.readString();</span><br><span class="line">      <span class="keyword">if</span> (!item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">        b.add(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String n : b) &#123;</span><br><span class="line">      StdOut.println(n+ <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="上述实现的特性"><a href="#上述实现的特性" class="headerlink" title="上述实现的特性"></a>上述实现的特性</h1><p>  满足上述描述的实现几乎达到了任意集合类数据类型的实现的最佳性能：</p><ul><li>每项操作的用时都与集合大小无关</li><li>空间需求总是不超过集合大小乘以一个常数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《算法》p96-p98</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 《算法》 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于链表的队列实现</title>
      <link href="/2019/05/07/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/07/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>使用链表能达到最优设计目标：</p><ol><li>可以处理任意类型的数据</li><li>所需的空间总是和集合的大小成正比</li><li>操作所需的时间总是和集合的大小无关</li></ol><p>在下面的实现代码中能看到队列和栈的区别，栈由于是后进先出，所以只涉及头部，操控一个first变量即可。队列是先进先出，所以要操控first和last两个Node变量。</p><a id="more"></a><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node first;</span><br><span class="line">  <span class="keyword">private</span> Node last;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">    Node oldlast = last;</span><br><span class="line">    last = <span class="keyword">new</span> Node();</span><br><span class="line">    last.item = item;</span><br><span class="line">    last.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      first = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      oldlast.next = last;</span><br><span class="line">    &#125;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item item = first.item;</span><br><span class="line">    first = first.next;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      last = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!StdIn.isEmpty()) &#123;</span><br><span class="line">      String item = StdIn.readString();</span><br><span class="line">      <span class="keyword">if</span> (!item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">        q.enquequ(item);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        StdOut.print(q.dequeue() + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StdOut.println(<span class="string">"("</span> + q.size() + <span class="string">" left on queue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《算法》p95</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 《算法》 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合类数据类型的实现</title>
      <link href="/2019/05/07/%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/07/%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文记录java中栈（集合类数据类型）的实现。使用java中的数组实现，要有数据类型通用性，栈的大小可调整，能够迭代。</p><a id="more"></a><h1 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h1><ul><li>数据类型是泛型</li><li>使用数组实现，数组大小可变</li><li><p>具有迭代性(集合类数据类型的基本操作之一就是能够使用java的<code>foreach</code>语句通过迭代遍历并处理集合中的每个元素)</p><ol><li>集合数据类型必须实现一个<code>iterator()</code>方法并返回一个<code>Iterator</code>对象。</li><li><code>Iterator</code>类必须包含两个方法：<code>hasNext()</code>(返回一个布尔值)和<code>next()</code>(返回集合中的一个泛型元素)。</li></ol></li></ul><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个相当于 java.util.Iterator</span></span><br><span class="line"><span class="comment">// pulic interface Iterator&lt;Item&gt; &#123;</span></span><br><span class="line"><span class="comment">//   boolean hasNext();</span></span><br><span class="line"><span class="comment">//   Item next();</span></span><br><span class="line"><span class="comment">//   void remove();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResizingArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    Item[] temp = (Item[]) <span class="keyword">new</span> Object[max];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      temp[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == a.length) &#123;</span><br><span class="line">      resize(<span class="number">2</span> * a.length);</span><br><span class="line">    &#125;</span><br><span class="line">    a[N++] = item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item item = a[--N];</span><br><span class="line">    a[N] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N == a.length / <span class="number">4</span>) &#123;</span><br><span class="line">      resize(a.length / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReverseArrayIterator();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a[--i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="上述实现的特性"><a href="#上述实现的特性" class="headerlink" title="上述实现的特性"></a>上述实现的特性</h1><p>  满足上述描述的实现几乎达到了任意集合类数据类型的实现的最佳性能：</p><ul><li>每项操作的用时都与集合大小无关</li><li>空间需求总是不超过集合大小乘以一个常数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《算法》p86-p88</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 《算法》 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DJ双栈算术表达式求值算法</title>
      <link href="/2019/05/06/%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/06/%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>看到p79，讲栈的一个应用——算术表达式求值，突然想起来这是来我现在这家公司面试的时候，被问的一道题。当年年少无知写计算器的时候，算术表达式求值用的是正则表达式的匹配（不涉及括号），面试给出的的答案也是这种办法。看到书里用栈来解决，真是牛逼。</p><a id="more"></a><h1 id="DJ双栈算术表达式求值算法描述"><a href="#DJ双栈算术表达式求值算法描述" class="headerlink" title="DJ双栈算术表达式求值算法描述"></a>DJ双栈算术表达式求值算法描述</h1><p>这个算法是 <strong>E.W.Dijkstra</strong>大神发明，使用两个栈，一个用于保存运算符，一个用于保存操作数。（这个算法使用括号）</p><ul><li>将操作数压入操作数栈</li><li>将运算符压入运算符栈</li><li>忽略左括号</li><li>遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算符结果压入操作数栈</li></ul><p>在处理完最后一个右括号之后，操作数栈上只会有一个值，就是表达式的值。</p><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evaluate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; ops = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    Stack&lt;Double&gt; vals = <span class="keyword">new</span> Stack&lt;Double&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!StdIn.isEmpty()) &#123; </span><br><span class="line">      <span class="comment">// 读取字符,如果是运算符则压入栈</span></span><br><span class="line">      String s = StdIn.readString();</span><br><span class="line">      <span class="keyword">if</span> (s.equals(<span class="string">"("</span>));</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"+"</span>))</span><br><span class="line">        ops.push(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"-"</span>))</span><br><span class="line">        ops.push(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"*"</span>))</span><br><span class="line">        ops.push(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"/"</span>))</span><br><span class="line">        ops.push(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"sqrt"</span>))</span><br><span class="line">        ops.push(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果字符为 ")",弹出运算符和操作数,计算结果并压入栈</span></span><br><span class="line">        String op = ops.pop();</span><br><span class="line">        <span class="keyword">double</span> v = vals.pop();</span><br><span class="line">        <span class="keyword">if</span>(op.equals(<span class="string">"+"</span>))</span><br><span class="line">          v = vals.pop() + v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"-"</span>))</span><br><span class="line">          v = vals.pop() - v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"*"</span>))</span><br><span class="line">          v = vals.pop() * v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"/"</span>))</span><br><span class="line">          v = vals.pop() / v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"sqrt"</span>)) v = Math.sqrt(v);</span><br><span class="line">          vals.push(v);</span><br><span class="line">      &#125; <span class="comment">// 如果字符既非运算符也不是括号,将它作为 double 值压入栈</span></span><br><span class="line">      <span class="keyword">else</span> vals.push(Double.parseDouble(s));</span><br><span class="line">    &#125;</span><br><span class="line">    StdOut.println(vals.pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它展示了一种重要的计算模型:将一个字符串解释为一段程序并执行该程序得到结果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《算法》p79-p80</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 《算法》 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移</title>
      <link href="/2019/05/02/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/05/02/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="新博客说明"><a href="#新博客说明" class="headerlink" title="新博客说明"></a>新博客说明</h1><ol><li><p>新博客基于<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>。</p></li><li><p>模板使用<a href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank" rel="noopener">xoxo</a>。</p></li></ol><a id="more"></a><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><ol><li><p>原模板没有给出添加<em>标签页</em>和<em>搜索页</em>的方法，添加方法使用参考中的链接<em>1</em>。</p></li><li><p>原模板没有给出正确修改图片的方法，添加方法使用参考中的链接<em>2</em>。</p></li><li><p>该模板需要的额外插件：<code>hexo-reading-time</code>，<code>hexo-generator-search</code>。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于promise的理解</title>
      <link href="/2019/04/28/promise/"/>
      <url>/2019/04/28/promise/</url>
      
        <content type="html"><![CDATA[<h1 id="基于回调函数的异步编程"><a href="#基于回调函数的异步编程" class="headerlink" title="基于回调函数的异步编程"></a>基于回调函数的异步编程</h1><blockquote><p>回调函数真正的问题在于它剥夺了我们使用return和throw这些关键字的能力。相反，我们的整个diamante流程都是基于副作用的：一个函数会附带调用其他函数。<sup>1</sup></p></blockquote><blockquote><p>并且，它会将我们通常在大部分编程语言中能获得的堆栈破坏。<sup>1</sup></p></blockquote><blockquote><p><strong><code>Primise</code>给予我们的是在我们使用异步时丢失的最重要的语言基石：<code>return</code>，<code>throw</code>以及<code>堆栈</code>。</strong><sup>1</sup></p></blockquote><a id="more"></a><h1 id="promise是什么"><a href="#promise是什么" class="headerlink" title="promise是什么"></a>promise是什么</h1><blockquote><p>promise是一种代码结构和流程<sup>1</sup></p></blockquote><blockquote><p>依照 promises 规范，一旦一个 promise 被创建，它就被执行了。<sup>1</sup></p></blockquote><h1 id="使用promise"><a href="#使用promise" class="headerlink" title="使用promise"></a>使用promise</h1><ol><li>在then()函数内部能处理的事情</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I'm inside a then() function</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以处理以下三件事<sup>1</sup>：</p><ul><li>return另外一个promise：这个用在<code>composing promises</code>写法中</li><li><p>return 一个 <strong>同步</strong> 的值(或者undefined)</p><p>下面第二个函数不需要关心<code>userAccount</code>是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个好的习惯：<strong>在then()函数内部，永远返回或抛出</strong></p></li><li><p>throw一个 <strong>同步</strong> 异常：catch()函数在捕获异常的时候，不关心异常是同步的还是异步的</p><blockquote><p>任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。</p></blockquote><p>可以 <strong>直接</strong> 使用<code>Promise.resolve</code>来进行同步或异步的封装，<code>Promise.reject()</code>同理。</p></li></ul><ol start="2"><li>永远都是往 then() 中传递函数<sup>1</sup></li></ol><p>参考:</p><ol><li><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6之后添加的日常开发用的到的新特性</title>
      <link href="/2019/04/08/new-feature/"/>
      <url>/2019/04/08/new-feature/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的新函数"><a href="#数组的新函数" class="headerlink" title="数组的新函数"></a>数组的新函数</h1><ol><li><p><code>Array.prototype.includes()</code></p><p>判断一个数组是否包含一个指定的值，包含返回<code>true</code>，否则返回<code>false</code>。</p></li><li><p><code>Array.prototype.flat()</code></p><p>这个方法按照一个可指定的深度递归遍历数组，将所有元素与遍历到的子数组中的元素合并为一个新数组返回（另外可以利用这个函数进行数组空项去除）。</p></li></ol><a id="more"></a><ol start="3"><li><p><code>Array.prototype.flatMap()</code></p><p>这个方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。</p></li></ol><h1 id="对象的新函数"><a href="#对象的新函数" class="headerlink" title="对象的新函数"></a>对象的新函数</h1><ol><li><p><code>Object.values()</code></p><p>这个方法不是定义在原型上的，返回指定对象自身属性的所有值，不包含继承的值。</p></li><li><p><code>Object.entries()</code></p><p>这个方法也没有定义在原型上，返回指定对象自身可枚举属性的键值对的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj1)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.fromEntries()</code></p><p>上一个函数的反转。</p></li></ol><h1 id="函数的新方法"><a href="#函数的新方法" class="headerlink" title="函数的新方法"></a>函数的新方法</h1><ol><li><p><code>Function.prototype.toString()</code></p><p>改进版的返回精确字符，包含空格和注释</p></li></ol><h1 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在后台面板</span></span><br><span class="line"><span class="comment">// 拿到单品id</span></span><br><span class="line"><span class="comment">// 进行单品详细信息轮寻获取的时候好像用到了类似的方法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这两种方式都无法正确执行异步过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h1><p>不论是<code>resolve</code>还是<code>reject</code>最后都可以执行<code>finally</code>中的代码。</p><h1 id="新的基本累心"><a href="#新的基本累心" class="headerlink" title="新的基本累心"></a>新的基本累心</h1><ul><li>String</li><li>Number</li><li>Boolean</li><li>Nill</li><li>Undefined</li><li>Symbol</li><li><strong>BigInt</strong>：这个好像还在提案中</li></ul><p>参考:</p><ol><li><a href="https://juejin.im/post/5ca2e1935188254416288eb2" target="_blank" rel="noopener">https://juejin.im/post/5ca2e1935188254416288eb2</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础学习笔记</title>
      <link href="/2019/02/13/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/13/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql基础学习笔记"><a href="#mysql基础学习笔记" class="headerlink" title="mysql基础学习笔记"></a>mysql基础学习笔记</h1><p>学习视频：<a href="https://www.bilibili.com/video/av19538278?t=47&amp;p=32" target="_blank" rel="noopener">https://www.bilibili.com/video/av19538278?t=47&amp;p=32</a></p><p>视频中用到的资料：<a href="https://blog.csdn.net/qq_27229113/article/details/75206309" target="_blank" rel="noopener">https://blog.csdn.net/qq_27229113/article/details/75206309</a></p><p>这套视频详细介绍了增删改查，左连接，子查询，视图，简单介绍了事务，引擎的区别。关于这套教程的一些想法：老师是真的教得好。还会讲一些项目、字段的设计、字符集之类的话题，感觉平时自己只是随便取出数据就用来控制或是显示了，没有怎么细想过，现在感觉理解上有些不一样了，也说不好哪儿不一样，总之感觉进步了一点点。</p><p>orm vs 原生sql：</p><ol><li><a href="https://stackoverflow.com/questions/3360304/orm-vs-traditional-database-query-which-are-their-fields" target="_blank" rel="noopener">https://stackoverflow.com/questions/3360304/orm-vs-traditional-database-query-which-are-their-fields</a></li><li><a href="https://stackoverflow.com/questions/494816/using-an-orm-or-plain-sql" target="_blank" rel="noopener">https://stackoverflow.com/questions/494816/using-an-orm-or-plain-sql</a></li><li><a href="https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5" target="_blank" rel="noopener">https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5</a></li><li><a href="https://medium.com/ameykpatil/why-orm-shouldnt-be-your-best-bet-fffb66314b1b" target="_blank" rel="noopener">https://medium.com/ameykpatil/why-orm-shouldnt-be-your-best-bet-fffb66314b1b</a></li></ol><p>决定后面的练习写sql了。</p><a id="more"></a><hr><h3 id="解决乱码的办法"><a href="#解决乱码的办法" class="headerlink" title="解决乱码的办法"></a>解决乱码的办法</h3><p><code>set names gbk</code></p><h3 id="一个建表语句"><a href="#一个建表语句" class="headerlink" title="一个建表语句"></a>一个建表语句</h3><p>create table class(<br>  id int primary key auto_increment,<br>  sname varchar(10) not null default ‘’,<br>  gender char(1) not null default ‘’,<br>  company varchar(20) not null default ‘’,<br>  salary decimal(6,2) not null default 0.00,<br>  fanbu smallint not null default 0<br>) engine myisam charset utf8;</p><h3 id="增的操作"><a href="#增的操作" class="headerlink" title="增的操作"></a>增的操作</h3><ol><li>往哪张表</li><li>往哪几列</li><li>添加哪些值</li></ol><p>insert into class<br>(id,sname,gender,company,salary,fanbu)<br>values<br>(1,’张三’,’男’,’百度’,8888.67,234);</p><!-- 增多行 --><p>insert into class<br>(sname,company,salary)<br>values<br>(‘刘备’,’皇室成员’,15.28),<br>(‘孙策’,’江东集团’,56.34),<br>(‘曹操’,’宦官后裔’,88.56);</p><h3 id="删的操作"><a href="#删的操作" class="headerlink" title="删的操作"></a>删的操作</h3><p>删除就是指删除整行，不存在删除某几列</p><ol><li>删哪张表</li><li>删哪行</li></ol><p>delete from class where salary&gt;8000;</p><p>delete from class where salary&gt;8000 and gender=’女’;</p><h3 id="改的操作"><a href="#改的操作" class="headerlink" title="改的操作"></a>改的操作</h3><ol><li>改哪张表</li><li>该哪几列</li><li>改成什么值</li><li>在哪一行生效</li></ol><p>update class<br>set<br>gender=’女’,<br>company=’千度’<br>where id=2;</p><p>update class<br>set fanbu=150<br>where gender=’男’ and salary&gt;8000;</p><p>update class<br>set fanbu=100<br>where 1;</p><h3 id="查的操作"><a href="#查的操作" class="headerlink" title="查的操作"></a>查的操作</h3><ol><li>从哪张表查</li><li>查哪几列</li><li>满足哪些条件</li></ol><p>select * from class; // 查class表中的所有数据</p><p>select sname,gender from class where id&lt;5; //查class表中id&lt;5的sname和gender列</p><p>select * from class where id=3; // 从class表中查id=3的所有列</p><p>select sname,gender from class; //从class表中查sname，gender两列的所有行</p><h3 id="后面要学"><a href="#后面要学" class="headerlink" title="后面要学"></a>后面要学</h3><ol><li>如何自己建表</li><li>如何修改表（增加减少列等）</li><li>多表联查</li><li>子查询</li><li>触发器</li><li>事务</li><li>存储过程</li><li>备份恢复</li></ol><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>建表的过程就是一个 <strong>声明字段</strong> 的过程.</p><p><strong>存储同样的数据，不同的列类型所占据的空间和效率是不一样的，这就是建表前学习列类型的意义。重点学列类型的存储范围和占据的字节大小。</strong></p><p>为什么建表时，加<em>not null default ‘’/0</em>？</p><p>答：不想让表中出现null值。</p><p>为什么不想要null值？</p><p>答：1.不好比较，null是一种类型，比较时只能用专门的is null和is not null来比较，碰到运算符一律返回null；2.效率不高，不利于提高索引效果。因此 <strong>在建表时往往声明not null default 0/‘’</strong>。</p><p>比较null要用专门的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test where sname is null;</span><br><span class="line">select * from test where sname is not null;</span><br></pre></td></tr></table></figure><p>mysql三大列类型</p><ul><li><p>数值型</p><ul><li><p>整型</p><ul><li>Tinyint<ul><li>占据空间：1个字节</li><li>存储范围：-128~127（0~255）</li><li>参数：(M) unsigned zerofill</li><li>默认有符号</li></ul></li><li>Smallint</li><li>Mediumint</li><li>bigint</li></ul></li><li><p>小数(浮点型、定点型)</p><ul><li>M：精度（小数所有位数）</li><li>D：标度（小数后位数）</li><li>范围：float能存10^38.10^-38</li><li>占据空间：M&lt;=24，占4个字节，否则占8个字节</li><li>定点：定点数是把整数部分和小数部分分开存储的，比float精确。float有时会损失精度，如果像银行这样的敏感字段，建议用decimal</li></ul></li></ul></li><li><p>补码规则</p></li></ul><p>计算机中的负数，不是按照后面的绝对值位乘-1得到的，而是用补码规则换算的。</p><p>负数 = 绝对值位 - 128</p><p>1111 1111 =========&gt; -1</p><p>1000 0000 =========&gt; -128</p><ul><li><p>字符串类型</p><ul><li>char：定长类型，对于char(M)，M代表宽度（占用空间，限制的是字符不是字节），0&lt;=M&lt;=255之间，表示能输M个字符，不够M个长度在尾部用空格补齐，能通过数学计算出位置。从利用率的角度，能达到100%。在存取特点上，char型如果不够M个字符，内部用空格补齐，取出时再把右侧空格删掉，这意味着如果右侧本身有空格，将会丢失。速度上定长类型快一些。</li><li>varchar：变长类型，对于varchar(M)，M代表宽度（占用空间，限制的是字符不是字节），0&lt;=M&lt;=65535(以ascii字符为例，utf8 22000左右)。varchar(100)能存0-100个字符。每个varchar前还有1-2个字符用来表示当前字符的长度，从利用率的角度，到不了100%。</li><li>Text：文本类型，可以存比较大的文本段，搜索速度稍慢。如果不是特别大的内容，建议使用char、varchar来代替。</li><li>Blob：是二进制类型，用来存储图像，音频等二进制信息。<strong>Blob在于防止因为字符集的问题，导致信息丢失。比如一张图片中有0xFF字节，这个在ascii字符集中认为非法，在入库的时候被过滤。</strong></li><li>日期类型：5.7版本的mysql的date类型不支持0为默认值，具体原因参考<a href="https://blog.csdn.net/chenshun123/article/details/79676567" target="_blank" rel="noopener">这里</a>。date类型能存储的范围是<code>1000-01-01~9999-12-31</code>。</li><li>时间类型</li><li>日期时间类型：输入格式YYYY-mm-dd HH:mm:ss。但一般使用时间戳来存储。</li><li>时间戳类型：timestamp</li><li>年份类型：year 1901-2155 255个年份+0000一个错误年份</li></ul></li></ul><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ul><li><p>新增列语法：</p><ol><li>alter table 表名 add 列名称 列类型 列参数;(加在最后)</li><li>alter table 表名 add 列名称 列类型 列参数 after 指定列;(加在指定列后面)</li><li>alter table 表名 add 列名称 列类型 列参数 first；（加在第一行）</li></ol></li><li><p>删除列语法：</p><ol><li>alter table 表名 drop 类名;</li></ol></li></ul><ul><li><p>修改列语法：</p><ol><li>alter table 表名 modify 列明 新类型 新参数;（此方法不能该表名）</li></ol></li><li><p>修改列明和列类型语法：</p><ol><li>alter table 表名 change 旧列名 新列名 新参数；</li></ol></li></ul><h3 id="查询建表语句"><a href="#查询建表语句" class="headerlink" title="查询建表语句"></a>查询建表语句</h3><p>show create table 表名;</p><h3 id="从一个表中将特定几列的数据拷入另一个表中"><a href="#从一个表中将特定几列的数据拷入另一个表中" class="headerlink" title="从一个表中将特定几列的数据拷入另一个表中"></a>从一个表中将特定几列的数据拷入另一个表中</h3><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>使用某个具体的字段来数的话，如果这个字段下某一行的值为null，使用count时，不计入数量。使用count(*)数绝对的行数。</strong></p><p><strong>用count(*)和count(1)谁好呢？</strong></p><p><strong>对于myisam引擎的表来说没有区别，这种表内部有一个计数器用来维护行数。对于Innodb引擎的表来说，用count(*)直接读行数效率很低，因为innodb真的要去数一遍</strong></p><p><em>以下查询基于<a href="https://blog.csdn.net/qq_27229113/article/details/75206309" target="_blank" rel="noopener">这里</a>的数据。</em></p><ol><li><p>基础查询 <strong>where</strong> 的练习</p><p> 1.1 主键为32的商品id、商品名称和商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods where goods_id=32;</span><br></pre></td></tr></table></figure><p> 1.2 类型不是3的商品id、类型id、商品名称、商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where cat_id!=3;</span><br></pre></td></tr></table></figure><p> 1.3 商城内价格高于3000块的商品的商品id、类型id、商品名称、商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where shop_price&gt;3000;</span><br></pre></td></tr></table></figure><p> 1.4 商城内价格低于或等于100块的商品的商品id、类型id、商品名称、商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where shop_price&lt;=100;</span><br></pre></td></tr></table></figure><p> 1.5 查询分类为4和11的商品，不许用or</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name.shop_price from goods where cat_id in (4,11);</span><br></pre></td></tr></table></figure><p> 1.6 查询大于等于100块小于等于500块的商品，不能用逻辑与and</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where shop_price between 100 and 500;</span><br></pre></td></tr></table></figure><p> 1.7 取出不再分类为3且不在分类为11中的商品，用not in 和 and 分别实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用not in实现 --&gt;</span><br><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where cat_id not in (3,11);</span><br><span class="line"></span><br><span class="line">&lt;!-- 用and实现 --&gt;</span><br><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where cat_id != 3 and cat_id != 11;</span><br></pre></td></tr></table></figure><p> 1.8 取出价格大于100且小于300或者大于4000且小于5000的商品</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where (shop_price&gt;100 and shop_price&lt;300) or (shop_price&gt;4000 and shop_price&lt;5000);</span><br></pre></td></tr></table></figure><p> 1.9 取出分类3下的价格小于1000或者大于3000，同时点击量大于等于5的商品</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where (cat_id=3) and (shop_price&lt;1000 or shop_price&gt;3000) and (click&gt;=5);</span><br></pre></td></tr></table></figure><p> 1.10 查出名字以诺开头的商品</p><p> 模糊查询 关键字 <strong>like</strong></p><p> 在查询字段后加 <strong>%(百分号匹配任意个字符)</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where goods_name like &apos;诺记%&apos;;</span><br></pre></td></tr></table></figure><p> 使用 <strong>_</strong>匹配任意个单个字符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where goods_name like &apos;诺记__&apos;;</span><br></pre></td></tr></table></figure><p> 1.11 查出在商城中购买商品比市场价省多少钱</p><p> 将字段名字看作是变量，既然是变量就可以参与运算</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,(market_price-shop_price) as discount from goods where cat_id&gt;10;</span><br></pre></td></tr></table></figure><p> 1.12 查出本店价比市场价省的钱，而且省200以上的商品</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,(market_price-shop_price) as discount from goods where (market_price-shop_price)&gt;200;</span><br></pre></td></tr></table></figure><p> 此处where中不能使用discount是因为where是在原表中发挥作用，原表中没有discount的字段，结果表中才有discount的字段，继续筛结果表中的数据要使用 <strong>having</strong>。</p><p> 1.13 将20-19之间的数改为20,30-39之间的数改为30</p><p> 把num当成变量看，num/10取整再乘以10。。。麻的，真妥么想不到诶。。。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update cv set num=floor(num/10)*10 where num between 20 and 40;</span><br></pre></td></tr></table></figure><p> <strong>大胆的把列看成变量，参与运算，甚至调用函数来处理，常用的函数有substring()、concat（）</strong></p></li><li><p>分组 <strong>group</strong> 查询</p></li></ol><p>group by cat_id 从语义上来分析，select的列只能是cat_id/max/min/avg/sum/count()这种统计类型的列。使用select *从语义上分析就不对，严格说不符合sql标准</p><pre><code>2.1 查询出最贵的商品价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(shop_price) from goods;</span><br></pre></td></tr></table></figure>2.2 查询出最便宜的商品的价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(shop_price) from goods;</span><br></pre></td></tr></table></figure>2.3 查询出最小的商品id<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(goods_id) from goods;</span><br></pre></td></tr></table></figure>2.4 查询所有商品总库存量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(goods_num) from goods;</span><br></pre></td></tr></table></figure>2.5 查询所有商品的平均价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(shop_price) from goods;</span><br></pre></td></tr></table></figure>2.6 查询有多少种商品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from goods;</span><br></pre></td></tr></table></figure>2.7 计算分类3下的所有商品的库存量之和<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(goods_number) from goods where cat_id=3;</span><br></pre></td></tr></table></figure>2.8 一条语句计算每个分组下的库存量之和<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,sum(goods_number) from goods group by cat_id;</span><br></pre></td></tr></table></figure>2.9 按商品分类分组，计算每个分类下的商品的平均价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,avg(shop_price) from goods group by cat_id;</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>having查询</p><p> sql语句的查询筛选过程：先根据where查询出满足条件的行，列和原表的列一样，得到一个中间表，再在这个中间表的基础上进行列之间的计算以及分组group，得到的结果集再通过having进行下一步的操作得到最终结果集。</p><p> 3.1 查询出每个商品积压的货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,shop_price * goods_number from goods;</span><br></pre></td></tr></table></figure><p> 3.2 查询该店积压的总货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(shop_price * goods_number) as sum from goods;</span><br></pre></td></tr></table></figure><p> 3.3 查询每个分类下挤压的货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,sum(shop_price*goods_number) as sum from goods group by cat_id;</span><br></pre></td></tr></table></figure><p> 3.4 查询加压货款超过2万以及积压的货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,sum(shop_price*goods_number) as sum from goods group by cat_id having sum&gt;20000;</span><br></pre></td></tr></table></figure><p> 3.5 查询比市场价省钱200块以上的商品以及该商品省的钱</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,(market_price-shop_price) as discount from goods having discount&gt;200;</span><br></pre></td></tr></table></figure><p> 3.6 查询2门及2门以上不及格者的平均成绩</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//写错了。。。。。。</span><br><span class="line">//因为count函数不管传入的是什么都数</span><br><span class="line">select name,avg(score) as average,count(score&lt;60) as gks from result group by name having gks&gt;=2;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正确结果：利用布尔值正确返回1错误返回0 --&gt;</span><br><span class="line"></span><br><span class="line">select name,avg(score),sum(score&lt;60) as gks from result group by name having gks&gt;=2;</span><br><span class="line"></span><br><span class="line">&lt;!-- 另一种方法 --&gt;</span><br><span class="line">&lt;!-- 先筛选出名字，得到一张表，根据这张表继续筛选 --&gt;</span><br><span class="line">&lt;!-- 三层嵌套 --&gt;</span><br><span class="line"></span><br><span class="line">select name,avg(score) from result where name in (select name from (select name,count(1) as gks from result where score&lt;60 group by name having gks&gt;=2)as tmp) group by name;</span><br></pre></td></tr></table></figure></li><li><p>排序</p></li></ol><p>排序发生在得到最终的结果集（拿到原始筛选数据）之后，排序是针对最终结果集的，也就是说order要放在where/group by/having后面，顺序不能乱。</p><p>排序的语法：</p><p>order by 结果集中的列名1 desc/asc,结果集中的列名2 desc/asc (<strong>注意：这样写有排序先后，先按列名1排序，再按列名2排序</strong>)</p><pre><code>4.1 取出分类4下的商品，并按价格由高到低排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods where cat_id=4 order by shop_price desc;</span><br></pre></td></tr></table></figure>4.2 按分类升序排列，同一个分类下的商品，再按商品的价格降序排列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by cat_id asc,shop_price desc;</span><br></pre></td></tr></table></figure></code></pre><ol start="5"><li>limit限制条数</li></ol><p>limit用在语句的最后，起到限制条目的作用。</p><p>limit[offset,] N，其中：</p><p>offset：偏移量，如果不写，相当于0<br>N：取出条目</p><pre><code>5.1 取出本店价格最高的前三名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by shop_price desc limit 0,3;</span><br></pre></td></tr></table></figure>5.2 查询本店价格最高的第三名到第五名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by shop_price desc limit 2,3;</span><br></pre></td></tr></table></figure>5.3 取商品价格最高的一件商品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by shop_price desc limit 1;</span><br></pre></td></tr></table></figure></code></pre><ol start="6"><li><p>子查询</p><ol><li><p>where型子查询：将内层查询的结果作为外层查询的条件。</p><p>典型题：查询最大商品、最贵商品</p><p>如果where列=（内层sql），则内层sql返回的必是单行单列，也就是单个值<br>如果where列 in (内层sql)，则内层sql只返回单列，可以多行</p></li><li><p>from型子查询</p><p>这里插入一个重要概念</p><p><strong>查询模型</strong></p></li><li><p>列就是变量，在每一行上，列的值都在变化</p></li><li>where条件是表达式，在哪一行上表达式为真，哪一行就取出来</li><li><p>查询结果集可以当成表看</p><p>from型子查询：内层sql的查询结果，当成一张临时表，供外层sql再次查询。</p></li><li><p>exists型子查询</p><p>exists型子查询：把外层sql的结果拿到内层sql去测试，如果内层sql成立，则该行被取出。</p></li></ol></li></ol><p>练习题</p><pre><code>6.1 查询出每个分类下id号最大的一条商品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 仅想出这种嵌套的方法 --&gt;</span><br><span class="line">select goods_id,goods_name,cat_id from goods where goods_id in (select max(goods_id) from goods group by cat_id) order by cat_id asc;</span><br></pre></td></tr></table></figure>6.2 查出本店最新的商品，要求不用排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name from goods where goods_id=(select max(goods_id) from goods);</span><br><span class="line"></span><br><span class="line">&lt;!-- select max(goods_id) from goods 这条语句返回的就是最大值 --&gt;</span><br></pre></td></tr></table></figure>6.3 查出有商品的分类号和分类名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,cat_name from category where exists (select * from goods where goods.cat_id=category.cat_id);</span><br></pre></td></tr></table></figure></code></pre><h3 id="表与集合的关系"><a href="#表与集合的关系" class="headerlink" title="表与集合的关系"></a>表与集合的关系</h3><p>一张表就是一个集合</p><p>每一行就是一个元素</p><p>在数据库中，用 <strong>,(逗号)</strong>将两个表名隔开即可完成两张表笛卡尔积查询</p><p>比如查询商品表和分类表，得到商品名称、库存、价格和分类名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,cat_name from goods,category where goods.cat_id=category.cat_id;</span><br></pre></td></tr></table></figure><p>但是这样做效率低。</p><p><em>两张表全相乘，比如A表10000行数据，B表10000万行数据，都不算大，但是两表全相乘，在内存中生成一个非常大的数据。10000\</em>10000行。另外索引没用上。*</p><p>先记下来：<strong>两张表联查之后没有索引</strong></p><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><p>假设A表在左，不动，B表在A表的右边滑动，A表与B表通过一个关系来筛选B表的行。</p><p>语法：</p><p><strong>A left join B on 条件</strong>，条件为真，则B表对应的行取出。</p><p><strong>A left join B on 条件</strong>这个部分形成的也是一个结果集，可以看成一张表，设为c。既如此，可以对c表进行查询，where\group\having\order by\limit照常可以使用。同样，C看成表之后还可以继续和其他表进行左连接。</p><p><strong>直接使用上面的语句会报语法错误诶…貌似5.7版本不能单独使用，和select一块儿使用就可以通过…</strong></p><p>问：C表可以查询的列有哪些？<br>答：AB两表的列都可以查询。</p><p>练习：</p><ol><li><p>取出第4个分类下的商品以及商品的分类名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price,cat_name from (goods left join category on goods.cat_id = category.cat_id) where goods.cat_id = 4;</span><br></pre></td></tr></table></figure></li></ol><ul><li>左连接、右连接、内连接的区别</li></ul><p>左右连接可以互换</p><p>A left join B &lt;=&gt; B right join A</p><p><em>注意：既然左右连接可以互换，尽量用左连接，处于移植时兼容性方面的考虑。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select boy.*,girl.* from boy inner join girl on boy.other = girl.other;</span><br></pre></td></tr></table></figure><p>从集合的角度看，内连接是左右连接的交集。</p><p><em>外连接是左右连接的并集，但是在mysql中不支持外连接。</em></p><p>作业题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 表结构 --&gt;</span><br><span class="line"></span><br><span class="line">Match 赛程表</span><br><span class="line">字段名称字段类型描述</span><br><span class="line">matchIDint主键</span><br><span class="line">hostTeamIDint主队的ID</span><br><span class="line">guestTeamIDint客队的ID</span><br><span class="line">matchResultvarchar(20)比赛结果，如（2:0）</span><br><span class="line">matchTimedate比赛开始时间</span><br><span class="line"></span><br><span class="line">Team 参赛队伍表</span><br><span class="line">字段名称字段类型描述</span><br><span class="line">teamIDint主键</span><br><span class="line">teamNamevarchar(20)队伍名称</span><br><span class="line"></span><br><span class="line">&lt;!-- 表数据 --&gt;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from m;</span><br><span class="line">+-----+------+------+------+------------+</span><br><span class="line">| mid | hid | gid | mres | matime |</span><br><span class="line">+-----+------+------+------+------------+</span><br><span class="line">| 1 | 1 | 2 | 2:0 | 2006-05-21 |</span><br><span class="line">| 2 | 2 | 3 | 1:2 | 2006-06-21 |</span><br><span class="line">| 3 | 3 | 1 | 2:5 | 2006-06-25 |</span><br><span class="line">| 4 | 2 | 1 | 3:2 | 2006-07-21 |</span><br><span class="line">+-----+------+------+------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+------+----------+</span><br><span class="line">| tid | tname |</span><br><span class="line">+------+----------+</span><br><span class="line">| 1 | 国安 |</span><br><span class="line">| 2 | 申花 |</span><br><span class="line">| 3 | 传智联队 |</span><br><span class="line">+------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">&lt;!-- 查出 2006-6-1 到2006-7-1之间举行的所有比赛，并且用以下形式列出：</span><br><span class="line">拜仁 2：0 不来梅 2006-6-21 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 想出的答案 --&gt;</span><br><span class="line"></span><br><span class="line">select team.teamName,matchResult,tmpTeam.teamName,matchTime from ((matchResult left join team on hostTeamId=teamId) left join team as tmpTeam on guestTeamId=tmpTeam.teamId) where matchTime between &apos;2006-06-01&apos; and &apos;2006-07-01&apos;;</span><br><span class="line"></span><br><span class="line">+--------------+-------------+--------------+------------+</span><br><span class="line">| teamName     | matchResult | teamName     | matchTime  |</span><br><span class="line">+--------------+-------------+--------------+------------+</span><br><span class="line">| 申花         | 1:2         | 传智联队     | 2006-06-21 |</span><br><span class="line">| 传智联队     | 2:5         | 国安         | 2006-06-25 |</span><br><span class="line">+--------------+-------------+--------------+------------+</span><br></pre></td></tr></table></figure><p><em>注意：要把第二次左连接用到的team表名起一个别名，否则会报错。</em></p><p><em>注意：match是mysql的关键字。</em></p><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>合并2条或多条语句的结果。</p><p>语法：sql1 union sql2</p><p>问：内否从2张表查询完再union呢？<br>答：可以，union合并的是“结果集”，不区分在哪一张表。</p><p>问：取自于2张表，通过别名让2个结果集的列一致，如果取出的结果集，列名字不一样，还能否union？<br>答：可以，以第一张表的列名为准。</p><p>问：union满足什么条件就可以用了？<br>答：只要结果集中的列数一致就可以。</p><p>问：列的类型不一致也可以嘛？<br>答：见上题。</p><p>问：union后的结果集可否再排序呢？<br>答：可以。</p><p>问：使用union语句时，内层的排序有时发挥效果有时不发挥效果，这是问什么？<br>答：内层的order by语句单独使用时，不影响结果集，仅排序，在执行期间就被mysql的代码分析器给优化掉了，内层的order by必须能够影响结果集时才有意义，比如配合limit使用。</p><p>问：如果union后的结果有重复（即某2行或n行的值都一样），怎么办？<br>答：这种情况是比较常见的默认会去重。</p><p>问：如果不想去重怎么办？<br>答：union all</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>如果mysql函数和javascript函数都实现某个功能，优先使用哪一个？</p><ol><li><p>mysql的函数肯定是要影响查询速度。应该在建表时通过合理的表结构减少函数的使用合理的表结构减少函数的使用；</p></li><li><p>如果确实要使用函数，比如时间的格式化，优先放在业务逻辑层，即用javascript处理；</p></li><li><p>在查询时使用了函数，最大的一个坏处是索引无法使用，比如date_format(A)，则A列的索引将无法使用。在where函数中，使用了索引，where查询的是函数处理后的条件，索引失效。</p></li></ol><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图View可以看成一张虚拟表，是表通过某种运算得到的一个投影，表的变化会影响到视图。</p><p>视图的定义一直存在，但不占用空间。</p><p>对于一些简单的视图，它在发挥作用的过程中，并没有建立临时表，而只是把条件存起来，下次查询，把条件一合并，直接去查表。</p><p>问：建视图的时候要指定视图的列名与列类型么？<br>答：不要，它只是一个投影，是一种关系，会继承原表的字段。</p><ul><li>创建视图的语法</li></ul><p>既然视图只是表的某种查询的投影，所以主要步骤在于查询表上，查询的结果命名为视图就可以了。</p><p><strong>create view 视图名字 as select语句</strong></p><ul><li><p>视图有什么用</p><ol><li>可以简化查询；</li><li>可以更精细的权限控制，比如某张用户表，2个网站搞合作，可以查询对方网站的用户，需要向对方开放用户表的权限，但是又不想开放用户表中的密码字段，可以使用视图；</li><li>数据多，分表时可以用到。比如小说站，article表，1000万篇，分成article1、article2…article5，查询小说时，不知道在哪张表上，可以创建一个五张表合在一起的视图一次型查出。</li></ol></li><li><p>表与视图数据变化时的相互影响问题</p><ol><li>表的数据变化，视图跟着变</li><li>视图的数据发生变化时，满足视图的数据和表的数据一一对应，类似函数和反函数的关系时，会影响到原表</li></ol></li></ul><p><em>注意：一一对应指的是根据select关系，从表中取出的行，只能计算出视图中确定的一行，反之，视图中任意抽一行，能够反推出表中确定的一行</em><br><em>注意：order by limit得到的结果与表不是一一对应的</em></p><ul><li>删除视图</li></ul><p><code>drop view 表名</code></p><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><ul><li><p>视图合并查询条件 vs 临时表</p><ol><li><p>如果将创建的视图看作临时表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp = select * from godds where shop_price &gt; 300;</span><br><span class="line">select * from tmp where shop_price &lt; 500;</span><br></pre></td></tr></table></figure></li><li><p>如果没有临时表，查这个视图，还有没有可能完成</p><p>可以。查原表，把建视图时的条件和查询视图的条件叠加起来，直接去查原表。</p></li></ol></li><li><p>这两种方式哪个快</p><ol><li>建表：查询=&gt;形成临时表=&gt;查询临时表</li><li>叠加：合并条件=&gt;查询表</li></ol></li><li><p>到底是创建临时表还是合并语句，就由algorithm来决定，当它的值为：</p><ol><li>merge：合并查询语句</li><li>temptable：临时表</li><li><p>undefined：未定义，由系统判断</p><p>合并条件的视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create algorithm=merge view v2</span><br><span class="line">as</span><br><span class="line">select * from goods where shop_price&gt;300;</span><br></pre></td></tr></table></figure><p>建临时表的视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 复杂查询 --&gt;</span><br><span class="line">&lt;!-- 比如建立平均价格视图 --&gt;</span><br><span class="line">create algorithm=temptable view v3</span><br><span class="line">as</span><br><span class="line">select goods_id,cat_id,goods_name,shop_price</span><br><span class="line">from goods</span><br><span class="line">order by cat_id asc,shop_price desc;</span><br></pre></td></tr></table></figure><p>由系统来决定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果拿不准就写algorithm=undefined，由系统来决定</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>字符集的概念</li></ul><p>2进制编码到字符的映射就是字符集。</p><ul><li>一些字符集</li></ul><p>ascii、ansi、gb2312、gbk、unicode、utf-8。</p><p>从容量上来看：GB2312&lt;GBK&lt;UTF-8</p><ul><li>unicode和utf-8的关系</li></ul><p>unicode用4个字节来编号，有2^32种组合。</p><p>unicode只负责分配编号，而且都是用4个字节来分配编号。</p><p>utf-8在不改变编号的基础上简化字节，把高位浪费的0值，用一定的规则舍弃。</p><p><strong>unicode和utf-8的关系就像源文件和压缩文件的关系。由给定的unicode字符可=&gt;utf-8的二进制值，反过来，由utf-8的二进制值=&gt;unicode字符。</strong></p><ul><li>utf8的长度</li></ul><p>变长，否则压缩就没有意义了。</p><ul><li>如何截取utf8（各国语言都有），无乱码？</li></ul><p>从头开始，取1个字节。通过位运算，计算连续的1的个数。如果为0，则截取1个字节，如果为N，则截取N个字节。</p><ul><li>GBK是如何转为UTF-8的？</li></ul><p>GBK也是和unicode有对应关系的，GBK=&gt;unicode=&gt;utf8。</p><ul><li><p>乱码原因</p><ol><li>可修复的情况：解码时与实际编码不一致</li><li>不可修复的情况：传输过程中，编码不一致，导致字节丢失</li></ol></li><li><p>客户端和服务器端的编码转换</p></li></ul><p>客户端与服务器之间存在一个 <strong>连接器</strong>。客户端的字符先发给连接器，连接器选择一种编码将其转换，临时存储，之后再次转换成服务器需要的编码，并最终存储在服务器。</p><p>告诉连接器客户端使用GBK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set character_set_client=gbk;</span><br></pre></td></tr></table></figure><p>告诉连接器使用utf8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set character_set_connection=utf8;</span><br></pre></td></tr></table></figure><p>告诉连接器如果返回值，返回GBK结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set character_set_results=gbk;</span><br></pre></td></tr></table></figure><p>如果上面三个参数都设置成GBK，可以简写，简写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set names gbk;</span><br></pre></td></tr></table></figure><ul><li>使用上面三个设置的一个基本原则</li></ul><p>服务器字符集容量 &gt;= 连接器字符集容量 &gt;= 客户端字符集容量</p><ul><li><p>保证下面三者字符集的一直就绝不会出现乱码的可能</p><ol><li>网页文件本身编码</li><li>meta信息</li><li>client/connection/results的指定</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generator函数初步学习</title>
      <link href="/2019/01/06/generator/"/>
      <url>/2019/01/06/generator/</url>
      
        <content type="html"><![CDATA[<p>看了许多材料后，感觉下面这三篇文章对于理解generator函数有非常大的帮助，囊括了常见用法、控制流程、循环操作等，理解的程度已经基本能满足现在的需求。</p><ol><li><a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">https://davidwalsh.name/es6-generators</a></li><li><a href="https://davidwalsh.name/es6-generators-dive" target="_blank" rel="noopener">https://davidwalsh.name/es6-generators-dive</a></li><li><a href="https://davidwalsh.name/async-generators" target="_blank" rel="noopener">https://davidwalsh.name/async-generators</a></li></ol><p>下面的内容为阅读材料时随手做的笔记，未经过整理。</p><a id="more"></a><h2 id="关于generator函数的基本概念"><a href="#关于generator函数的基本概念" class="headerlink" title="关于generator函数的基本概念"></a>关于generator函数的基本概念</h2><p><a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">这篇</a>文章描述generator使用了<code>...so powerful for the future of JS.</code>。</p><p>万万没想到！之前对generator的认知仅停留在是个新的函数种类，没想到这里厉害。</p><p>到目前已经遇到两种衍生的技术了：</p><ol><li><p>async函数</p></li><li><p>saga结合成的redux-saga。</p></li></ol><p>原文：</p><blockquote><p>If you ‘ve ever read anything about concurrency or threaded programming, you may have seen the term ‘cooperative’, which basically indicates that a process(in our case, a function) itself chooses when it will allow an interruption, so that it can cooperate with other code. This concept is contrasted with ‘preemptive’, which suggests that a process/function could be interrupted against its will.</p></blockquote><p>就是说，并行编程有两种，在一段程序运行的时候可以被打断，执行另一段程序，主动打断的称为 <strong>cooperative</strong>，被动打断的称为 <strong>preemptive</strong>。Generator函数就是前者，它通过<code>yield</code>关键字，从generator函数内部打断执行过程，需要从外部恢复执行。</p><p>Generator函数并不仅仅是简单的打断、启动这种流程控制，它还允许向generator函数的内部和外部进行双向的数据传递。</p><h3 id="创建iterator"><a href="#创建iterator" class="headerlink" title="创建iterator"></a>创建iterator</h3><p>调用一个generator函数便会创建一个iterator，并且创建的过程并不会执行generator函数中的内容。</p><h2 id="关于generator的工作流程"><a href="#关于generator的工作流程" class="headerlink" title="关于generator的工作流程"></a>关于generator的工作流程</h2><p>以下内容出自<a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md" target="_blank" rel="noopener">此处</a>。</p><ol><li>Advancing the Generator</li></ol><p>使用next()函数</p><ol start="2"><li>Pass a Value To the Iterator</li></ol><p>在function*函数中使用yield关键字</p><ol start="3"><li>Receive a Value From the Iterator</li></ol><p>yield keyword can receive a value back from the iterator</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line"></span><br><span class="line">iterator.next(<span class="string">'foo'</span>);</span><br><span class="line">iterator.next(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>好奇怪，为啥执行第一个next不输出<code>foo</code>，而是将这个值丢弃？</p><ol start="4"><li>内部执行顺序</li></ol><p>执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo, f;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'generator 1'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'yield 1'</span>, <span class="keyword">yield</span> <span class="string">'A'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'generator 2'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'yield 2'</span>, <span class="keyword">yield</span> <span class="string">'B'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'generator 3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'b'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'c'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 4'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'d'</span>));</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tick <span class="number">1</span></span><br><span class="line">generator <span class="number">1</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">'A'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">tick <span class="number">2</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span> b</span><br><span class="line">generator <span class="number">2</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">'B'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">tick <span class="number">3</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span> c</span><br><span class="line">generator <span class="number">3</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">tick <span class="number">4</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用<code>for...of...</code>循环</li></ol><p>准则：</p><ol><li>The iteration will continue as long as done property is false.</li><li>The for..of loop cannot be used in cases where you need to pass in values to the generator steps.</li><li>The for..of loop will throw away the return value.</li></ol><ol start="6"><li>委托yield</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">  <span class="keyword">yield</span> * bar();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">yield</span> * baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>委托一个generator到另一个generator相当于将目标generator的函数体导入到目的generator中，<br>相当于下面这种代码形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><ol start="7"><li>用yield控制异步流程</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">name, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(name);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">method, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    args.push(callback);</span><br><span class="line">    <span class="keyword">return</span> method.apply(&#123;&#125;, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controller = <span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> iterator = generator();</span><br><span class="line">  <span class="keyword">const</span> advancer = <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    state = iterator.next(response);</span><br><span class="line">    <span class="keyword">if</span> (!state.done) &#123;</span><br><span class="line">      state.value(advancer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  advancer();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controller(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> curry(foo, <span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> curry(foo, <span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> curry(foo, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="8"><li>带错误处理的yield异步流程控制</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">parameters, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(parameters);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">method, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    args.push(callback);</span><br><span class="line">    <span class="keyword">return</span> method.apply(&#123;&#125;, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controller = <span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> iterator = generator();</span><br><span class="line">  <span class="keyword">const</span> advancer = <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; response.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> iterator.throw(response.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = iterator.next(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.done) &#123;</span><br><span class="line">      state.value(advancer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  advancer();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controller(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a, b, c;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    a = <span class="keyword">yield</span> curry(foo, <span class="string">'a'</span>);</span><br><span class="line">    b = <span class="keyword">yield</span> curry(foo, &#123;<span class="attr">error</span>: <span class="string">'Something went wrong.'</span>&#125;);</span><br><span class="line">    c = <span class="keyword">yield</span> curry(foo, <span class="string">'c'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="generator的一个理解角度"><a href="#generator的一个理解角度" class="headerlink" title="generator的一个理解角度"></a>generator的一个理解角度</h2><p>以下部分出自<a href="https://goshakkk.name/javascript-generators-understanding-sample-use-cases/" target="_blank" rel="noopener">此处</a></p><p>翻译其中的understanding部分：</p><p>当一个函数被调用，其中的命令会一个接一个的按顺序执行，函数能够通过<code>return</code>将一些值传给它的调用者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">regular</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doA();</span><br><span class="line">  doB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>generators</code>的出现能够像对待一个<code>program</code>一样对待一个函数。</strong>这个函数能够根据你定义的规则执行。所以我们可以将这个<code>generator</code>函数成为一个<code>program</code>。</p><p>为了执行一个<code>program</code>，我们需要一个<code>interpreter</code>，这个<code>interpreter</code>将“take the program in and run it”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interpreter(<span class="function"><span class="keyword">function</span>* <span class="title">program</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>yield</code>命令告诉一个<code>program</code>跳出generator调到<code>interpreter</code>中。<code>program</code>和<code>interpreter</code>的交流是双向的：</p><ol><li><code>program</code>可以向<code>interpreter</code>发送一些东西</li><li><code>interpreter</code>也可以向<code>program</code>返回一些东西</li></ol><p>基于上面的描述，可以从下面的角度描述下面这行代码：</p><p><code>const a = yield b;</code>这行代码表示了我们如何发送一个命令b到<code>interpreter</code>然后把它的结果给a。<code>generator</code>函数将会暂停，直到<code>interpreter</code>告诉它才会继续执行后面的代码。</p><p>从redux-saga的角度阐述这个概念。</p><p>redux-saga没有将<code>side-effect</code>分散进多个action creator 和 reducer中，而是按逻辑组合多个片段行为，这个组合体被成为一个<strong>saga</strong>。</p><p>redux-saga中的<code>helper</code>函数，相当于在翻译<code>command</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">welcomeSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> take(<span class="string">'REGISTRATION_FINISHED'</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(showWelcomePopup());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(welcomeSaga);</span><br></pre></td></tr></table></figure><p>sagaMiddleware感觉就是一个interpreter。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dva初步学习</title>
      <link href="/2018/12/17/dva%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/12/17/dva%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>这篇博客摘自<a href="https://dvajs.com/guide/" target="_blank" rel="noopener">此处</a>，是从方便自己理解的角度整理了下。</p><h3 id="Dva的本质"><a href="#Dva的本质" class="headerlink" title="Dva的本质"></a>Dva的本质</h3><p>Dva = React-Router + Redux + Redux-saga</p><a id="more"></a><h3 id="Dva中的数据流向"><a href="#Dva中的数据流向" class="headerlink" title="Dva中的数据流向"></a>Dva中的数据流向</h3><p>数据的改变通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候，可以通过<code>dispatch</code>发起一个action，如果是同步行为会直接通过<code>reducers</code>改变<code>State</code>，如果是异步行为（副作用）会先触发<code>Effects</code>然后流向<code>Reducers</code>最终改变<code>State</code>。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>state操作的时候每次都要当做不可变数据来对待，保证每次都是全新的对象，没有引用关系，这样才能保证State的独立性，便于测试和追踪变化。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><h3 id="dispatch函数"><a href="#dispatch函数" class="headerlink" title="dispatch函数"></a>dispatch函数</h3><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>这个函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。感觉这也是Reducer名字的来源。  </p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>这个要好好看看，对这个不太熟悉。</p><p>Effect是一个Generator函数，内部使用yield关键字，标识每一步的操作。</p><blockquote><p>Effect被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。</p></blockquote><blockquote><p>dva为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而键effects转为纯函数</p></blockquote><p>后面要学的东西：</p><ol><li>redux-sagas</li><li><del>generator-将异步转为同步写法</del></li><li>纯函数好像是个<a href="https://github.com/MostlyAdequate/mostly-adequate-guide" target="_blank" rel="noopener">狼人</a></li></ol><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>Subscription语义是订阅，用于订阅一个数据源，然后根据条件dispatch需要的action。数据源可以是当前的时间、服务器的websocket连接、keyboard输入、geolocation变化、history路由变化等。</p><p>给了一个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> key form <span class="string">'keymaster'</span>;</span><br><span class="line"></span><br><span class="line">add.model(&#123;</span><br><span class="line">  namespace: <span class="string">'count'</span>,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    keyEvent(&#123;dispatch&#125;) &#123;</span><br><span class="line">      key(<span class="string">'ctrl+up'</span>, () =&gt; &#123;dispatch(&#123;<span class="attr">type</span>: <span class="string">'add'</span>&#125;)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>dva实例提供了router方法来控制路由，使用的是react-router。</p><h3 id="Route-Components"><a href="#Route-Components" class="headerlink" title="Route Components"></a>Route Components</h3><p>在Dva中，我们将Container Components约束为Route Components，因为在Dva中，我么通常以页面维度来设计Container Components。</p><p>所以在Dva中，通常需要connect Mode的组件都是Router Components，组织在<code>/routes/</code>目录下，而<code>/components/</code>目录下则是纯组件。</p><h3 id="dva的结构"><a href="#dva的结构" class="headerlink" title="dva的结构"></a>dva的结构</h3><p><a href="https://dvajs.com/guide/introduce-class.html#dva-%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E7%AE%80%E7%BB%93%E6%9E%84%EF%BC%88%E5%B8%A6-model" target="_blank" rel="noopener">见这里</a></p><ol><li>创建应用</li><li>注册Model</li><li>注册视图</li><li>启动应用</li></ol><h3 id="关于Model对象"><a href="#关于Model对象" class="headerlink" title="关于Model对象"></a>关于Model对象</h3><ol><li><p>所有的应用逻辑都定义在app.model这个对象上面</p></li><li><p>Model对象的属性</p><ul><li>namespace：当前Model的名称，整个应用的state，由多个小的Model的state以namespace为key合成</li><li>state：该Model当前的状态。数据保存在这里，直接决定了视图层的输出</li><li>reducers：Action处理器，处理同步动作，用来算出最新的state</li><li>effects：Action处理器，处理异步动作</li></ul></li></ol><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">参考MDN</a></p><blockquote><p>Calling a generator function does not execute its body immediately; an iterator object for the function is returned instead. When the iterator’s next() method is called, the generator function’s body is executed until the first yield expression, which specifies the value to be returned from the iterator or, with yield*, delefates to another generator function. The next() method returns an object with a value property containing the yielded value and a done property which indicates whether the generator has yielded its last value as a boolean. Calling the next() method with an argument will resume the generator function execution, replacing the yield expression where execution was paused with the arguments from next().</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Dva </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React纯组件</title>
      <link href="/2018/12/17/pure-component/"/>
      <url>/2018/12/17/pure-component/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">https://reactjs.org/docs/react-api.html#reactpurecomponent</a></li><li><a href="https://segmentfault.com/a/1190000014979065" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014979065</a></li><li><a href="https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs" target="_blank" rel="noopener">https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs</a></li><li><a href="https://juejin.im/post/5b1caceb5188257d63226743" target="_blank" rel="noopener">https://juejin.im/post/5b1caceb5188257d63226743</a></li></ol><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>React为了提升性能，产生了纯组件。纯组件的子组件也是纯组件。</p><p>关于纯组件自己的理解：类似于纯函数，只要是一样的state和props，就必定是同样的结果，可以不用再render，直接使用上次的结果。</p><p><code>React.PureComponent</code>通过减少应用中的渲染次数提升性能可以避免手写检查代码。</p><p>纯组件忽略重新渲染时，会影响它和它的所有子元素，所以出组件的最佳使用场景就是展示组件，既没有子组件，也没有依赖应用的全局状态。</p><p>解决纯组件的初始化问题：</p><ol><li>default Props</li><li>向子组件中传入的函数传引用，而不是函数本身，否则会重新创建函数对象</li></ol><p>不要在render中创建一个新函数或对象或方法。任何包含子元素的组件，shallowEqual检查总会返回false。</p><h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><p>这个要补充一下</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async函数使用方法</title>
      <link href="/2018/12/15/async%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/15/async%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#Simple_example" target="_blank" rel="noopener">MDN的一个使用实例，有讲顺序启动，并行启动之类的常用方法，其他的感觉讲的不如下面的资料清楚</a></p></li><li><p><a href="http://exploringjs.com/es2016-es2017/ch_async-functions.html" target="_blank" rel="noopener">自己写的这篇博客里说到的主要概念和理解都出自这篇材料，写的很好</a></p></li><li><p><a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c" target="_blank" rel="noopener">这篇材料讲述了避免async/await hell的一个主要解决途径就是分离启动promise和resolve promise这两个过程</a></p></li></ol><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol><li><p>描述了涉及async函数的主要概念，包括：</p><ul><li>async函数的返回值Promise对象的创建工作过程</li><li>await操作符的作用</li><li>async函数中return和await的区别</li></ul></li><li><p>描述了顺序启动和并行启动的方法</p></li><li>描述了是否使用await的区别</li></ol><h2 id="有待补充和学习的"><a href="#有待补充和学习的" class="headerlink" title="有待补充和学习的"></a>有待补充和学习的</h2><ol><li>async的原理</li><li>async函数的一些复杂的使用场景</li><li>其他异步执行方法，promise、yield的深入理解</li></ol><h2 id="对async函数使用的理解"><a href="#对async函数使用的理解" class="headerlink" title="对async函数使用的理解"></a>对async函数使用的理解</h2><ol><li>局限在async函数内部，利用await</li><li>利用async函数的返回值promise对象</li></ol><h2 id="async函数是如何工作的"><a href="#async函数是如何工作的" class="headerlink" title="async函数是如何工作的"></a>async函数是如何工作的</h2><ol><li><p>The result of an async function is always a Promise p. That Promise is created when starting the execution of the async function.</p></li><li><p>The body is executed. Execution may finish permanently via return or throw. Or it may finish temporarily via await, in which case execution will usually continue later on.</p></li><li><p>The Promise p is returned.</p></li></ol><p>When executing the body of the async function, <code>return x resolves the Promise p with x</code>, while throw err rejects p with err.</p><h2 id="await的本质"><a href="#await的本质" class="headerlink" title="await的本质"></a>await的本质</h2><p>waiting for a Promsie to be settled.</p><ol><li><p>if the Promise is fulfilled, the result of await is the fulfillment value（也就是说，此刻的结果是普通的值，而不是一个promsie对象， 比如下面的示例：）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">  <span class="built_in">console</span>.log(reuslt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个函数完全等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">  .then(<span class="function"><span class="params">reuslt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If the promise is rejected， await throws the rejection value。这个同样有两种处理方式，一种是在async函数内部使用try…catch来解决，另一种是传到async函数外，使用catch来解决。</p></li><li><p>await后面是个常数，则会以这种形式返回返回值：<code>Promise.resolve(value)</code></p></li></ol><h2 id="async函数中的return"><a href="#async函数中的return" class="headerlink" title="async函数中的return"></a>async函数中的return</h2><p>Resolving a Promise is a standard operation. return uses it to resolve the Promise p of an async function.</p><ol><li><p>Returning a non-Promise value fulfills p with that value</p></li><li><p>Returning a Promise means that p now mirrors the state of that Promise</p></li></ol><h2 id="是否使用await"><a href="#是否使用await" class="headerlink" title="是否使用await"></a>是否使用await</h2><ol><li><p>在返回语句中不使用await</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数的返回值使用的是上面第二种情况</span></span><br><span class="line"><span class="comment">// 效率高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> anotherAsyncFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在返回语句中使用await</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这个函数的返回语句中会发生先解包（await解包），在包装（return 会再次包装成Promise.resolve的过程）</span></span><br><span class="line"><span class="comment">// 效率低</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> anotherAsyncFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="async函数使用的几种场景（出自上述参考资料1）"><a href="#async函数使用的几种场景（出自上述参考资料1）" class="headerlink" title="async函数使用的几种场景（出自上述参考资料1）"></a>async函数使用的几种场景（出自上述参考资料1）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolveAfter2Seconds = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"starting slow promise"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"slow promise is done"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resolveAfter1Second = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"starting fast promise"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">10</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"fast promise is done"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sequentialStart = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==SEQUENTIAL START=='</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.</span></span><br><span class="line">  <span class="keyword">const</span> slow = <span class="keyword">await</span> resolveAfter2Seconds();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fast = <span class="keyword">await</span> resolveAfter1Second();</span><br><span class="line">  <span class="built_in">console</span>.log(slow);</span><br><span class="line">  <span class="built_in">console</span>.log(fast);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentStart = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==CONCURRENT START with await=='</span>);</span><br><span class="line">  <span class="keyword">const</span> slow = resolveAfter2Seconds(); <span class="comment">// starts timer immediately</span></span><br><span class="line">  <span class="keyword">const</span> fast = resolveAfter1Second();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> slow);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> fast); <span class="comment">// waits for slow to finish, even though fast is already done!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stillConcurrent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==CONCURRENT START with Promise.all=='</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.all([resolveAfter2Seconds(), resolveAfter1Second()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(messages[<span class="number">0</span>]); <span class="comment">// slow</span></span><br><span class="line">    <span class="built_in">console</span>.log(messages[<span class="number">1</span>]); <span class="comment">// fast</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parallel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==PARALLEL with Promise.then=='</span>);</span><br><span class="line">  resolveAfter2Seconds().then(<span class="function">(<span class="params">message</span>)=&gt;</span><span class="built_in">console</span>.log(message));</span><br><span class="line">  resolveAfter1Second().then(<span class="function">(<span class="params">message</span>)=&gt;</span><span class="built_in">console</span>.log(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/2018/11/11/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
      <url>/2018/11/11/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><ul><li>姓名：杨胤</li><li>本科：<strong>北京工业大学(211)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;水务工程</li><li>研究生：<strong>北京工业大学(211)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;市政工程（<strong>保送</strong>） </li><li>技术博客：<a href="https://ginnko.github.io/">https://ginnko.github.io/</a></li><li>github账号：<a href="https://github.com/ginnko" target="_blank" rel="noopener">https://github.com/ginnko</a></li></ul><a id="more"></a><hr><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p><strong>2017.10 ~ 现在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端开发工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同方有云科技有限公司</strong></p><ul><li>负责公司官网的前端开发和维护(<a href="https://www.tfcloud.com/" target="_blank" rel="noopener">https://www.tfcloud.com/</a>)</li><li>负责公司技术文档模板的开发和维护（使用sphinx，<a href="https://github.com/ginnko/sphinx_rtd_theme" target="_blank" rel="noopener">https://github.com/ginnko/sphinx_rtd_theme</a> ）</li><li>负责公司云服务产品（UOS）面板的开发和维护</li><li>负责公司云存储产品（UDS）面板的开发和维护</li><li>负责公司裸机管理产品（UBS）面板的开发和维护</li><li>负责公司内部组件库的维护</li></ul><p>2015.8 ~ 2017.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;市政设计工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;北京市政设计研究总院有限公司 </p><hr><h3 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h3><p>掌握： html、css、javascript、React、Ant Design</p><p>熟悉： git、Redux、React-router、Bootstrap、less、sphinx</p><p>了解： webpack、gulp、echarts、jQuery、ejs、Jekyll、css-sprites、Sass、D3、Vue</p><hr><h3 id="主要技术学习"><a href="#主要技术学习" class="headerlink" title="主要技术学习"></a>主要技术学习</h3><ul><li><p>javascript</p><ul><li>读过的书：《Javascript权威指南》、《JavaScript高级程序设计》、《Javascript模式》、《你不知道的Javascript》、《Javascript设计模式与开发实践》、《JavaScript DOM编程艺术》、《ECMAScript 6 入门》（笔记：<a href="https://github.com/ginnko/memos" target="_blank" rel="noopener">https://github.com/ginnko/memos</a> ）</li><li>教程：MDN教程（笔记：<a href="https://ginnko.github.io/">https://ginnko.github.io/</a> ），相关技术文章和博客</li><li>学习过的源码：underscore（笔记：<a href="https://github.com/ginnko/learn-javascript-via-underscore" target="_blank" rel="noopener">https://github.com/ginnko/learn-javascript-via-underscore</a> ）</li><li>目前在看：《33个javascript核心概念》</li></ul></li><li><p>css</p><ul><li>读过的书：《HTML &amp; CSS设计与构建网站》、《CSS设计指南》、《CSS权威指南》、《精通CSS-高级Web标准解决方案》</li><li>教程：MDN教程（笔记：<a href="https://ginnko.github.io/">https://ginnko.github.io/</a> ），相关技术文章和博客</li></ul></li><li><p>网络</p><ul><li>读过的书：《图解http》、《网络是怎样连接的》（笔记：<a href="https://github.com/ginnko/memos" target="_blank" rel="noopener">https://github.com/ginnko/memos</a> ）</li><li>教程：MDN教程</li><li>辅助工具：httpie</li></ul></li><li><p>React  </p><ul><li>读过的书：《React学习之路》、《React小书》、《React设计模式》、React官方文档</li><li>教程：相关技术文章和博客</li><li>DIY React：模拟一个简单的React库（笔记：<a href="https://github.com/ginnko/learn-react-via-diy" target="_blank" rel="noopener">https://github.com/ginnko/learn-react-via-diy</a> ）</li><li>目前在看：React16之后版本的内部运行机制（笔记：<a href="https://github.com/ginnko/learn-react-via-diy" target="_blank" rel="noopener">https://github.com/ginnko/learn-react-inner-workings</a> ）</li></ul></li><li><p>Redux</p><ul><li>读过的书：《React小书》、Redux官方文档和教程</li><li>教程：相关技术文章和博客</li><li>DIY Redux：《React小书》 (笔记：<a href="https://github.com/ginnko/redux-learn" target="_blank" rel="noopener">https://github.com/ginnko/redux-learn</a>)</li></ul></li><li><p>其他</p><p>React-router、git、sphinx、antDesign、chrome使用技巧、gulp、less、Bootstrap、Sass、D3技术文档、博客和教程  </p></li></ul><hr><h3 id="练习项目"><a href="#练习项目" class="headerlink" title="练习项目"></a>练习项目</h3><p><em>（以下练习项目均可点击至相关页面）</em></p><ul><li><p><a href="https://github.com/ginnko/company_page" target="_blank" rel="noopener">公司旧官网模仿</a><br>不借助第三方库模仿公司旧官网（大约完成90%）。</p></li><li><p><a href="https://github.com/ginnko/front-end-demos/tree/master/responsivewebpage" target="_blank" rel="noopener">响应式页面</a><br>模仿一个互联网金融网站的主页面。广告部分的动画实现借助owlcarousel2库，图片兼容性借助picturefill库。</p></li><li><p><a href="https://codepen.io/ginnko/full/JydBWO/" target="_blank" rel="noopener">一个简单的RPG游戏</a><br>FreeCodeCamp上的项目，使用React做的一个RPG游戏。</p></li><li><p><a href="https://codepen.io/ginnko/full/YQvVRw/" target="_blank" rel="noopener">Conway’s Game of Life</a><br>FreeCodeCamp上的项目，使用React实现的英国数学家Conway创造的一个细胞生存游戏，规则：1.本轮某个细胞存活如果与它相邻有2个或3个细胞存活，那它在下一轮也将继续存活；<br>2.某个死亡的细胞周围如果有3个活着的细胞存在，那么下一轮这个细胞将复活。<br>可以控制游戏盘的大小，游戏运行的速度，可以随机生成或手动添加细胞。</p></li><li><p><a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">分数排名榜</a><br>FreeCodeCamp上的项目，使用React实现的FreeCodeCamp这个编程学习社区的分数排名，可以显示30天内或总的分数排名。排名会显示用户名和头像，顺序可以是从小到大或从大到小。</p></li><li><p><a href="https://codepen.io/ginnko/full/XgzqKG/" target="_blank" rel="noopener">食谱编辑器</a><br>FreeCodeCamp上的项目，使用React实现的一个可以存储在浏览器中的食谱应用，可以添加、删除、编辑项目。</p></li><li><p><a href="https://codepen.io/ginnko/full/zzZmvJ/" target="_blank" rel="noopener">Markdown预览</a><br>FreeCodeCamp上的项目，这个应用可以用来实时预览用Markdown书写的文档。</p></li><li><p><a href="https://codepen.io/ginnko/full/YQRgxM/" target="_blank" rel="noopener">美国GDP逐年变化可视化</a><br>FreeCodeCamp上的项目，使用D3框架将美国GDP可视化成一组条状图，可以通过鼠标移动查看详细数据。</p></li><li><p><a href="https://codepen.io/ginnko/full/mwvmdW/" target="_blank" rel="noopener">世界自行车竞赛排名</a><br>FreeCodeCamp上的项目，使用D3框架将世界自行车竞赛排名可视化成一系列点状图，可以显示选手是否曾经使用兴奋剂，可以通过鼠标移动查看详细数据。</p></li><li><p><a href="https://codepen.io/ginnko/full/bRZeWy/" target="_blank" rel="noopener">全球地表平均温度可视化</a><br>FreeCodeCamp上的项目，使用D3框架将1753-2015年每个月全球的地表平均温度可视化成一组条状图，能看出地球在逐渐变暖。</p></li><li><p><a href="https://codepen.io/ginnko/full/xreaEp/" target="_blank" rel="noopener">相邻国家可视化</a><br>FreeCodeCamp上的项目，使用D3框架中的force layout实现主要国家的相邻国家的可视化，可以任意拖动。使用css-sprites插入每个国家的国旗，移动鼠标到相应国旗显示国家名称（有时国旗显示比较慢）。</p></li><li><p><a href="https://codepen.io/ginnko/full/LLwyvv/" target="_blank" rel="noopener">全球陨石地图</a><br>FreeCodeCamp上的项目，使用D3框架中的map实现全球陨石落地地点的可视化，地图可以拖动，可以缩放，圆圈的大小表示陨石相对大小，鼠标移动查看详细数据。</p></li><li><p><a href="https://codepen.io/ginnko/full/dRPXGv/" target="_blank" rel="noopener">Tic Tac Toe Game</a><br>FreeCodeCamp上的项目，一个游戏，三子连成一条线即算赢，可以人机对战也可以双人对战，一局结束后记录结果并自动开始下一局。</p></li><li><p><a href="https://codepen.io/ginnko/full/EXxXJw/" target="_blank" rel="noopener">番茄工作法计时器</a><br>FreeCodeCamp上的项目，一个番茄工作法计时器，在session length中输入工作时长，在break length中输入休息时长，点击start，即开始循环计时。可以暂停，可以重置。</p></li><li><p><a href="https://codepen.io/ginnko/full/oWKbKz/" target="_blank" rel="noopener">计算器</a><br>FreeCodeCamp上的项目，模仿实体计算器，双行显示，能够计算20位以内的数字。</p></li><li><p><a href="https://codepen.io/ginnko/full/Omadzj/" target="_blank" rel="noopener">维基百科搜索引擎</a><br>FreeCodeCamp上的项目，使用英文够搜索维基百科内的所有词条并显示前10项内容。</p></li><li><p><a href="https://codepen.io/ginnko/full/mmzqVj/" target="_blank" rel="noopener">天气地址查看器</a><br>FreeCodeCamp上的项目，显示所在地点的具体地址和天气情况。  </p></li></ul><hr><h3 id="语言能力"><a href="#语言能力" class="headerlink" title="语言能力"></a>语言能力</h3><ul><li>英语：IELTS  6.5，CET6  512</li><li>日语：基本具备二级水平</li></ul><hr><h3 id="个人描述"><a href="#个人描述" class="headerlink" title="个人描述"></a>个人描述</h3><p>毕业之后在设计院工作，终因自己对编程的执念于17年4月辞职，开始前端的自学之路。17年10月进入目前的公司，正式开始前端开发。一年实际开发的经历和持续的学习，让我对前端有了更深刻的认识，也多了一份自信，难得的是能感受到这份工作带来的成就感和快乐，我相信自己可以借助前端走的更远。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React查缺补漏之三——《React小书》第一、第二阶段</title>
      <link href="/2018/11/02/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/"/>
      <url>/2018/11/02/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><a href="http://huziketang.mangojuice.top/books/react/" target="_blank" rel="noopener">React小书</a></p><h3 id="关于对React这个库的理解"><a href="#关于对React这个库的理解" class="headerlink" title="关于对React这个库的理解"></a>关于对React这个库的理解</h3><p>首先，React是一个库，而不是一个框架，它存在的意义是从下面几个角度降低前端开发的复杂性：</p><ol><li>封装了DOM操作</li><li>增强了代码的可复用性</li><li>封装了数据驱动页面更新的过程</li><li>封装了浏览器的兼容性</li><li>封装了事件处理过程</li></ol><a id="more"></a><h3 id="虚拟DOM存在意义"><a href="#虚拟DOM存在意义" class="headerlink" title="虚拟DOM存在意义"></a>虚拟DOM存在意义</h3><ol><li>根据不同的平台进行相应的抽象，这也是react-dom被抽出的原因</li><li>数据更新时，操作虚拟DOM的效率远高于操作实际DOM节点的效率</li></ol><h3 id="React中的event对象"><a href="#React中的event对象" class="headerlink" title="React中的event对象"></a>React中的event对象</h3><p>React中的<code>event</code>对象并不是浏览器提供的，而是它自己内部构建的。React将浏览器原生的event对象封装了以下，对外提供统一的API和属性，这样就不用考虑不同浏览器的兼容性问题。同时，这个event对象是符合W3C标准的，它具有类似event.stopPropagation、event.preventDefault这种常用的方法。</p><h3 id="React中的事件绑定"><a href="#React中的事件绑定" class="headerlink" title="React中的事件绑定"></a>React中的事件绑定</h3><p>React调用你传给它的方法的时候，并不是通过对象方法的方式调用(<code>this.handleClickOnTitle</code>)，而是直接通过函数调用(<code>handleClickOnTitle</code>)，<strong>所以事件监听函数内并不能通过<code>this</code>获取到实例</strong>。</p><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p><a href="https://reactjs.org/docs/react-component.html#defaultprops" target="_blank" rel="noopener">defaultProps</a></p><p>当设置这个组件类的静态属性后，没有给组件传递参数的时候(<code>undefined</code>)，会自动使用defaultProps中的值，如果传入<code>null</code>，将会使用<code>null</code>，而不是默认值。</p><p>一个简单的栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomButton.defaultProps = &#123;</span><br><span class="line">color: <span class="string">'blue'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关于componentWillUnmount"><a href="#关于componentWillUnmount" class="headerlink" title="关于componentWillUnmount"></a>关于componentWillUnmount</h3><p>componentWillUnmount：组件对应的 DOM 元素从页面中删除之前调用。</p><p>下面这样的场景就很有用了，在同事写的代码里有见过类似的写法：</p><p>多次的隐藏和显示会让 React.js 重新构造和销毁 Clock 组件，每次构造都会重新构建一个定时器。而销毁组件的时候没有清除定时器，所以你看到报错会越来越多。而且因为 JavaScript 的闭包特性，这样会导致严重的内存泄漏。</p><p>这时候componentWillUnmount 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 Clock 添加 componentWillUnmount，在组件销毁的时候清除该组件的定时器.</p><p>如果组件删除了，但是定时器没有被消除就会出现下图的错误：</p><p><img src="/images/react/componentWillUnmount.png" alt="componentWillUnmount"></p><h3 id="关于props-children"><a href="#关于props-children" class="headerlink" title="关于props.children"></a>关于props.children</h3><p>这个属性是个 <strong>数组</strong> ！！！！！！</p><p>所以可以这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'two-cols-layout'</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">'sidebar'</span>&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children[<span class="number">0</span>]&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className='main'&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children[1]&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="关于dangerouslySetInnerHTML"><a href="#关于dangerouslySetInnerHTML" class="headerlink" title="关于dangerouslySetInnerHTML"></a>关于dangerouslySetInnerHTML</h3><p>一般要这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  className=<span class="string">'editor-wrapper'</span></span><br><span class="line">  dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="keyword">this</span>.state.content&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>当需要往页面动态插入HTML结构的时候，我们只能使用<code>dangerouslySetInnerHTML</code>，注意为避免XSS攻击，需要对一些敏感字符进行转义处理：</p><p>一个简单的栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p dangerouslySetInnerHTML=&#123;&#123;</span><br><span class="line">  __html: <span class="keyword">this</span>._getProcessedContent(comment.content)</span><br><span class="line">&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">_getProcessedContent (content) &#123;</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">  .replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#039;"</span>)</span><br><span class="line">  ..replace(<span class="regexp">/`([\S\s]+?)`/g</span>, <span class="string">'&lt;code&gt;$1&lt;/code&gt;'</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面<code>_getProcessedContent</code>函数中的前五个<code>replace</code>都是用来进行转义处理的操作。</p><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><p>这个函数不要再使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十四-backgrounds</title>
      <link href="/2018/09/11/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-backgrounds/"/>
      <url>/2018/09/11/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-backgrounds/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_boxes/Backgrounds" target="_blank" rel="noopener">链接</a></p><h3 id="What-exactly-is-a-background"><a href="#What-exactly-is-a-background" class="headerlink" title="What exactly is a background"></a>What exactly is a background</h3><ol><li>默认情况下，背景会延伸到边框的外延。外边距并不算元素区域的一部分，而是算元素的外部区域。</li></ol><h3 id="The-basics-color-image-position-repeat"><a href="#The-basics-color-image-position-repeat" class="headerlink" title="The basics: color, image, position, repeat"></a>The basics: color, image, position, repeat</h3><h4 id="background-color"><a href="#background-color" class="headerlink" title="background color"></a>background color</h4><ol><li>元素默认的背景色是<code>transparent</code></li></ol><a id="more"></a><h3 id="background-image"><a href="#background-image" class="headerlink" title="background image"></a>background image</h3><p><code>background-image: url(https://mdn.mozillademos.org/files/13026/fire-ball-icon.png);</code> url中不用必须写成字符串</p><ol><li>background images使用css属性设置，所以对于辅助设备是不可见的。</li></ol><p>下面这段话解释了什么时候用background，什么时候用img元素。</p><blockquote><p>Background images are not content images – they are just for decoration – if you want to include an image on your page that is part of the content, then you should do so with an <code>&lt;img&gt;</code> element.</p></blockquote><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background repeat"></a>background repeat</h3><p>可以取得值有：</p><ul><li>no-repeat: 横向，竖向都完全不重复，只会显示一次</li><li>repeat-x: 会在横向重复</li><li>repeat-y：会在纵向重复</li><li>repeat： <em>默认值</em> ，在横向和纵向皆重复</li></ul><h3 id="background-position"><a href="#background-position" class="headerlink" title="background position"></a>background position</h3><p>这个属性允许摆放background image的位置，属性值是两个由空格分隔的值，可以是绝对值也可以是相对值，这两个值定义了<code>背景图片</code>的横纵坐标。</p><blockquote><p>Generally the property will take two values separated by a space, which specify the horizontal (x) and vertical (y) coordinates of the image. The top left corner of the image is the origin — (0,0). </p></blockquote><p>下面的观点出自<a href="https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/02/01/1948644.html" target="_blank" rel="noopener">这里</a>以及<a href="https://blog.csdn.net/u013778905/article/details/52811146" target="_blank" rel="noopener">这里</a>，其实并没有说清楚，结合自己的感觉，罗列如下：</p><ul><li><p>使用绝对值定位其实指的是图片的左上角相对于背景的左上角的偏移。</p></li><li><p>使用百分数定位是改变了背景图和元素的对齐基点，background-position： 100% 50%; 就是将背景图片的 100%（right） 50%（center） 这个点，和元素的 100%（right） 50%（center） 这个点对齐。</p></li><li><p>使用关键字定位感觉类似百分比</p></li></ul><h3 id="background-image-gradients"><a href="#background-image-gradients" class="headerlink" title="background image:gradients"></a>background image:gradients</h3><p>有两种gradient方式：线性和辐射</p><h4 id="线性gradient"><a href="#线性gradient" class="headerlink" title="线性gradient"></a>线性gradient</h4><p><code>background-image: linear-gradient(to bottom, orange, yellow);</code></p><p>linear-gradient函数接收三个参数：方向、起始颜色、结束颜色。</p><p>color stops: 下面的<code>orange 40%</code>就是一个color stops，可以指定任意个color stops，40%表示的是位置而不是颜色的程度，是沿着指定的方向按此值确定的，此处可以使用绝对值。</p><p><code>background-image: linear-gradient(to bottom, yellow, orange 40%, yellow);</code></p><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background attachment"></a>background attachment</h3><p>首先，这个属性只有在内容出现滚动的时候才会生效。</p><p>这个属性有三个值可用：</p><ul><li><p>scroll：页面滚动，背景图也跟着滚动，元素滚动，背景图固定</p></li><li><p>fixed：使背景图相对于视口fixed，无论内容还是页面滚动背景图都不会滚动</p></li><li><p>local：页面滚动或元素滚动，背景图都跟着滚动</p></li></ul><p>要看一下这个简写属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十三-box model recap</title>
      <link href="/2018/09/10/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-box-model-recap/"/>
      <url>/2018/09/10/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-box-model-recap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_boxes/Box_model_recap" target="_blank" rel="noopener">链接</a></p><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p><code>overflow</code>的默认值是<code>visible</code>。</p><a id="more"></a><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>默认情况下，<code>backgrounds</code>延伸到<code>border</code>的外边延。</p><p>使用<code>background-clip</code>属性可以设置<code>backgrounds</code>仅延伸到内容的边缘。</p><p><code>background-clip</code>可以设置的值有：</p><ul><li><p><code>border-box</code></p></li><li><p><code>padding-box</code></p></li><li><p><code>content-box</code></p></li><li><p><code>text</code></p></li></ul><p>设置在文本上的时候，可以这样设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-clip</span>: <span class="selector-tag">text</span>;</span><br><span class="line">-webkit-background-clip: text; // 针对chrome</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p><code>outline</code><strong>不是</strong>盒模型的一部分，看起来像是border，但实质是画在盒子的上方，同时也不会改变盒子的尺寸（具体来讲是画在边框外，在外边距内）。</p><h3 id="advanced-box-properties"><a href="#advanced-box-properties" class="headerlink" title="advanced box properties"></a>advanced box properties</h3><ol><li>setting width and height constraints</li></ol><p>一个常见的用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  width:  70%; // 给容器设置弹性宽度</span><br><span class="line">  max-width: 1280px; // 设置最大值，阻止宽度过大  </span><br><span class="line">  min-width： 480px; // 设置最小值，阻止宽度过小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>margin: 0 auto;</code>来给inner盒子居中在parent中时，需要设置本盒子的宽度，这个宽度设置成 <strong>百分比</strong> 也是有效果的。<code>auto</code>的意思是让容器左右两侧的外边距分享可用的空间，以实现居中的效果。</p><ol start="2"><li>changing the box model completely</li></ol><p>盒子的总宽 = <code>width</code> + <code>padding-left</code> + <code>padding-right</code> + <code>border-right</code> + <code>border-left</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十二-multiple-column layout</title>
      <link href="/2018/09/09/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-multiple-column-layout/"/>
      <url>/2018/09/09/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-multiple-column-layout/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Multiple-column_Layout" target="_blank" rel="noopener">链接</a></p><h3 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h3><p>真是出乎意料，这个属性竟然几乎被全部的浏览器支持！！！</p><ul><li><code>column-count</code>将创建属性值那么多数量的列。</li></ul><p>使用<code>column-count</code>创建出来的列具有弹性宽度。</p><ul><li><code>column-width</code></li></ul><p>使用这个属性将按照设定的属性值根据container的尺寸提供尽可能多的列，剩余的空间将<code>填充</code>到已生成的列中。也就是说没有办法得到设定的宽度，除非container的宽度恰好能被设定的宽度整除。</p><a id="more"></a><h3 id="设置列的样式"><a href="#设置列的样式" class="headerlink" title="设置列的样式"></a>设置列的样式</h3><p>出乎意料！！！通过<code>multicol</code>创建的列不能单独设置样式。没有办法做到一列比另一列宽，或是改变单独一列文本的颜色。只能通过<code>column-gap</code>或是<code>column-rule</code>这两个属性来整体改变每一列的样式。</p><p><strong>好像是个问题：通过column-*设置的样式貌似都没有办法通过浏览器的样式查看器进行查看和调试</strong></p><p><code>column-rule</code>是<code>column-rule-color</code>，<code>column-rule-style</code>以及<code>column-rule-width</code>三个属性的缩写。用于设置列边的样式。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">4px</span> dotted <span class="built_in">rgb</span>(79, 185, 227);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是<code>column-rule</code>属性并不会为它自己占据什么空间，而是<code>lies across</code>通过<code>column-gap</code>属性设置的<code>gap上</code>。如果想增加<code>column-rule</code>两边的空间，只有增加<code>column-gap</code>的值才能做到。</p><h3 id="columns-and-fragmentation"><a href="#columns-and-fragmentation" class="headerlink" title="columns and fragmentation"></a>columns and fragmentation</h3><blockquote><p>The content of a multi-column layout is fragmented. It essentially behaves the same way as content behaves in paged media —- such as when you print a webpage. When you turn your content into a multicol container it is fragmented into columns, and the content breaks to allow this to happen.</p></blockquote><p>这个<a href="https://codepen.io/pen/" target="_blank" rel="noopener">例子</a>中会出现标题和文本被分割的情况。</p><p>在容器中的元素上使用<code>break-inside: avoid</code>，明确告知我们不想对这个盒子使用片段化。</p><p>避免浏览器的不支持，建议混合使用下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">break-inside</span>: avoid;</span><br><span class="line">  <span class="attribute">page-break-inside</span>: avoid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十一-positioning</title>
      <link href="/2018/09/08/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-positioning/"/>
      <url>/2018/09/08/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-positioning/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning" target="_blank" rel="noopener">链接</a></p><h3 id="static-positioning"><a href="#static-positioning" class="headerlink" title="static positioning"></a>static positioning</h3><p><em>static positioning</em> 是每个元素获得的默认属性，这个属性的意思是：把这个元素摆在文档正常流的正常位置就好。</p><h3 id="relative-positioning"><a href="#relative-positioning" class="headerlink" title="relative positioning"></a>relative positioning</h3><p>设置为<code>position: relative</code>的元素：依然占据文档正常流中的位置，但是可以通过<code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>调整位置。</p><a id="more"></a><h3 id="absolute-positioning"><a href="#absolute-positioning" class="headerlink" title="absolute positioning"></a>absolute positioning</h3><p>一个绝对定位的元素不再在文档普通流中存在，<strong>它存在于自己的层中</strong>。这意味着我们可以创建孤立的ui特性同时不会干扰页面上的其他元素。比如 <em>弹出消息框</em>，<em>控制菜单</em>, <em>拖拽或低落的效果</em>。</p><p>对于绝对定位元素，margin属性依然有效。</p><h3 id="positioning-contexts"><a href="#positioning-contexts" class="headerlink" title="positioning contexts"></a>positioning contexts</h3><blockquote><p>if no ancestor elements have their position property explicitly defined, then by default all ancestor elements will have a static position. The result of this is, the absolutely positioned element will be contained in the <strong>initial containing block</strong>. The initial containing block has the dimensions of the viewport, and is also the block that contains the html element. Simply put, the absolutely positioned element will be contained outside of the html element, and be positioned relative to the initial viewport.</p></blockquote><p>解决了我的一大困惑：<strong>父元素没有做任何特殊处理的绝对定位元素，将被包含在html元素之外（这意思是不再被html元素包裹？），将相对于初始包含块定位。</strong></p><p>可以通过给父元素指定<code>position: relative</code>或<code>position: absolute</code>来更改positioning contexts。</p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>首先要知道的是：当我们绝对定位一个元素之后，它就会出现在最顶层，因为<em>绝对定位元素</em>在和<em>non-positioned</em>元素争夺高空权的时候，胜出。</p><p>但是，当有多个（同一父元素下的兄弟？示例里使用的这种形式）元素时，就可以使用<code>z-index</code>属性来控制z-axis方向上的顺序。</p><h3 id="fixed-positioning"><a href="#fixed-positioning" class="headerlink" title="fixed positioning"></a>fixed positioning</h3><p>固定定位元素相对于 <strong>浏览器视口</strong> 定位。</p><h3 id="sticky-positioning"><a href="#sticky-positioning" class="headerlink" title="sticky positioning"></a>sticky positioning</h3><p>之前有看过这个</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之九-grids</title>
      <link href="/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-grids/"/>
      <url>/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-grids/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids" target="_blank" rel="noopener">链接</a></p><p>Grid布局是二维的布局方法。能同时在row和column两个方向上进行布局。</p><h3 id="What-is-grid-layout"><a href="#What-is-grid-layout" class="headerlink" title="What is grid layout"></a>What is grid layout</h3><p><img src="/images/css/grids-scheme.png" alt="grids-scheme"></p><a id="more"></a><h3 id="defining-a-grid"><a href="#defining-a-grid" class="headerlink" title="defining a grid"></a>defining a grid</h3><p><strong>下面的内容皆是创建网格时所用：</strong></p><ol><li><p>设置一个grid box默认是创建了 <strong>一列</strong> 的grid</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加列, 使用<code>grid-template-columns</code>属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>说明：创建列的宽度的单位可以使用任意单位。</p><ol start="3"><li>使用<code>fr</code>创建弹性尺寸的行与列</li></ol><p><code>1fr</code>表示一个grid盒子中的 <strong>可用空间</strong> 的一块,也就是按比例布局。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！<code>fr</code>分发的是可用空间，而不是所有的空间。因此，如果一个track（不知道翻译成什么好，理解为一列吧）中的东西过大，就会压缩外面剩余的可用空间。</p><ol start="4"><li><p>使用<code>grid-column-gap</code>创建列间距，使用<code>grid-row-gap</code>创建行间距，<code>grid-gap</code>同时创建行和列间距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了代码更无懈可击，推荐使用下面这种bulletproof的写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  gap: 20px; // 这个在vscode里被识别为无效...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重复track listings，使用<code>repeat</code>函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 1fr);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>implicit and explicit grid（这里要翻译成隐式和显示创建）</p></li></ol><p>使用<code>grid-template-columns</code>以及<code>grid-template-rows</code>来显式创建行和列。</p><blockquote><p>The implicit grid is created whrn content is placed outside of that grid - such as into our rows.</p></blockquote><p>上面这是啥意思？</p><p>默认情况下，在隐式网格中创建的tracks都是自动调整大小的，这意味着，通常情况下，它们都能盛下其中的内容。</p><p>其实不太明白，但是可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>来隐式设置网格，值可以取<code>auto</code>也可以取<code>具体的值</code>。</p><ol start="8"><li><p><code>minmax()</code>function</p><p><code>minmax(100px, auto);</code>表示最小值是100px，最大值为auto，也就是大小能容纳内容。</p></li><li><p>组合使用<code>minmax()</code>函数和<code>repeat()</code>函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, minmax(200px, 1fr));</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="built_in">minmax</span>(100px, auto);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repeat函数中，</p><p>第一个参数表示要创建的个数，使用auto-fill表示创建尽可能多的列来满足container的空间</p><p>第二个参数表示每列的尺寸，最小尺寸为200px，最大尺寸为1fr</p></li></ol><h3 id="Line-based-placement"><a href="#Line-based-placement" class="headerlink" title="Line-based placement"></a>Line-based placement</h3><ul><li><p><code>grid-column-start</code></p></li><li><p><code>grid-column-end</code></p></li><li><p><code>grid-row-start</code></p></li><li><p><code>grid-row-end</code></p></li></ul><p>缩写形式：</p><ul><li><p><code>grid-column</code></p></li><li><p><code>grid-row</code></p></li></ul><p>比如像下面这样使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="positioning-with-grid-template-areas"><a href="#positioning-with-grid-template-areas" class="headerlink" title="positioning with grid-template-areas"></a>positioning with grid-template-areas</h3><p>使用<code>grid-template-areas</code>和<code>grid-area</code>两个属性。</p><ul><li><p><code>grid-template-areas</code>用来设置位置</p></li><li><p><code>grid-grid</code>用来给内容命名</p></li></ul><p>比如像下面这样使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">      <span class="string">"header header"</span></span><br><span class="line">      <span class="string">"sidebar content"</span></span><br><span class="line">      <span class="string">"footer footer"</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-template-areas</code>遵循下面的原则：</p><ol><li><p>每一个网格的cell都要被填充</p></li><li><p>跨越两个cells，重复名字即可</p></li><li><p>留下一个空白cell，使用句点即可</p></li><li><p>每一个dom元素只能占据矩形空间</p></li><li><p>没一个dom元素只能占据连续空间</p></li></ol><p>ps.火狐有<code>Firefox Grid Inspector</code>这个神器，为毛chrome没有？？？</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十-floats</title>
      <link href="/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-floats/"/>
      <url>/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-floats/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats" target="_blank" rel="noopener">链接</a></p><h3 id="浮动的结果"><a href="#浮动的结果" class="headerlink" title="浮动的结果"></a>浮动的结果</h3><p><code>float</code>本来是用来在一块文本中浮动图片的,多行布局交给了<code>flex</code>和<code>grid</code>，链接中的文章就是从这个角度来介绍float的。</p><p>浮动元素会脱离正常流。</p><p>浮动只会在元素所在的原始行开始浮动，并不会像<code>position: absolute</code>“浮的”那么彻底。</p><blockquote><p>the element with the float set on it is taken out of the normal layout flow of the document and stuck to the left and side of its parent container. Any content that comes below the floated element in the normal layout flow will now wrap around it, filling up the space to the right-hand side of it as far up as the top of the floated element. There it will stop.</p></blockquote><p>只能通过给<code>浮动元素</code>的一侧添加外边距来调整浮动元素和环绕它的文本的间距。</p><a id="more"></a><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>使用<code>clear</code>属性，可以取得值有：</p><ul><li><p>left</p></li><li><p>right</p></li><li><p>both</p></li></ul><h3 id="clearing-boxes-wrapped-around-a-float"><a href="#clearing-boxes-wrapped-around-a-float" class="headerlink" title="clearing boxes wrapped around a float"></a>clearing boxes wrapped around a float</h3><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>Float<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(207,232,220);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(79,185,227);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会出现图片中的布局：</p><p><img src="/images/css/clearing-box.png" alt="clearing-box"></p><p>造成这种结果的原因是浮动元素脱离了正常流。想做到文本在浮动元素旁边排列且外部盒子能包住两个元素，靠给文本添加清除浮动是无法做到的，只会导致文本另起一行。</p><p>解决办法：</p><ol><li>clearfix hack</li></ol><p>实质就是在wrapper后面添加内容，并两侧清除浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>overflow</code>值非<code>visible</code></li></ol><p>实质是这个属性让wrapper成为了一个新的BFC，而BFC在计算高度的时候会包含浮动元素。</p><ol start="3"><li>使用<code>display: flow-root</code></li></ol><p>专业的做法，实质也是创建了新的BFC。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之七-BFC2</title>
      <link href="/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-bfc2/"/>
      <url>/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-bfc2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/xiaohuochai/p/5248536.html" target="_blank" rel="noopener">链接</a></p><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>常说的文档流可以分为<code>定位流</code>，<code>浮动流</code>，<code>普通流</code>三种。而<code>普通流</code>其实就是指BFC中的FC（formatting context），直译过来就是格式化上下文，<strong>它是页面上的一块渲染区域，有一套渲染规则，决定了其子元素如何布局以及和其他元素之间的关系和作用。</strong>常见的FC有BFC，IFC，GFC，FFC。BFC是block formatting context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域。</p><a id="more"></a><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC是页面上的一个隔离的独立容器，<strong>容器里面的子元素不会影响到外面的元素，反之亦然</strong>。它与普通的块框类似，但不同之处在于：</p><ol><li><p>可以阻止元素被浮动元素覆盖</p></li><li><p>高度计算是会包含浮动元素，解决父元素高度坍塌的问题</p></li><li><p>属于同一个BFC的两个相邻块级资源素的上下外边距会发生坍塌的现象，所以当两个相邻块级子元素分属于不同的BFC时可以阻止外边距坍塌。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之八-flexbox</title>
      <link href="/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-flexbox/"/>
      <url>/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-flexbox/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox" target="_blank" rel="noopener">链接</a></p><p>flex是一维布局方法，将flex items在row方向上布局或是在column方向上布局。flex item会伸缩来适应剩余空间或空间不够的情况。<strong>成为flex-items的元素可以认为是一个 <em>块级盒子</em>。</strong></p><h3 id="设置在-flexbox-上的属性"><a href="#设置在-flexbox-上的属性" class="headerlink" title="设置在 flexbox 上的属性"></a>设置在 flexbox 上的属性</h3><ol><li>display: box</li><li>flex-direction: row | column | row-reverse | column-reverse</li><li><p>flex-wrap: wrap </p><p> 当flex items数量过多，导致超出flex box的时候，上面这个属性会让flex items分布在多行显示，消除溢出flex box的问题。</p></li><li><p>flex-flow = flex-direction + flex-wrap</p><p> 上面的设置可以写成： <code>flex-flow: row wrap;</code></p></li></ol><a id="more"></a><h3 id="设置在-flex-items-上的属性"><a href="#设置在-flex-items-上的属性" class="headerlink" title="设置在 flex items 上的属性"></a>设置在 flex items 上的属性</h3><ol><li><p>flex: 1 200px;</p><p> 第1个无单位的属性表示元素将在主轴上占据多少空间（设置完padding和margin后留下的剩余空间）。</p><p> 第2个<code>200px</code>参数表明最小尺寸。</p><p> 上面这个属性的意思是：每一个flex item首先会给<code>200px</code>的可用空间。之后，剩余的空间将按照比例<code>1</code>来分。</p></li><li><p>flex是一个缩写属性，最多能设置三个值（<strong>mdn上建议使用缩写形式</strong>）：</p><ul><li>flex-grow：无单位的比例</li><li>flex-shrink： 无单位的比例</li><li>flex-basis： 最小空间</li></ul></li><li><p>align-items:控制flex items如何在交叉轴上摆放，可以取得值有：</p><ul><li>stretch：默认值，将会拉伸flex items的高度和父元素相同</li><li>center：flex items将保持固有尺寸，但是会沿着交叉轴居中</li><li>flex-start/flex-end：定位在交叉轴的start/end位置</li></ul></li><li><p>justify-content：控制flex items在主轴上如何摆放，可以取得值有：</p><ul><li>flex-start(默认值):从主轴的start处开始</li><li>flex-end：从主轴的end处开始</li><li>center：定位在主轴的中间</li><li>space-around: 在每个元素的左右两侧都留相同的空间，导致最靠边的两个元素左右两侧距离边框有距离，且元素和元素之间的空间要比刚说的这个空间大。整个主轴的空间被这些flex items瓜分。</li><li>space-between: 最外侧的两个元素靠近边框的一侧没有多余的空间，整个主轴的空间被flex items瓜分，剩余的空间都分布在flex items之间了。</li></ul></li><li><p>order:</p><ul><li>默认值： 0</li><li>数值越大排序越靠后</li></ul></li></ol><h3 id="Nested-flex-boxes"><a href="#Nested-flex-boxes" class="headerlink" title="Nested flex boxes"></a>Nested flex boxes</h3><p>这个已经用过多次了</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之六-普通流</title>
      <link href="/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-normal-flow/"/>
      <url>/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-normal-flow/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow" target="_blank" rel="noopener">链接</a></p><p>在正常流中，</p><p><em>块级元素</em> 竖向堆叠， 它们之间的距离由各自的外边距叠加而成。</p><a id="more"></a><p><em>内联元素</em> 在同一行水平挨着摆放。</p><p><em>外边距坍塌</em>, 如果两个相邻的的元素且都设置了外边距（ <strong>这里感觉特指是块级元素，且特指上下外边距，试了下，内联元素不会发生坍塌，块级元素的左右外边距也不会发生坍塌，印象中也说的是块级元素的上下外边距</strong> ）</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之五-css布局介绍</title>
      <link href="/2018/09/04/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-introduction-to-css-layout/"/>
      <url>/2018/09/04/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-introduction-to-css-layout/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Introduction" target="_blank" rel="noopener">链接</a></p><p><img src="/images/css/css定位方案.png" alt="一张神图"></p><h3 id="Normal-flow"><a href="#Normal-flow" class="headerlink" title="Normal flow"></a>Normal flow</h3><p>能够改变元素的布局的方法如下：</p><ol><li><code>display</code></li><li><code>Floats</code></li><li><code>position</code></li><li><code>Table layout</code></li><li><code>Multi-column layout</code></li></ol><a id="more"></a><h4 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h4><p>在父元素上设置<code>display：flex</code>，然后它的直属子元素就变成了<code>flex items</code>。</p><p>比如下面这个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>flex初始设置：</p><p>没有给<code>wrapper</code>设置<code>display:flex</code>之前，它的三个子元素将竖向堆叠;设置后，它们将排成一行，<strong>这是由于它们成为了flex items 并且拥有了flex box给它们的初始属性</strong>，其中<code>flex-direction: row</code>，所以就排成了一行。它们都被拉伸到最高<code>item</code>的高度，这是因为<code>align-items: stretch</code>,这意味着<code>items</code>拉伸到flex容器的高度，这里是由最高的<code>item</code>决定的。<code>items</code>从容器的开始排成一行，在该行的后面留下多余的空间。</p><p>上面提到的<code>flex-direction</code>和<code>align-items</code>都是应用在<code>flexbox</code>上面的。</p><h4 id="Grid-Layout"><a href="#Grid-Layout" class="headerlink" title="Grid Layout"></a>Grid Layout</h4><p>flexbox是为一维布局设计的，也就是说只能横向或竖向布局。grid布局是为二维布局设计的，同时在横向和竖向两个方向上布局。</p><p>使用<code>display: grid</code>将布局方式转换为grid布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box5"</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box6"</span>&gt;</span>Six<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面提到的<code>grid-template-rows</code>以及<code>grid-template-columns</code>属性是应用在<code>gridbox</code>上的。上面的例子定义了三列，每列1fr，两行，每行100px。</p><p>下面的这个例子简直惊了…</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Floats"><a href="#Floats" class="headerlink" title="Floats"></a>Floats</h4><h4 id="Positioning-techniques"><a href="#Positioning-techniques" class="headerlink" title="Positioning techniques"></a>Positioning techniques</h4><p>positioning允许你将处在正常流中的元素所在位置移到他处。<strong>Positioning不是创建主页面布局的方法，更多的是用来微调页面上个别元素的位置。</strong></p><p>positioning可以取以下五个值：</p><ol><li><code>static</code>：默认值，在<code>Normal flow</code>中</li><li><code>relative</code>：在<code>Normal flow</code>中</li><li><p><code>absolute</code>：完全脱离<code>Normal flow</code></p><p> 在<a href="./2018-08-31-css查漏补缺之一-格式上下文.md">格式化上下文</a>一文中，有记录：子元素浮动导致父元素高度出现坍塌的原因是在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由其他的子元素的高度撑开的。但是如果子元素是设置了浮动，<strong>脱离了文档流</strong>,那么父元素计算高度的时候就会忽略该子元素，出现父元素高度为0的现象。解决办法是让父元素新建一个BFC，其在计算高度的时候，会把浮动资源素包进来。</p><p> <code>absolute</code>也会导致元素完全脱了<code>normal flow</code>，但即便给其父元素设置了创建BFC的属性，也不能解决副元素高度坍塌的问题，看来，对于<code>absolute</code>是包不进来了。</p></li><li><p><code>fixed</code>：完全脱离<code>Normal flow</code></p></li><li><code>sticky</code>：元素开始表现的像<code>static</code>，直到它 hit a defined offset from the viewport，此刻就开始按<code>fiexed</code>行事。</li></ol><p>点击<a href="https://codepen.io/ginnko/pen/OogrwQ" target="_blank" rel="noopener">此处</a>详见示例。</p><blockquote><p> A stickily positioned element is treated as relatively positioned until it crosses a specified threshold, at which point it is treated as fixed until it reaches the boundary of its parent. </p></blockquote><p>一个使用<code>position: sticky</code>布局的元素在到达设置的阈值之前将表现为<code>relative</code>的布局形式，到达阈值后将被当作<code>fixed</code>布局，直到它碰到它的父元素。</p><h4 id="Table-layout"><a href="#Table-layout" class="headerlink" title="Table layout"></a>Table layout</h4><p>现代浏览器使用<code>flexbox</code>以及<code>grid</code>，这个就不看了</p><h4 id="Multi-column-layout"><a href="#Multi-column-layout" class="headerlink" title="Multi-column layout"></a>Multi-column layout</h4><p>点击<a href="https://codepen.io/ginnko/pen/BOZEoR" target="_blank" rel="noopener">此处</a>详见示例。这个例子在容器元素上使用<code>column-width: 200px;</code>，使得浏览器创建尽可能多的200像素的<code>column</code>填充进容器，然后将剩余的空间布置在创建的<code>column</code>周围。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之三-浮动和清除浮动</title>
      <link href="/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89-%E6%B5%AE%E5%8A%A8%E5%92%8C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89-%E6%B5%AE%E5%8A%A8%E5%92%8C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">链接</a></p><p>使用<code>float</code>就意味着使用了<code>块状布局</code>，在某些情况下它修改了<code>display</code>的计算值</p><p><img src="/images/css/float-block.png" alt="float-block"></p><p>图中<code>inline-block</code>和<code>table-*</code>系列以及<code>flex-*</code>系列的本身会创建一个新的BFC，好像也没啥关系诶…</p><p>注：使用<code>js</code>访问这个<code>float</code>属性时，要写成<code>cssFloat</code>。</p><h3 id="how-floated-elements-are-positioned"><a href="#how-floated-elements-are-positioned" class="headerlink" title="how floated elements are positioned"></a>how floated elements are positioned</h3><p>当一个元素被设置为浮动，它就脱离了文档的正常流（但它仍然是文档的一部分），它向左或右移动，直到它碰到了 <strong>包含它的容器的边缘或者其他的浮动元素的边缘</strong>(注意这个描述！！！)。</p><a id="more"></a><p>比如下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span><br><span class="line">     Morbi tristique sapien ac erat tincidunt, sit amet dignissim</span><br><span class="line">     lectus vulputate. Donec id iaculis velit. Aliquam vel</span><br><span class="line">     malesuada erat. Praesent non magna ac massa aliquet tincidunt</span><br><span class="line">     vel in massa. Phasellus feugiat est vel leo finibus congue.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">background</span>: cyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clear" target="_blank" rel="noopener">链接</a></p><p>清除浮动的含义：强制一个元素移动到一个浮动元素的下方。比如你想让一个段落挨着一个浮动元素，但是强制让标题位于另一行。</p><p><code>clear</code>属性定义了一个元素能在一个浮动元素的旁边还是必须要移动到它的下方。<code>clear</code>这个属性既能应用在<code>浮动元素</code>上又能应用在<code>非浮动元素</code>上。</p><p>未完待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之四-盒模型</title>
      <link href="/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction-to-the-CSS-basic-box"><a href="#Introduction-to-the-CSS-basic-box" class="headerlink" title="Introduction to the CSS basic box"></a>Introduction to the CSS basic box</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">链接</a></p><p>每一个盒模型都是由四个部分组成，由它们各自的edge定义：内容edge、内边局edge、边框edge以及外边距edge。</p><p><img src="/images/css/box-model.png" alt="盒模型"></p><ul><li><p>内容区域：如果<code>box-sizing</code>属性被设置为<code>content-box</code>(默认值)，内容区域的尺寸可以被进一步通过<code>width</code>,<code>min-width</code>,<code>max-width</code>,<code>height</code>,<code>min-height</code>,<code>max-height</code>定义。</p></li><li><p>内边距区域：在内容区域的基础上扩张</p></li><li><p>边框区域：在内边距的基础上扩张。如果<code>box-sizing</code>属性被设置为<code>border-box</code>，边框区域的宽度能被进一步通过<code>width</code>，<code>min-width</code>，<code>max-width</code>，<code>height</code>，<code>min-height</code>，<code>max-height</code>定义。当给这个盒子设置了背景（背景颜色或者是背景图片），背景会延伸到边框的外延，位于边框的下方。可以通过<code>background-clip</code>这个属性对上述背景特征进行修改。</p></li><li><p>外边距区域：在边框的基础上扩张。</p></li></ul><p>对于未替换的内联元素，占据空间的大小是由<code>line-height</code>这个属性决定的，尽管边框和内边距依然会展示在内容周围。</p><a id="more"></a><h3 id="外边距坍塌"><a href="#外边距坍塌" class="headerlink" title="外边距坍塌"></a>外边距坍塌</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">链接</a></p><p>外边距坍塌：一个块状元素的 <strong>上下外边距</strong>，有时会重叠成单个边距，大小是这两个边距中的大者。 <strong>浮动元素</strong>和 <strong>绝对定位元素</strong>永远不会发生编剧坍塌的问题。</p><p>外边距坍塌发生的三种情况：</p><ol><li><p>相邻兄弟元素</p></li><li><p>父元素和第一个或者最后一个子元素：如果没有边框，内联部分，没有BFC被创建，也没有清除机制分隔一个块和它的子块元素的margin-top或者margin-bottom，那么就会发生外边距坍塌，坍塌的外边距延伸到父元素外。</p></li><li><p>空块元素：如果没有边框，没有内边距，没有内联内容，没有高度和最小高度的属性设置分隔一个块状元素的上下外边距，那它的上下外边距就会坍塌。</p></li></ol><p>注意：</p><ol><li><p>如果有负外边距存在，外边距坍塌后的大小是最大正外边距与最小负外边距之和;</p></li><li><p>如果参与坍塌的双方外边距都是负值，坍塌后的尺寸是最小负外边距。对于相邻和包含元素都适用。</p></li></ol><h3 id="visual-formatting-model"><a href="#visual-formatting-model" class="headerlink" title="visual formatting model"></a>visual formatting model</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model" target="_blank" rel="noopener">mdn(看不明白)</a></p><p><a href="http://layout.imweb.io/article/box-type.html" target="_blank" rel="noopener">简单易懂的文章</a></p><ol><li>块级元素和块盒子</li></ol><p>块级元素定义：当一个元素的<code>display</code>属性的计算值为<code>block</code>，<code>list-item</code>，<code>table</code>,<code>flex</code>,<code>grid</code>时，它就是块级元素，块级元素会生成块级盒子，一个块级元素会垂直堆叠。</p><p>行内级元素：当一个元素的<code>display</code>属性的计算值为<code>inline</code>,<code>inline-block</code>,<code>inline-table</code>,<code>inline-flex</code>,<code>inline-grid</code>时，它就是行内级元素，行内级元素生成行内级盒。</p><p>行内级元素生成的盒子又可以分为 <strong>行内盒</strong>和 <strong>原子行内盒</strong>（感觉这名字有点傻逼…）。行内盒（<code>display: inline</code>）一行显示不下的话会折行显示，而原子行内盒（<code>display: inline-block</code>）不能拆分，其中的内容一行显示不下的话会整体下移（卧槽，做了个实验，真的不折行诶，如果在原子行内盒中的内容过多，依然不弯，而是自动加了水平滚动条，真是盒子界的钢铁直男！）。</p><p>块容器盒：就是该元素的直接子元素只能是块级盒，或只能是行内级盒。</p><p>匿名盒：匿名盒当然是没有名字，所以断然不会被css选择器选中，也就不能为其设置样式。匿名盒的所有样式均来自<em>继承</em>或是<em>初始值</em>。有匿名块盒也有匿名行内盒。</p><p>行盒：行盒与行内盒是不一样的，<strong>行盒是由行内格式化上下文产生的盒，用于表示一行</strong>。费解：既然有了行内盒还要行盒干嘛？行盒从块盒的一边延伸到另一边，当有左浮动时，行盒从浮动元素的最右边延伸到块盒的最右边，右浮动相反。</p><p>定位方案：</p><p>一旦生成盒子，css引擎就需要在布局中定位这些盒子，定位的方案有如下三种：</p><ol><li>正常流</li><li>浮动算法</li><li>绝对定位方案</li></ol><ul><li><p>正常流：盒子是一个挨着一个排列的，在BFC中，是竖向排列的，在IFC中，是横向排列的。正常流当<code>position</code>设置为<code>static</code>或是<code>relative</code>或者<code>float</code>属性被设置为<code>none</code>就会被激活。</p></li><li><p>浮动：浮动会创建浮动盒子，浮动盒子会被摆在当前行的开头或是行尾。</p></li><li><p>绝对定位：在绝对定位中，盒子会从<code>flow</code>中被完全移除，和<code>flow</code>再无交集。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之二-BFC</title>
      <link href="/2018/09/02/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-BFC/"/>
      <url>/2018/09/02/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-BFC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">链接</a></p><p>BFC可以理解为了一个区域，其中有规定块状盒子该如何布局，浮动元素将如何和其他元素打交道。</p><p>下面至少一个方法就能创建一个BFC</p><ol><li>根元素</li><li>浮动（<code>float</code>属性值不是<code>none</code>）</li><li>绝对定位元素（<code>position</code>是<code>absolute</code>或者<code>fixed</code>）</li><li>设置为<code>inline-block</code>的元素（<code>display: inline-block</code>）</li><li>table cells（HTML table cells或者是<code>display: table-cell</code>）</li><li>table caption（HTML table captions 或者是<code>display: table-caption</code>）</li><li>通过<code>display:</code>设置值为<code>table</code>或者<code>table-row</code>或者<code>table-row-group</code>或者<code>table-header-group</code>或者<code>table-footer-group</code>或者<code>inline-table</code>（对于HTML的tables, table row, table bodies, table headers 以及 table footers 默认就会创建）——隐式创建的table-cell</li><li>块状元素的<code>overflow</code>属性值设置为非<code>visible</code></li><li>设置<code>display: flow-root</code></li><li>元素被设置为<code>contain:layout或者content或者strict</code></li><li>flex items（被设置为<code>display: flex 或者 inline-flext</code>的元素的 <strong>直接子元素</strong>）</li><li>grid items（被设置为<code>display: grid 或者 inline-grid</code>的元素的 <strong>直接子元素</strong>）</li><li>多列容器（元素被设为<code>column-count</code>或者<code>column-width</code>不为<code>auto</code>）——这个听都没听过…</li><li><code>column-span:all</code>永远都会创建一个新的BFC —— 没听过…</li></ol><p><strong>如果一个元素创建了一个BFC，那么这个元素的一切子元素都位于这个BFC中。</strong></p><a id="more"></a><p>只有位于同一个BFC中的元素，对它们使用布局或者清除浮动或者边距坍塌规则才会起作用。</p><p>例子已在<a href="./2018-08-31-css查漏补缺之一-格式上下文.md">上一篇</a>中有写。</p><p>下面看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">浮动</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clear" target="_blank" rel="noopener">清除浮动</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Flow_Layout_and_Writing_Modes" target="_blank" rel="noopener">flow-layout-and-writing-modes</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model" target="_blank" rel="noopener">visual-formatting-model</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model" target="_blank" rel="noopener">css-box-model</a>五篇。</p><p>ps.感觉mdn上关于css的文章没有什么顺序诶…有点乱…</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之一-格式上下文</title>
      <link href="/2018/08/31/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2018/08/31/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Formatting_Contexts_Explained" target="_blank" rel="noopener">链接</a></p><h3 id="格式上下文"><a href="#格式上下文" class="headerlink" title="格式上下文"></a>格式上下文</h3><p>页面上的所有东西都处在一个格式上下文中，这个格式上下文可以理解为一个固有结界，它依据规则规定如何摆放内容。</p><p><code>Block Formatting Context</code>根据<code>Block Layout rules</code>来摆放它的子元素。</p><p><code>Flex Formatting Context</code>把它的子元素按照<code>flex items</code>摆放。</p><p><code>html</code>元素定义了最初的<code>BFC</code>,意味着<code>html</code>中的元素都依据<code>Normal Flow</code>的规则摆放。这个规则由<code>css盒模型</code>勾勒，定义了元素的<code>margin</code>，<code>border</code>， <code>padding</code>是如何和相邻的block元素交互的。</p><a id="more"></a><h3 id="创建BFC"><a href="#创建BFC" class="headerlink" title="创建BFC"></a>创建BFC</h3><p><code>html</code>元素不是唯一具有创建BFC能力的元素。新的BFC和document的效果类似，就好像在一个主布局中开辟了一个迷你布局。浮动和清除浮动只会应用在位于相同格式上下文中的元素，而margin也只会collapse在位于相同格式上下文中的元素。</p><p>除了html，下面这些情况也会创建BFC</p><ol><li>浮动元素</li><li>绝对定位元素</li><li>有<code>display:inline-block</code>属性值的元素</li><li>table cells或者是有<code>display：table-cell</code>属性值的元素</li><li>table caption或者是有<code>display：table-caption</code>属性值的元素</li><li>块状元素的<code>overflow</code>属性的属性值是<code>visible</code>以外的值</li><li><code>display: flow-root</code></li><li>有<code>contain:layout,content或者strict</code>的元素</li><li>flex项目</li><li>grid项目</li><li>多列容器</li><li>有<code>column-span：all</code>的元素</li></ol><hr><p>下面是几个脱离正常流的例子</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动元素会脱离<code>正常流</code>，创建一个新的BFC。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/In_Flow_and_Out_of_Flow#Floated_Items" target="_blank" rel="noopener">这个浮动的例子</a></p><p>直接翻译这个例子下面的解释：你能看到紧随其后的段落的背景颜色穿过浮动元素。只有段落中的行盒子被压缩导致了文本环绕浮动元素的效果。<strong>段落的盒子依旧按照正常流的规则摆放</strong>，所以要使得浮动元素周围有空间，只能通过<code>给浮动元素增加外边距的办法</code>，给还处在正常流中的内容应用其他方法都做不到。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>给一个元素赋值<code>position: absolute</code>或者<code>position: fixed</code>都会将它从正常流中移除，并且它占有的空间也会一同被夺走。</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>给一个元素赋值<code>position:relative</code>表示他将会继续待在正常流中，然而你可以使用<code>offset</code>将它向四处推动。它在正常流中的空间依然会被保留。</p><hr><p>继续创建BFC的话题</p><p>下面这个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(244, 206, 247);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid rebeccapurple;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>I am a floated box!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am content inside the container.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个新的BFC会承载这个浮动元素。之前典型的做法是设置<code>overflow: auto</code>或者是设置其他非默认值<code>overflow: visible</code>。现在我们的<code>div</code>成为我们布局中的一个迷你布局了，<strong>任何子元素都将被它包含在其中</strong>。</p><p>使用<code>overflow</code>来创建BFC的问题在于<code>overflow</code>属性是用来告知浏览器你想如何处理满溢的内容（也就是说虽然能达到效果但是不合语义）。仅使用这个方法，在某些情况下，还会出现导航条或是修剪阴影的副作用。除此之外，对于后面的开发者也会带来阅读理解的问题，他们可能意识不到你是出于这个目的设置了这个属性在此，如果这样做了，最好留下注释。</p><p>一个完美的解决办法是使用<code>display: flow-root</code>这个新属性来创建新的BFC，这个属性不会带来任何副作用（看名字就知道干嘛用哒）。在<code>div</code>上使用<code>display: flow-root</code>，其中的所有子元素都将是这个新BFC的参与者，就不会出现浮动元素戳破其父元素（父元素有内容）或者父元素高度为零（父元素没有内容）的情况了。</p><p><strong>元素浮动父元素高度出现坍塌的原因：在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由他的子元素的高度撑开的。但是如果子元素是设置了浮动，脱离了文档流，那么父元素计算高度的时候就会忽略该子元素，就可能会出现父元素高度为零的情况。</strong></p><p><strong>新建BFC解决高度坍塌的原理：父元素在新建一个BFC的时候，其高度计算时，会把浮动子元素包进来。</strong></p><h3 id="inline-formatting-context"><a href="#inline-formatting-context" class="headerlink" title="inline formatting context"></a>inline formatting context</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Formatting_Contexts_Explained#An_inline_formatting_context" target="_blank" rel="noopener">链接</a></p><p>IFC（为啥没有这种缩写？这里就用这个缩写了）存在于其他格式上下文中，可以被想成是一个段落的上下文。这个段落创建了一个IFC，其中比如<code>strong</code>，<code>a</code>，<code>span</code>这些元素都是用在文本上的。</p><p><strong>盒模型</strong>不会完全用在IFC中的内容上。在水平书写的一行文本中，<strong>水平方向上的</strong><code>padding</code>，<code>borders</code>以及<code>margin</code>将会生效，将左右两侧的文本推开。<code>margin</code>在竖直方向上不会生效，<code>boder</code>和<code>padding</code>在竖直方向上会生效，但起不到推开上下内容的作用。</p><p>示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Before that night—<span class="tag">&lt;<span class="name">strong</span>&gt;</span>a memorable night<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>, as it was to prove—hundreds of millions of people had watched the rising smoke-wreaths of their fires without drawing any special inspiration from the fact.”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他格式上下文"><a href="#其他格式上下文" class="headerlink" title="其他格式上下文"></a>其他格式上下文</h3><p>创建任何种类的格式上下文，都将改变位于其中的子元素的排布方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之二十 ——《继承和原型链》</title>
      <link href="/2018/08/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C%E5%8D%81-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/08/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C%E5%8D%81-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">链接地址</a></p><h3 id="获取和设置原型对象的标准方法"><a href="#获取和设置原型对象的标准方法" class="headerlink" title="获取和设置原型对象的标准方法"></a>获取和设置原型对象的标准方法</h3><ul><li>获取：<code>Object.getPrototypeOf()</code></li></ul><p>以后可以不用<code>__proto__</code>这个属性了。</p><a id="more"></a><h3 id="设置一个对象的属性"><a href="#设置一个对象的属性" class="headerlink" title="设置一个对象的属性"></a>设置一个对象的属性</h3><p>通常，设置一个对象的属性会创建这个对象自身的属性。但如果这个对象继承了<code>getter</code>或<code>setter</code>属性，就会出现例外。</p><p>比如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line">  <span class="keyword">get</span> b() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> c(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = x / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins = <span class="built_in">Object</span>.create(o);</span><br><span class="line"></span><br><span class="line">ins.c = <span class="number">50</span>;<span class="comment">//这行代码并不会给ins设置自己的c属性，而是会沿着原型链找到作为`setter`的c属性，结果是ins中多了一个属性a，属性值为25。</span></span><br></pre></td></tr></table></figure><h3 id="不同方式创建对象以及导致的原型链"><a href="#不同方式创建对象以及导致的原型链" class="headerlink" title="不同方式创建对象以及导致的原型链"></a>不同方式创建对象以及导致的原型链</h3><ol><li><p>使用字面两创建</p><ul><li><code>var o = {a: 1};</code>, 原型链：<code>o ---&gt; Object.prototype ---&gt; null</code>。</li><li><code>var b = [&#39;yo&#39;, &#39;whadup&#39;, &#39;?&#39;];</code>, 原型链： <code>b ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</code>。</li><li><code>function f() {return 2}</code>, 原型链： <code>f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code>。</li></ul></li><li><p>使用构造函数创建</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertices = [];</span><br><span class="line">  <span class="keyword">this</span>.edges = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph.prototype = &#123;</span><br><span class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Object.create</code>创建</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (inherited)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</span><br><span class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// d ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); </span><br><span class="line"><span class="comment">// undefined, because d doesn't inherit from Object.prototype</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>class</code>创建</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</span><br><span class="line">    <span class="keyword">super</span>(sideLength, sideLength);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> sideLength(newLength) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = newLength;</span><br><span class="line">    <span class="keyword">this</span>.width = newLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a><code>hasOwnProperty</code></h3><p>这个属性定义在<code>Object.prototype</code>上，是js中唯一一个处理对象属性且不会贯穿原型链的处理方法。</p><h3 id="扩展原型链的方法比较"><a href="#扩展原型链的方法比较" class="headerlink" title="扩展原型链的方法比较"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#Summary_of_methods_for_extending_the_protoype_chain" target="_blank" rel="noopener">扩展原型链的方法比较</a></h3><p>MDN上推荐使用下面两种方法进行原型链的扩展。不推荐使用<code>Object.setPrototypeOf</code>以及<code>__proto__</code>。</p><p>另外感觉<code>class</code>也是一种实现扩展原型链的方法，感觉这里落下了。</p><ol><li>传统的方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: <span class="string">'foo val'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="keyword">new</span> foo;</span><br><span class="line">proto.bar_prop = <span class="string">'bar val'</span>;</span><br><span class="line">bar.prototype = proto;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> bar;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>Object.create</code></li></ol><p>下面的例子显示，<code>Object.create</code>可以传入第二个参数，表示添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: <span class="string">'foo val'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(foo.prototype);</span><br><span class="line">proto.bar_prop = <span class="string">'bar val'</span>;</span><br><span class="line">bar.prototype = proto;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> bar;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: <span class="string">'foo val'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(</span><br><span class="line">  foo.prototype,</span><br><span class="line">  &#123;</span><br><span class="line">    bar_prop: &#123;</span><br><span class="line">      value: <span class="string">'bar val'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">bar.prototype = proto;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> bar;</span><br></pre></td></tr></table></figure><h3 id="prototype和Object-getPrototypeOf"><a href="#prototype和Object-getPrototypeOf" class="headerlink" title="prototype和Object.getPrototypeOf"></a><code>prototype</code>和<code>Object.getPrototypeOf</code></h3><p>当你调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>时，javascript实际执行的是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.[[Prototype]] = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十九 ——《闭包》</title>
      <link href="/2018/08/14/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B9%9D-%E9%97%AD%E5%8C%85/"/>
      <url>/2018/08/14/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B9%9D-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">链接地址</a></p><h3 id="关于lexical的解释"><a href="#关于lexical的解释" class="headerlink" title="关于lexical的解释"></a>关于<code>lexical</code>的解释</h3><blockquote><p>The word “lexical” refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.</p></blockquote><a id="more"></a><h3 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h3><blockquote><p>A closure is the combination of a function andn the lexical environment within which that function was declared.</p></blockquote><p><strong>闭包具有封装和隐藏数据的优点。</strong></p><p>比如下面这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p><code>add5</code>和<code>add10</code>都是闭包，它们共享相同的函数体定义，但是存储了不同的词法环境。在<code>add5</code>的词法环境中，<code>x</code>是5；在<code>add10</code>的词法环境中，<code>x</code>是10。</p><p>再比如下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;   </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 0</span></span><br><span class="line">counter.increment();</span><br><span class="line">counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 2</span></span><br><span class="line">counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 1</span></span><br></pre></td></tr></table></figure><p>在前面的例子中，每一个闭包都有它自己的词法环境。然而，这里我们创建了一个单一的词法环境，这个环境被三个函数共享。这个共享的词法环境是在一个匿名函数的函数体中创建的，这个匿名函数创建完就执行了。这个词法环境包含两个私有条目：一个叫做<code>privateCounter</code>的变量以及一个叫做<code>changeBy</code>的函数。这两个私有条目都不可以从匿名函数外访问到。相反，它们只能被匿名函数返回的三个公共函数访问。</p><h3 id="一个常见的闭包错误"><a href="#一个常见的闭包错误" class="headerlink" title="一个常见的闭包错误"></a>一个常见的闭包错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"help"</span>&gt;Helpful notes will appear here&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;E-mail: &lt;input type="text" id="email" name="email"&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;Name: &lt;input type="text" id="name" name="name"&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Age: &lt;input type="text" id="age" name="age"&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>原因：传给<code>onfocus</code>的函数是闭包。循环创建了这三个闭包，但这三个共享了相同的唯一的词法环境,这个此法环境有一个改变中的变量<code>item.help</code>。<strong>当<code>onfocus</code>的回调函数执行的时候，<code>item.help</code>的值才会确定。(只有函数执行的时候才会上溯搜寻参数)</strong>而此时，循环已经结束，被三个闭包共享的变量对象<code>item</code>指向<code>helpText</code>数组的最后一项。</p><p>解决的关键是让这<strong>三个闭包不共享相同的词法环境</strong>。</p><ol><li>方法1</li></ol><p>在循环词法环境和比包之间创建一个过渡的嵌套环境，立即执行保存了正确的参数，同时也给闭包创建了不同于其他两个比包的词法环境。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelpCallback</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showHelp(help);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = makeHelpCallback(item.help);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ol start="2"><li>方法2</li></ol><p>使用匿名闭包，和上面的方法本质相同，这种方法是把循环的整个过程通过匿名立即执行函数保存成一个区别于其它两个的词法环境。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">       <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); <span class="comment">// Immediate event listener attachment with the current value of item (preserved until iteration).</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ol start="3"><li>方法3</li></ol><p>使用<code>let</code>，每个闭包绑定了块作用域的变量，这就不再需要闭包创建独立的词法环境了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ol start="4"><li>方法4</li></ol><p>使用<code>forEach</code>替代<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">  </span><br><span class="line">  helpText.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(text.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(text.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十八 ——《相等判断》</title>
      <link href="/2018/08/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AB-%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD/"/>
      <url>/2018/08/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AB-%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">链接地址</a></p><h3 id="loose-equality"><a href="#loose-equality" class="headerlink" title="loose equality"></a>loose equality</h3><p><img src="/images/js/7.png" alt="==转换"></p><ol><li><code>Number</code>，<code>String</code>，<code>Boolean</code>类型在和<code>Number</code>，<code>String</code>，<code>Boolean</code>类型比较的时候，如果两个不是相同类型，会将两个比较的值都转成数字后再进行比较。转换时，相当于使用<code>+</code>。</li></ol><a id="more"></a><ol start="2"><li><p><code>Number</code>，<code>String</code>，<code>Boolean</code>类型在和<code>Object</code>类型比较的时候，会把<code>Object</code>类型转换成基础类型。转换过程会调用<code>A.toString</code>和<code>A.valueOf</code>这两个方法，不同类型进行转换时，这两个方法调用的顺序不同。转换顺序详见<a href="http://ecma-international.org/ecma-262/5.1/#sec-8.12.8" target="_blank" rel="noopener">规范</a>。</p><p> <em>此处要加上几个关于对象转换成基本值的示例，一步步按转换步骤写。暂时没有找到…明天看下犀牛书的说明好了。</em></p><p> 犀牛书原文：</p><blockquote><p>“+”和“=”应用的对象到原始值的转换包含日期对象的一种特殊情形。日期类是js语言核心中唯一的预先定义类型，它定义了有意义的向字符串和数字类型的转换。对于所有非日期的对象来说，<strong>对象到原始值的转换基本上是对象到数字的转换</strong><code>（首先调用valueof()）</code>，日期对象则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的并不完全一致：通过valueOf或toString返回的原始值将被直接使用，而不会被强制转换为数字或字符串。</p></blockquote><blockquote><p>对象转换为数字的细节解释了为什么空数组会被转换为数字0以及为什么具有单个元素的数组同样会被转换成一个数字。数组集成了默认的valueOf方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换成为空字符串，空字符串转为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换为数字。</p></blockquote></li></ol><h3 id="同值相等判断"><a href="#同值相等判断" class="headerlink" title="同值相等判断"></a>同值相等判断</h3><p><code>Object.is()</code>除下面的特殊情况外，基本类似<code>===</code>的比较结果。</p><p><strong>通常要避免使用这个函数，比较NaN时，可以使用isNaN函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="严格相等比较算法"><a href="#严格相等比较算法" class="headerlink" title="严格相等比较算法"></a><a href="http://ecma-international.org/ecma-262/5.1/#sec-11.9.6" target="_blank" rel="noopener">严格相等比较算法</a></h3><p>The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:</p><ol><li>If Type(x) is different from Type(y), return false.</li><li>If Type(x) is Undefined, return true.</li><li>If Type(x) is Null, return true.</li><li>If Type(x) is Number, then<ol><li>If x is NaN, return false.</li><li>If y is NaN, return false.</li><li>If x is the same Number value as y, return true.</li><li>If x is +0 and y is −0, return true.</li><li>If x is −0 and y is +0, return true.</li><li>Return false.</li></ol></li><li>If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return false.</li><li>If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false.</li><li>Return true if x and y refer to the same object. Otherwise, return false.</li></ol><h3 id="绝对相等比较算法"><a href="#绝对相等比较算法" class="headerlink" title="绝对相等比较算法"></a><a href="http://ecma-international.org/ecma-262/5.1/#sec-11.9.3" target="_blank" rel="noopener">绝对相等比较算法</a></h3><p>共10个steps，详见链接。下面是一些注意：</p><ol><li><p>Given the above definition of equality:</p><ul><li>String comparison can be forced by: “” + a == “” + b.</li><li>Numeric comparison can be forced by: +a == +b.</li><li>Boolean comparison can be forced by: !a == !b.</li></ul></li><li><p>The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other. For Example:</p><ul><li>new String(“a”) == “a” and “a” == new String(“a”)are both true.</li><li>new String(“a”) == new String(“a”) is false.</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十七 ——《null&amp;undefined》</title>
      <link href="/2018/08/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%83-null&amp;undefined/"/>
      <url>/2018/08/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%83-null&amp;undefined/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">链接地址(评论区RedNax的评论)</a></p><p>感觉这段评论将<code>undefined</code>和<code>null</code>的不同说的很清楚，而且也说明白了应该在什么地方使用。</p><p>react的源码<code>ReactElement.js</code>中的<code>createElement</code>函数中就有如下定义：</p><p>如此看来这样的定义才是合理的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> source = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><ol><li><p>null 和 undefined在现代JS语义里面是有明确区别的：</p><p> null 表示一个值被定义了，定义为“空值”；</p><p> undefined 表示根本不存在定义。</p><p> 所以设置一个值为 null 是合理的，如objA.valueA = null;但设置一个值为 undefined 是不合理的，如objA.valueA = undefined; // 应该直接使用 delete objA.valueA; 任何一个存在引用的变量值为undefined都是一件错误的事情。</p><p> 这样判断一个值是否存在，就可以用objA.valueA === undefined // 不应使用 null 因为 undefined == null，而 null 表示该值定义为空值。</p><p> 这个语义在JSON规范中被强化，这个标准中不存在 undefined 这个类型，但存在表示空值的 null 。在一些使用广泛的库（比如jQuery）中的深度拷贝函数会忽略 undefined 而不会忽略 null ，也是针对这个语义的理解。</p></li></ol><ol start="2"><li><p>JS 中同时存在 undefined 和 null 是合理的。</p><p> 首先在 Java 中不存在 undefined 是很合理的：Java 是一个静态类型语言，对于 Java 来说不可能存在一个“不存在”的成员（不存在的话直接就编译失败了），所以只用 null 来表示语义上的空值。而 JavaScript 是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），所以这就要一个值来表示对某成员的 getter 是取不到值的。</p></li></ol><ol start="3"><li><p>typeof null 结果是 ”object“ 更像是一个设计失误</p><p> 因为 typeof null === “object” 而认为 null 语义是表示空对象是个不谨慎的猜测，感觉像是先射箭后画靶一般。简单的反例：在强类型数据交换协议 odata（<a href="http://www.odata.org/）的" target="_blank" rel="noopener">http://www.odata.org/）的</a> JSON 格式中，即使一个成员定义为特定类型（比如string），也可以设置其值为 null 来表示这个值是空值，这可不是表示这个成员是空对象，只是说值为空而已（和空字符串、0、false有所区别）。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十六 ——《客户端内存》</title>
      <link href="/2018/07/30/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AD-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%85%E5%AD%98/"/>
      <url>/2018/07/30/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AD-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data" target="_blank" rel="noopener">链接地址</a></p><p>客户端存储由js的api构成，这些api允许你在客户端存储数据，当需要的时候再获取它们，比如：</p><ol><li><p>个性化站点</p></li><li><p>保存先前站点的活动状态，比如从先前的session中存储购物车中的内容，或者记住用户先前是否已经登录</p></li><li><p>保存数据或是assets到本地，以便离线使用或者同样的网站再次加载能以更快的速度</p></li><li><p>保存网页应用生成的文件到本地以便离线使用</p></li></ol><p>客户端存储在现代浏览器中可以取代cookie诶。</p><a id="more"></a><ol><li><p>web storage</p><p>用来存储简单的小型数据。web storage包含两种结构，一种是sessionStorage，一种是localStorage。</p><ul><li><p>sessionStorage：数据存在的时长是浏览器打开的这段时期，关闭浏览器则数据丢失；</p></li><li><p>localStorage：使用这种类型保存数据，即使浏览器关闭再打开数据也依然存在。<strong>localStorage是按domain分隔的！！！</strong></p><ol><li><p>存储数据：<code>localStorage.setItem(&#39;name&#39;, &#39;bobo&#39;)</code></p></li><li><p>拿到数据：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = localStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line">myName</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><pre><code>3. 移除数据：`localStorage.removeItem(&apos;name&apos;);`</code></pre><ol start="2"><li><p>Indexed DB</p><p>用来存储复杂的大型数据。</p><p>一个简单的使用案例：</p><ol><li><p>创建一个变量用来存储数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db；</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>创建IDB是异步的操作，所以一般写在<code>window.onload</code>的回调函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>创建名叫<code>notes</code>的第<code>1</code>个版本的数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">'notes'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handle创建结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">'notes'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Database failed to open'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Database opened successfully'</span>);</span><br><span class="line"></span><br><span class="line">    db = request.result;</span><br><span class="line"></span><br><span class="line">    displayData();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>DB说IDB暂且用不到，搁置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十五 ——《从服务器获取数据》</title>
      <link href="/2018/07/27/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%94-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/07/27/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%94-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>XMLHttpRequest</p><p> 使用步骤</p><ol><li><p>使用<code>XMLHttpRequest()</code>构造函数创建一个新的请求对象</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></li></ol></li></ol><a id="more"></a><pre><code>2. 使用`open()`方法指定用于从网络请求资源的**方法**以及**url**    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br></pre></td></tr></table></figure>3. 设置响应类型（XHR默认返回文本）    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.responseType = <span class="string">'text'</span>;</span><br></pre></td></tr></table></figure>4. XHR使用`onload`事件处理来处理响应    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    poemDisplay.textContent = request.response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>5. 发出请求    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.send()</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>fetch</p><ol><li><p>速览<br> 使用fetch替换上面的XHR的代码：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        poemDisplay.textContent = text;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> fetch返回一个<code>promise</code>对象！在fetch后面的<code>then（）</code>函数将解析从服务器返回的响应。</p><p> 当fetch（）的promise解析时，这个函数会自动将响应从服务器传递给参数。在函数内部，我们获取响应并运行其<code>text()</code>方法。这将响应作为原始文本返回。<code>text()</code>返回一个promise对象，所以我们连接另外一个<code>.then()</code>在她上面，在其中我们定义了一个函数来接收text()promise解析的生文本。</p><p> 当使用链式写法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> response.text()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">poemDisplay.textContent = text;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 注意上面前一个then函数的回调函数中有一个<code>return</code>。</p></li><li><p>使用fetch</p><ol><li><p>注意事项</p><ol><li><p>当接收到一个代表错误的http请求状态码时，从<code>fetch()</code>返回的promise<strong>不会被标记为reject</strong>，即使该http响应的状态码是404或500。相反，它会将promise状态标记为resolve（但是会将resolve的返回值ok属性设置为false），仅当网络故障时或请求被阻止时，才会标记为reject。</p></li><li><p>默认情况下，fetch不会从服务端发送或接收任何cookies，如果站点依赖于用户的session，则会导致未经认证的请求（要发送cookies，必须设置<code>credentials</code>选项）。</p></li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十三 ——《元编程》</title>
      <link href="/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-%E5%85%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-%E5%85%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming" target="_blank" rel="noopener">链接地址</a></p><a id="more"></a><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理对象</a></p><p> <code>let p = new Proxy(target, handler);</code></p><ul><li><p>target表示用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></li><li><p>handler表示一个对象，其属性是当执行一个操作时定义代理的行为的函数。（handler的属性键都是对象的原生函数？感觉是哦）</p></li></ul><ol><li><p>使用<code>get</code>关键字，当对象中不存在属性名时，返回缺省值</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">37</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  p = <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b); <span class="comment">// 1, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></span><br></pre></td></tr></table></figure></li><li><p>无操作转发代理</p><p> 使用一个原生的js对象，代理会将所有应用到它的操作转发到这个对象上。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">37</span>; <span class="comment">// 操作转发到目标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.a);  <span class="comment">// 37  操作已经被正确转发</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>3. 验证    通过代理验证向一个对象传的值，这个例子使用`set`。    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="string">'young'</span>; <span class="comment">// Uncaught TypeError: The age is not an integer</span></span><br><span class="line"></span><br><span class="line">page.age = <span class="number">300</span>; <span class="comment">// Uncaught RangeError: The age seems invalid</span></span><br></pre></td></tr></table></figure>4. 撤销proxy    Proxy.revocable()方法被用来创建可撤销的Proxy对象。这意味着代理可以通过revoke函数来撤销并且关闭代理。此后，代理上的任意的操作都会导致TypeError。    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> revocable = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"[["</span> + name + <span class="string">"]]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> proxy = revocable.proxy;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// "[[foo]]"</span></span><br><span class="line"></span><br><span class="line">revocable.revoke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// TypeError is thrown</span></span><br><span class="line">proxy.foo = <span class="number">1</span>           <span class="comment">// TypeError again</span></span><br><span class="line"><span class="keyword">delete</span> proxy.foo;       <span class="comment">// still TypeError</span></span><br><span class="line"><span class="keyword">typeof</span> proxy            <span class="comment">// "object", typeof doesn't trigger any trap</span></span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>反射</p><p> 这个mdn讲的很粗略，日后看下阮老师的<a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener">书</a>。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十四 ——《客户端web api》</title>
      <link href="/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-%E5%AE%A2%E6%88%B7%E7%AB%AFweb_api/"/>
      <url>/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-%E5%AE%A2%E6%88%B7%E7%AB%AFweb_api/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>javascript api的共同点</p><ol><li><p>基于对象</p></li><li><p>有可识别的入口点</p></li><li><p>它们使用事件来处理状态的变化</p></li><li><p>它们在适当的地方有额外的安全机制</p></li></ol></li></ol><a id="more"></a><ol start="2"><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents" target="_blank" rel="noopener">操作文档</a></p><ol><li><p>document.querySelector(selectors)</p><ol><li><p>文档对象模型Document引用的querySelector()方法返回文档中与指定选择器或选择器组匹配的第一个 html元素Element。 如果找不到匹配项，则返回null。</p></li><li><p>selectors:包含一个或多个要匹配的选择器的 DOM字符串DOMString。 该字符串必须是有效的CSS选择器字符串</p></li><li><p><strong>使用深度优先的遍历顺序</strong></p></li><li><p>返回Element对象</p></li></ol></li><li><p>document.querySelectorAll(selectors)</p><ol><li><p><strong>使用深度优先的遍历顺序</strong></p></li><li><p>selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串</p></li><li><p>返回一个<strong>静态的</strong> NodeList 类型的对象</p></li></ol></li><li><p>document.createElement();</p><p> <code>var para = document.createElement(&#39;p&#39;);</code></p></li><li><p>Node.appendChild()</p><p> <code>sect.appendChild(para);</code></p></li><li><p>Document.createTextNode()</p><p> 创建一个文本节点</p></li><li><p>node.textContent</p></li><li><p>node.innerText</p></li><li><p>node.innerHTML</p><p> 返回文本内容和标签</p></li><li><p>Node.removeChild()</p><p> 当知道要删除节点以及父节点的时候可以使用这个方法：</p><p> <code>sect.removeChild(linkPara);</code></p></li><li><p>删除一个仅基于自身引用的节点</p><p><code>linkPara.parentNode.removeChild(linkPara);</code></p></li><li><p>Node.cloneNode(deep)</p><ol><li><p>deep: 如果为true，表示执行深复制，当前节点的所有子节点也会一并复制</p></li><li><p>如果deep参数设为false,则不克隆它的任何子节点.该节点所包含的所有文本也不会被克隆,因为文本本身也是一个或多个的Text节点</p></li><li><p>这个函数复制的节点信息包括：克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=”alert(1)”),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件</p></li></ol></li><li><p>HTMLElement.style</p><ol><li>使用这个属性的结果是样式都是<strong>内联样式</strong>。</li></ol></li><li><p>Element.setAttribute()</p><ol><li>使用这个方法设置的样式是普通的css样式表的样式：<code>Element.setAttribute(class, className)</code>。</li></ol></li><li><p>获取视窗尺寸</p><p><code>window.innerWidth</code>：视窗宽度</p><p><code>window.innerHeight</code>:视窗高度</p></li><li><p>视窗的resize事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    WIDTH = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">    HEIGHT = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    div.style.width = WIDTH + <span class="string">'px'</span>;</span><br><span class="line">    div.style.height = HEIGHT + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>给DOM添加节点需要上述1、2、3、4、5五个方法;</p><p>  下面这个例子里添加文本使用的是Node.textContent属性。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sect = <span class="built_in">document</span>.querySelector(<span class="string">'section'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">para.textContent = <span class="string">'We hope you enjoyed the ride.'</span>;</span><br><span class="line"></span><br><span class="line">sect.appendChild(para);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">' — the premier source for web development knowledge.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> linkPara = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line">linkPara.appendChild(text);</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十二 ——《迭代器和生成器》</title>
      <link href="/2018/07/24/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2018/07/24/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>迭代器</p><p> 迭代器是一个<strong>对象</strong>，知道如何每次访问集合中的一项，并跟踪该序列中的当前位置。它提供一个<code>next()</code>方法，用来返回序列中的下一项。这个方法返回包含两个属性：<code>done</code>和<code>value</code>。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">          &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">          &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next().value); <span class="comment">// 'yo'</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value); <span class="comment">// 'ya'</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().done); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>生成器</p><p> 迭代器需要显式地维护其内部状态，<strong>生成器</strong>允许自定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = idMaker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>可迭代对象</p><p> 为了实现可迭代，一个对象必须实现<code>@@iterator</code>方法，就是说这个对象或其原型链中的一个对象必须具有带<code>Symbol.iterator</code>键的属性。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">    myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    [...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 高级生成器</span><br><span class="line"></span><br><span class="line">    The next() 方法也接受可用于修改生成器内部状态的值。传递给next()的值将被视为暂停生成器的最后一个<span class="keyword">yield</span>表达式的结果。</span><br><span class="line"></span><br><span class="line">    <span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">    使用 next(x) 重新启动 fibonacci 序列生成器：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function* fibonacci() &#123;</span></span><br><span class="line"><span class="string">      var fn1 = 0;</span></span><br><span class="line"><span class="string">      var fn2 = 1;</span></span><br><span class="line"><span class="string">      while(true) &#123;</span></span><br><span class="line"><span class="string">        var current = fn1;</span></span><br><span class="line"><span class="string">        fn1 = fn2;</span></span><br><span class="line"><span class="string">        fn2 = current + fn1;</span></span><br><span class="line"><span class="string">        var reset = yield current;</span></span><br><span class="line"><span class="string">        if (reset) &#123;</span></span><br><span class="line"><span class="string">          fn1 = 0;</span></span><br><span class="line"><span class="string">          fn2 = 1;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var sequence = fibonacci();</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 0</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 2</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 3</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 5</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 8</span></span><br><span class="line"><span class="string">    console.log(sequence.next(true).value); // 0</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 2</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十一 ——《对象模型的细节》</title>
      <link href="/2018/07/23/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2018/07/23/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="noopener">链接地址</a></p><ol><li>JavaScript 是一种基于原型而不是基于类的面向对象语言。</li></ol><a id="more"></a><ol start="2"><li><p>对象模型使用（创建Employee层级结构）</p><p> Employee的层级结构见下图：</p><p> <img src="/images/js/6.png" alt="employee层级结构"></p><ol><li><p>创建Employee的构造函数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">"general"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Manager和WorkerBee</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Manager</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Employee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.reports = [];<span class="comment">//增加了reports属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Manager.prototype = <span class="built_in">Object</span>.create(Employee.prototype);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkerBee</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Employee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.projects = []<span class="comment">//增加了projects属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerBee.prototype = <span class="built_in">Object</span>.create(Employee.prototype);</span><br></pre></td></tr></table></figure></li><li><p>创建SalesPerson和Engineer</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SalesPerson</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  WorkerBee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'sales'</span>;<span class="comment">//给这个属性重新赋值</span></span><br><span class="line">  <span class="keyword">this</span>.quota = <span class="number">100</span>;<span class="comment">//增加quota属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SalesPerson.prototype = <span class="built_in">Object</span>.create(WorkerBee.prototype);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  WorkerBee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'engineering'</span>;<span class="comment">//给这个属性重新赋值</span></span><br><span class="line">  <span class="keyword">this</span>.machine = <span class="string">''</span>;<span class="comment">//增加了machine属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engineer.prototype = <span class="built_in">Object</span>.create(WorkerBee.prototype);</span><br></pre></td></tr></table></figure></li><li><p>利用构造函数创建对象</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mark = <span class="keyword">new</span> WorkerBee;</span><br></pre></td></tr></table></figure><p> 上面的代码经历了下面的创建过程：</p><blockquote><p>当javascript发现<code>new</code>操作符时，它会创建一个<strong>通用对象</strong>,并将其作为关键字<code>this</code>的值传递给<code>WorkerBee</code>的构造函数。该构造函数显式地设置projects属性的值，然后隐式地将其内部的<code>[[Prototype]]</code>属性设置为<code>WorkerBee.prototype</code>的值。内置的<code>[[Prototype]]</code>属性决定了用于返回属性值的原型链。一旦这些属性设置完成，javascript返回新创建的对象，然后赋值语句会将变量mark的值指向该对象。</p></blockquote><blockquote><p>这个过程不会显式的将 mark所继承的原型链中的属性值作为本地变量存放在 mark 对象中。当请求属性的值时，JavaScript 将首先检查对象自身中是否存在属性的值，如果有，则返回该值。如果不存在，JavaScript会检查原型链（使用内置的 [[Prototype]] 属性）。如果原型链中的某个对象包含该属性的值，则返回这个值。如果没有找到该属性，JavaScript 则认为对象中不存在该属性。</p></blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mark.name = <span class="string">""</span>;</span><br><span class="line">mark.dept = <span class="string">"general"</span>;</span><br><span class="line">mark.projects = [];</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>    &gt;mark 对象从`mark.__proto__`中保存的原型对象中继承了`name`和`dept`属性的值。并由`WorkerBee`构造器函数为`projects`属性设置了本地值。 这就是`JavaScript`中的属性和属性值的继承。    使用`Object.hasOwnProperty`检验上面三个属性，返回`true`，可见不论是构造函数显式设置的属性还是通过原型链隐式传回的属性，这些属性都是对象自身的属性，如果此时修改这些属性，只是针对这个对象，不会影响原型，不会影响相同原型的其他对象。5. 对象模型的另一种使用    1. 创建可以传参数的构造函数     <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, dept</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept= dept || <span class="string">'general'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    2. 在下一层构造函数中调用上层构造函数    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkerBee</span>(<span class="params">name, dept, projs</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = Employee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, dept);</span><br><span class="line">  <span class="keyword">this</span>.projects = projs || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerBee.prototype = <span class="keyword">new</span> Employee;</span><br></pre></td></tr></table></figure>    注意上面的代码！先将`Employee`赋值给`this.base`，然后再通过`this.base`调用，这时，Employee内部的`this`指向`this.base`中的`this`也就是使用`new`关键字创建的对象。    3. 使用`new`调用构造函数创建对象    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mark = <span class="keyword">new</span> WorkerBee(<span class="string">"smith, mark"</span>, <span class="string">'training'</span>, [<span class="string">'javascript'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span> (<span class="params">name, projs, mach</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = WorkerBee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, <span class="string">"engineering"</span>, projs);</span><br><span class="line">  <span class="keyword">this</span>.machine = mach || <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engineer.prototype = <span class="keyword">new</span> WorkerBee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Engineer(<span class="string">"Doe, Jane"</span>, [<span class="string">"navigator"</span>, <span class="string">"javascript"</span>], <span class="string">"belau"</span>);</span><br></pre></td></tr></table></figure>    javascript会按以下步骤执行:    1. new 操作符创建了一个新的通用对象，并将其 __proto__ 属性设置为 Engineer.prototype。    2. new 操作符将该新对象作为 this 的值传递给 Engineer 构造器。    3. 构造器为该新对象创建了一个名为 base 的新属性，并指向 WorkerBee 的构造器。这使得 WorkerBee 构造器成为 Engineer 对象的一个方法。    4. 构造器调用`base`方法，将传给该构造器的参数中的两个，作为参数传递给base方法，同事还传递一个字符串参数`engineering`。显式地在构造器中使用`engineering`表明所有Engineer对象继承的`dept`属性具有相同的值，且该值重载了继承自`Employee`的值。    5. 因为`base`是`Engineer`的一个方法，在调用`base`时，javascrit将在步骤1中创建的对象绑定给`this`关键字。这样，`WorkerBee`函数接着将`Doe， Jane`和`engineering`参数传递给`Employee`构造器函数。当从`Employee`构造器函数返回时，`WorkerBee`函数用剩下的参数设置`projects`属性。    6. 当从`base`方法返回后，`Engineer`构造器将对象的`machine`属性初始化为`belau`    7. 当从构造器返回时，javascript将新对象赋值给`jane`变量。    **重要说明：**    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span> (<span class="params">name, projs, mach</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = WorkerBee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, <span class="string">"engineering"</span>, projs);</span><br><span class="line">  <span class="keyword">this</span>.machine = mach || <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Engineer(<span class="string">"Doe, Jane"</span>, [<span class="string">"navigator"</span>, <span class="string">"javascript"</span>], <span class="string">"belau"</span>);</span><br><span class="line">Employee.prototype.specialty = <span class="string">"none"</span>;</span><br></pre></td></tr></table></figure>    如果代码写成上面这样，对象jane不会继承speciality属性。必须显式地设置原型才能确保动态的继承，也就是添加下面这行代码：    `Engineer.prototype = new WorkerBee;`    此刻，对象jane就可以动态的继承speciality属性了。</code></pre><ol start="3"><li><p>instance操作符</p><p> instanceof 操作符可以用来将一个对象和一个函数做检测，如果对象继承自函数的原型，则该操作符返回真。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http查漏补缺之二 《cookie》</title>
      <link href="/2018/07/21/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-cookie/"/>
      <url>/2018/07/21/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-cookie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">mdn地址</a></p><ol><li><p>set-cookie响应头部</p><p> 服务器使用Set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。</p><p> 写法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>cookie请求头部</p><p> 现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过Cookie请求头部再发送给服务器。</p></li><li><p>会话期cookie</p><p> 会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。</p></li><li><p>持久性cookie</p><p> 和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p><p> <strong>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</strong></p></li><li><p>secure标记</p><p> cookie只能通过https协议发送。</p></li><li><p>httpOnly标记</p><p> cookie无法被<code>document.cookie</code>获取，只能发送给服务端，可以避免跨域脚本攻击（XSS）。</p></li><li><p>Cookie的作用域</p><p> domain和path这两个标识符定义了Cookie的作用域。</p><p> Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。</p><blockquote><p>例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。</p></blockquote><p> Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。</p><blockquote><p>例如，设置 Path=/docs，则以下地址都会匹配：<br> /docs<br> /docs/Web/<br> /docs/Web/HTTP</p></blockquote></li><li><p>第三方cookie</p><p> 如果Cookie的域和页面的域不同，则称之为第三方Cookie；</p><p> 如果Cookie的域和页面的域相同，那么我们称这个Cookie为第一方Cookie。</p></li><li><p>涉及cookie的安全问题</p><ol><li><p>xss（跨站攻击）</p><p> 在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行XSS攻击。</p></li><li><p>csrf（跨站请求伪造）</p><p> 比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求。当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十——《使用对象》</title>
      <link href="/2018/07/18/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/07/18/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>JavaScript中的对象只能使用String类型作为键类型。</p></li><li><p>对对象的枚举</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function showProps(obj, objName) &#123;</span><br><span class="line">  var result = &quot;&quot;;</span><br><span class="line">  for (var i in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">        result += objName + &quot;.&quot; + i + &quot; = &quot; + obj[i] + &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面的列子使用了<code>for in</code> 和 <code>hasOwnProperty</code>，自己几乎没有这样写过代码，都是先用<code>Object.keys</code>获取所有的键，然后循环键组成的数组进行操作。下次可以试一波。</p></li></ol><a id="more"></a><ol start="3"><li><p>枚举一个对象属性的三种方法</p><ol><li><p><code>for in</code>依次访问一个对象及其原型链中所有可枚举的属性。</p></li><li><p><code>Object.keys(o)</code>返回一个对象 o 自身包含（不包括原型中）的所有属性的名称的数组。</p></li><li><p><code>Object.getOwnPropertyNames(o)</code>该方法返回一个数组，它包含了对象 o 所有拥有的属性（无论是否可枚举）的名称。<strong>注意！不论可否枚举！！！不论可否枚举！！！不论可否枚举！！！</strong></p></li></ol></li><li><p>创建对象的方法</p><ol><li><p>使用对象字面两</p></li><li><p>使用构造函数</p></li><li><p>使用 Object.create 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Animal properties and method encapsulation</span><br><span class="line">var Animal = &#123;</span><br><span class="line">  type: &quot;Invertebrates&quot;, // Default value of properties</span><br><span class="line">  displayType : function() &#123;  // Method which will display type of Animal</span><br><span class="line">    console.log(this.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create new animal type called animal1 </span><br><span class="line">var animal1 = Object.create(Animal);</span><br><span class="line">animal1.displayType(); // Output:Invertebrates</span><br><span class="line"></span><br><span class="line">// Create new animal type called Fishes</span><br><span class="line">var fish = Object.create(Animal);</span><br><span class="line">fish.type = &quot;Fishes&quot;;</span><br><span class="line">fish.displayType(); // Output:Fishes</span><br></pre></td></tr></table></figure></li></ol></li><li><p>getters与setters</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 7,</span><br><span class="line">  get b() &#123; </span><br><span class="line">    return this.a + 1;</span><br><span class="line">  &#125;,</span><br><span class="line">  set c(x) &#123;</span><br><span class="line">    this.a = x / 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.a); // 7</span><br><span class="line">console.log(o.b); // 8</span><br><span class="line">o.c = 50;</span><br><span class="line">console.log(o.a); // 25</span><br></pre></td></tr></table></figure></li></ol><pre><code>1. 上面定义getters使用了get2. 定义setters使用了set3. 使用getter和setter时的方式和普通对象属性相同</code></pre><ol start="6"><li><p>第二种使用getters和setters的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = Date.prototype;</span><br><span class="line">Object.defineProperty(d, &quot;year&quot;, &#123;</span><br><span class="line">  get: function() &#123; return this.getFullYear() &#125;,</span><br><span class="line">  set: function(y) &#123; this.setFullYear(y) &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>delete操作符</p><p> <strong>注意！</strong><code>delete</code>操作符只能用于删除一个不是继承来的属性。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http查漏补缺之一 《缓存》</title>
      <link href="/2018/07/18/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E7%BC%93%E5%AD%98/"/>
      <url>/2018/07/18/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>下面主要关于代理服务器的缓存。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">mdn地址</a></p><a id="more"></a><ol><li><p>http缓存</p><p> 使用<code>Cache-Control</code>控制缓存，不同值之间使用逗号和空格分割。</p><ol><li><p>强制确认缓存</p><p> <code>Cache-Control: no-cache</code> ：每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。</p><p> <em>MDN的页面请求头中都带有这个消息头，比如这个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">页面</a>。</em></p></li><li><p>缓存过期机制</p><p> <code>Cache-Control: max-age=31536000</code>：max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</p><p> <em>比如这个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">页面</a>的css文件</em></p><p> <img src="/images/http/1.png" alt="缓存过期时间"></p></li><li><p>禁止进行缓存</p><p> <code>Cache-Control: no-store</code></p></li><li><p>缓存验证确认</p><p> <code>Cache-Control: must-revalidate</code></p><p> 如果缓存的响应头信息里含有”Cache-control: must-revalidate”的定义，在浏览的过程中（感觉此处的浏览过程中指的是正常的接到响应）也会触发缓存验证。</p></li></ol></li><li><p>Expires</p><p> Expires响应头包含日期/时间，即在此时间之后，响应过期。</p><p> 如果在<code>Cache-Control</code>相应头设置了 <em>max-age</em> 那么Expires头会被忽略。</p></li><li><p>缓存新鲜度</p><p> 由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。</p><p> 服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。</p><p> 驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个<code>If-None-Match</code>头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 <code>304 (Not Modified)</code>（该响应不会有带有实体信息），<strong>则表示此资源副本是新鲜的</strong>，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。</p><p> 见下图描述：</p><p> <img src="/images/http/HTTPStaleness.png" alt="缓存新鲜度"></p></li><li><p>计算缓存寿命</p><ol><li><p>当有比如<code>Cache-control: max-age=N的请求头</code>这种的特定头，相应的缓存的寿命就是N。</p></li><li><p>如果没有 <code>Cache-control</code>请求头，会去查看是否包含<code>Expires</code>属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。<code>Expires</code>表示一个日期时间，如果<code>Date</code>表示的日期和时间大于<code>Expires</code>则表示缓存已经过期。</p></li><li><p>如果既没有<code>Cache-control</code>， 也没有<code>Expires</code>，就会查找头里的<code>Last-Modified</code>信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10。Date表示消息生成的日期和时间。</p><p><img src="/images/http/2.png" alt="第三种计算缓存时间的方法"></p></li></ol></li><li><p>ff和chrome查看缓存的方法</p><ul><li><p>Firefox: Navigate to about:cache.</p></li><li><p>Chrome: Navigate to chrome://cache.</p></li></ul></li><li><p>计算过期时间</p><p> MDN上给出的计算公式如下：</p><blockquote><p>expirationTime = responseTime + freshnessLifetime - currentAge</p></blockquote><p> 其中，</p><ul><li><p>responseTime：表示浏览器接收到此响应的那个时间点。（感觉这项应该是在浏览器的某处找到）</p></li><li><p>freshnessLifetime： 表示缓存的寿命。</p></li><li><p>currentAge： 感觉对应响应头中的age，表示消息对象在缓存代理服务器中存贮的时长</p><p>这样 <em>寿命</em> - <em>已经存在的时间</em> + <em>最近一次到达浏览器的时间</em> 就得到未来缓存过期的时间。</p></li></ul></li><li><p>资源加速</p><p> 下面这个要问一下。</p><blockquote><p>更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。</p></blockquote><blockquote><p>web开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术[1] 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。</p></blockquote><blockquote><p>这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。</p></blockquote><blockquote><p>加在加速文件后面的版本号不一定是一个正式的版本号字符串，如1.1.3这样或者其他固定自增的版本数。它可以是任何防止缓存碰撞的标记例如hash或者时间戳。</p></blockquote></li></ol><ol start="8"><li><p>缓存验证</p><p> 缓存验证出发的方法：</p><ol><li><p>用户点击刷新按钮时会开始缓存验证;</p></li><li><p>如果缓存的响应头信息里含有”Cache-control: must-revalidate”的定义，在浏览的过程中也会触发缓存验证。（已在上面做了解释）</p></li><li><p>在浏览器偏好设置里设置Advanced-&gt;Cache为强制验证缓存也能达到相同的效果。</p><p>只要出发了缓存验证在请求中就会带有条件<code>If-None-Match</code>或<code>If-Modified-Since</code>（？），不带条件的请求就会重新获取资源。</p></li></ol></li><li><p>缓存过期后的处理方法</p><p> 当缓存的文档过期后，需要进行<strong>缓存验证</strong>或者<strong>重新获取资源</strong>。</p><ul><li><p>缓存校验</p><p>  触发条件： <strong>只有在服务器返回强校验器或者弱校验器时才会进行验证。</strong></p><ol><li><p>如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。</p></li><li><p>Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。</p><p>结果：<strong>当向服务端发起缓存校验的请求时，服务端会返回 200 ok表示返回正常的结果或者 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。</strong></p></li></ol></li></ul></li><li><p>带Vary头的响应</p><ol><li><p>Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。</p><p> <img src="/images/http/HTTPVary.png" alt="Vary头的使用"></p></li><li><p>使用vary头有利于内容服务的动态多样性。</p><p> 例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。(但这样的话岂不是要写移动和桌面端两份文件，对于前端就是包袱啊！！！不如媒体查询来的方便！！！)</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之九 ——《带键的集合》</title>
      <link href="/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-%E5%B8%A6%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88/"/>
      <url>/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-%E5%B8%A6%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Map"><a href="#1-Map" class="headerlink" title="1.Map"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">1.Map</a></h3><ol><li><p>创建Map</p><ol><li><p>使用<code>set</code>方法添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &apos;content&apos;)</span><br></pre></td></tr></table></figure><p><em>set方法返回的是当前的Map对象，因此可以采用链式写法。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line">  .set(1, &apos;a&apos;)</span><br><span class="line">  .set(2, &apos;b&apos;)</span><br><span class="line">  .set(3, &apos;c&apos;);</span><br></pre></td></tr></table></figure></li></ol></li></ol><a id="more"></a><ol start="2"><li><p>调用构造函数的时候传入一个二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>判断Map结构中是否包含某个键值，使用<code>has</code>方法</p><p><code>map.has(&#39;name&#39;) // true</code></p></li><li><p>获取Map结构某个键对应的值，使用<code>get</code>方法</p><p><code>map.get(&#39;name&#39;) // &quot;张三&quot;</code></p></li><li><p>删除某个键值对，使用<code>delete</code>方法</p><p><code>m.delete(o) // true</code></p></li><li><p>清除所有成员，使用<code>clear</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line">map.set(&apos;foo&apos;, true);</span><br><span class="line">map.set(&apos;bar&apos;, false);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.clear()</span><br><span class="line">map.size // 0</span><br></pre></td></tr></table></figure></li><li><p>对同一个键多次赋值，后面的值将覆盖前面的值。</p></li><li><p>读取一个未知的键返回undefined。</p></li><li><p>只有对同一个对象的引用，Map 结构才将其视为同一个键。<strong>陷阱！大陷阱！！！</strong>墙裂注意下面的代码。原因：<strong>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure></li><li><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p></li><li><p>三个遍历器生成函数</p><ol><li><p>遍历的顺序就是插入的顺序。</p></li><li><p>使用这三个函数返回的是这种形式的结果：<code>MapIterator {&quot;F&quot;, &quot;T&quot;}</code>。这就是传说中的遍历器？！<strong>感觉可以将这个遍历器视为一个数组？下面第11项感觉可以佐证这个猜想。</strong></p></li></ol><p>然后利用这个遍历器的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>for of</code>循环来利用这个遍历器。</p><ol start="3"><li>Map结构的默认遍历器接口就是entries方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  // &quot;F&quot; &quot;no&quot;</span><br><span class="line">  // &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">  // 等同于使用map.entries()</span><br><span class="line">  for (let [key, value] of map) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>Map结构转数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line">// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br></pre></td></tr></table></figure></li><li><p>Map结构的遍历函数<code>forEach</code></p><ol><li>使用方法类似数组的<code>forEach</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>forEach方法还可以接受第二个参数，用来绑定this</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></li><li><p>Map转JSON</p><ol><li>当Map的键为字符串时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strMapToJson(strMap) &#123;</span><br><span class="line">  return JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>当Map的键包含其他类型的值时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function mapToArrayJson(map) &#123;</span><br><span class="line">  return JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure></li></ol><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ol><li><p>WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。<strong>一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</strong></p></li><li><p>WeakMap只有四个方法可用：get()、set()、has()、delete()。没有size属性。</p></li></ol><h3 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#Set" target="_blank" rel="noopener">2. Set</a></h3><p>Set类似于数组，但是成员的值都是唯一的，没有重复的值。</p><ol><li><p>创建Set对象</p><ol><li><p>使用<code>add</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>2. 传入数组或类数组参数  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//传入数组参数</span><br><span class="line">  const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">  [...set]</span><br><span class="line"></span><br><span class="line">//传入类数组参数</span><br><span class="line">  const set = new Set(document.querySelectorAll(&apos;div&apos;));</span><br><span class="line">  set.size // 56</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>数组去重的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure></li><li><p>Set对象判断元素是否相等的算法</p><p> 算法类似<code>===</code>，但是NaN在Set中被认为是等于自身的，这点和<code>===</code>不！一！样！</p></li><li><p>Set对象的属性</p><ul><li>size属性，查看元素个数</li></ul></li><li><p>Set对象的方法</p><ul><li><p>add(value)：添加某个值，返回 Set 结构本身。</p></li><li><p>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</p></li><li><p>has(value)：返回一个布尔值，表示该值是否为Set的成员。</p></li><li><p>clear()：清除所有成员，没有返回值。</p><p>Map对象添加元素使用的是<code>set</code>。</p></li></ul></li><li><p>Set对象转成普通数组对象</p><ol><li><p><code>[...setObject]</code></p></li><li><p><code>Array.from(setObject)</code></p></li></ol></li><li><p>遍历器</p><ul><li><p>keys()</p></li><li><p>values()</p></li><li><p>entries()</p></li></ul><p>生成的遍历器结果可以使用<code>for of</code>来循环遍历进行下一步操作。由于Set对象键名和键值相同，所以<code>keys()</code>和<code>values()</code>的结果相同。</p><p>Set结构的实例默认可遍历，默认遍历器生成函数就是<code>values（）</code>方法，所以可以省略写成：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure></li><li><p>forEach（）</p><p> 和Map结构相同，Set结构的forEach（）函数同样可以接受第二个参数，作为第一个函数参数中的this</p></li><li><p>使用Set实现交集、并集、差集</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// set &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></li><li><p>Set的一个用法</p><p><strong>Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</strong></p></li></ol><h3 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h3><p>WeakSet 的成员只能是对象，而不能是其他类型的值。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>在Map和Set中都出现过iterable结构这个东西，这个要看下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之八——《索引集合类》</title>
      <link href="/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>用来处理DOM集合的一个更高效的土法子</p><p>从来没有这样用过诶。<code>div = divs[i]</code>这个赋值表达式，当i = length时，返回值为false就会停止这个循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var divs = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">for (var i = 0, div; div = divs[i]; i++) &#123;</span><br><span class="line">  /* Process div in some way */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>以下是几个自己没有怎么常用的数组方法</p><ol><li><p><code>join()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myArray = new Array(&quot;Wind&quot;, &quot;Rain&quot;, &quot;Fire&quot;);</span><br><span class="line">var list = myArray.join(&quot; - &quot;); // list is &quot;Wind - Rain - Fire&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>Array.prototype.reverse()</code></p></li></ol></li><li><p><code>map(callback[, thisObject])</code>之类的函数有第二个参数，thisObject 变成回调函数内部的 this 关键字的值。如果没有提供，例如函数在一个显示的对象上下文外被调用时，this 将引用全局对象(window)。 </p></li><li><p>字符串使用数组函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach.call(&apos;a string&apos;, function(chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之七——《正则表达式》</title>
      <link href="/2018/07/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/07/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><ol><li><p><strong>?</strong></p><ol><li><p>单独使用：匹配前面一个表达式0次或者1次。等价于 {0,1}。</p></li><li><p>如果紧跟在任何量词 <code>*、 +、? 或 {}</code> 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。</p></li></ol></li><li><p><code>x(?=y)</code>: 正向肯定查找。</p><blockquote><p>/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p></blockquote></li></ol><a id="more"></a><ol start="3"><li><p><code>x(?!y)</code>: 正向否定查找。</p><blockquote><p>/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</p></blockquote></li><li><p><code>[^xyz]</code>: 方向字符集和。匹配<strong>任何没有包含</strong>在方括号中的字符。</p></li><li><p><code>.</code>: 匹配除换行符之外的任何单个字符。</p></li><li><p><code>\w</code>： 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</p></li></ol><h4 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h4><ol><li><p><code>RegExp.prototype.exec()</code>：这个函数类似<code>String.prototype.match()</code>,但是返回数组的同时还会同时更新正则表达式的属性。</p><ul><li><p>返回的数组和更新的正则表达式的附带属性见下图</p><p>  <img src="/images/js/5.png" alt="exec()返回值"></p></li><li><p>使用<code>exec（）</code>函数的一个方便用法的示例</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myRe = /ab*/g;</span><br><span class="line">var str = &apos;abbcdefabh&apos;;</span><br><span class="line">var myArray;</span><br><span class="line">while ((myArray = myRe.exec(str)) !== null) &#123;</span><br><span class="line">var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;</span><br><span class="line">msg += &apos;Next match starts at &apos; + myRe.lastIndex;</span><br><span class="line">console.log(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <em>注意：</em></p><ol><li><p>不要把正则表达式字面量（或者RegExp构造器）放在 while 条件表达式里（否则每次都会重新设置，会造成while的死循环）;</p></li><li><p>要加g标志（否则不会查找下一个，会造成while的死循环）。</p></li></ol></li></ul></li><li><p><code>RegExp.prototype.test()</code>： 类似<code>String.prototype.search()</code>,只是返回值为布尔值。</p></li><li><p><code>String.prototype.split()</code>: 这个函数是String原型对象上的方法。</p><ul><li><p>不使用捕获组括号</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/\d/);</span><br><span class="line">console.log(splits);</span><br><span class="line">//[ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure></li><li><p>使用捕获组括号</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/(\d)/);</span><br><span class="line">console.log(splits);</span><br><span class="line">//[ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之六——《字符串》</title>
      <link href="/2018/07/09/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/07/09/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide" target="_blank" rel="noopener">译文链接</a></p><a id="more"></a><ol><li><p>String对象方法</p><ol><li><p><code>String.prototype.charAt()</code>：从一个字符串中返回指定的字符。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var anyString = &quot;Brave new world&quot;;</span><br><span class="line"></span><br><span class="line">console.log(&quot;The character at index 0   is &apos;&quot; + anyString.charAt(0)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 1   is &apos;&quot; + anyString.charAt(1)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 2   is &apos;&quot; + anyString.charAt(2)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 3   is &apos;&quot; + anyString.charAt(3)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 4   is &apos;&quot; + anyString.charAt(4)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 999 is &apos;&quot; + anyString.charAt(999) + &quot;&apos;&quot;);</span><br><span class="line"></span><br><span class="line">//输出结果：</span><br><span class="line">The character at index 0 is &apos;B&apos;</span><br><span class="line">The character at index 1 is &apos;r&apos;</span><br><span class="line">The character at index 2 is &apos;a&apos;</span><br><span class="line">The character at index 3 is &apos;v&apos;</span><br><span class="line">The character at index 4 is &apos;e&apos;</span><br><span class="line">The character at index 999 is &apos;&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.charCodeAt(index)</code>: 能正确返回一个两个字节组成的字符的码点值。</p></li><li><p><code>String.prototype.pointCodeAt(index)</code>： 能正确返回一个四个字节组成的字符的码点值。</p></li><li><p><code>String.prototype.indexOf()</code>: indexOf() 方法返回调用  String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。如果未找到该值，则返回-1。<strong>这个方法区分大小写</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;Blue Whale&apos;.indexOf(&apos;lu&apos;)</span><br><span class="line">//1</span><br><span class="line"></span><br><span class="line">//判断某个字符串是否存在于另一个字符串中</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;) !== -1; // true</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Bloe&quot;) !== -1; // false</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.lastIndexOf()</code>: lastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。</p><p> 其中， fromIndex从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。</p></li><li><p><code>String.prototype.startsWith()</code>: 用来判断当前字符串是否以另外一个给定的子字符串开头，返回true或false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;To be, or not to be, that is a question.&apos;;</span><br><span class="line"></span><br><span class="line">alert(str.startsWith(&apos;To be&apos;))//true</span><br><span class="line">alert(str.startsWith(&apos;not to be&apos;))//false</span><br><span class="line">alert(str.startsWith(&apos;not to be&apos;, 10))//true</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.endWith()</code>: endsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;To be, or not to be, that is the question.&quot;;</span><br><span class="line"></span><br><span class="line">alert( str.endsWith(&quot;question.&quot;) );  // true</span><br><span class="line">alert( str.endsWith(&quot;to be&quot;) );      // false</span><br><span class="line">alert( str.endsWith(&quot;to be&quot;, 19) );  // true</span><br><span class="line"></span><br><span class="line">注意最后一个alert，结束位置是19而不是18,19表示的是be后面的那个逗号。</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.includes()</code>: 判断一个字符串中是否包含另一个字符串，返回true或false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;To be, or not to be, that is the question.&apos;;</span><br><span class="line"></span><br><span class="line">console.log(str.includes(&apos;To be&apos;));       // true</span><br><span class="line">console.log(str.includes(&apos;question&apos;));    // true</span><br><span class="line">console.log(str.includes(&apos;nonexistent&apos;)); // false</span><br><span class="line">console.log(str.includes(&apos;To be&apos;, 1));    // false</span><br><span class="line">console.log(str.includes(&apos;TO BE&apos;));       // false</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.concat()</code>:字符串拼接函数，由于性能问题，mdn建议使用<code>+</code>代替这个函数拼接字符串。自己写代码好像还真没用过这个函数。</p></li><li><p><code>String.fromCharCode()</code>：这个函数是String类的静态方法，必须这样使用。返回<strong>字符串</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(65,66,67)//&apos;ABC&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint()</code>: 这个函数同样是String类的静态方法。参数是高位码点。</p></li><li><p><code>String.prototype.split(seperator[,limit])</code>: 使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。separator 可以是一个字符串或正则表达式。</p><ul><li><p>例1：使用空格作为Seperator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Webkit Moz O ms Khtml&quot;.split( &quot; &quot; )   // [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;O&quot;, &quot;ms&quot;, &quot;Khtml&quot;]</span><br></pre></td></tr></table></figure></li><li><p>例2：使用正则表达式作为Seperator,正则表达式不需要加<code>g</code>标识符。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/(\d)/);</span><br><span class="line"></span><br><span class="line">console.log(splits);</span><br><span class="line"></span><br><span class="line">//[ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure><ul><li>例3：设置第二个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello World. How are you doing?&quot;;</span><br><span class="line">var splits = myString.split(&quot; &quot;, 3);</span><br><span class="line"></span><br><span class="line">console.log(splits);</span><br><span class="line"></span><br><span class="line">//[&quot;Hello&quot;, &quot;World.&quot;, &quot;How&quot;]</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.slice(begin[, end])</code>:返回一个子字符串，提取范围是[begin, end),其中end为可选参数，如果begin或end为负值，则实际为length+begin/length+end。</p></li><li><p><code>String.prototype.substring(begin[, end]</code>: 返回一个子字符串。类似上面的slice方法。当begin&gt;end时，会交换begin和end的位置执行。</p></li><li><p><code>String.prototype.substr(start[, length])</code>：返回一个字符串中从指定位置开始到指定字符数的字符。</p></li><li><p><code>String.prototype.match()</code>： <code>match（）</code>函数是<strong>字符对象</strong>的方法！！！</p><ul><li><p>接受一个<strong>正则表达式</strong></p><ol><li><p>正则表达式没有加<code>g</code>时，返回的数组会带有一个<code>index</code>属性，表示匹配结果的索引；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reg = /matc(h)/;</span><br><span class="line"></span><br><span class="line">var str = &apos;this is a match function test.&apos;;</span><br><span class="line"></span><br><span class="line">var re = str.match(reg);</span><br><span class="line"></span><br><span class="line">re;</span><br><span class="line"></span><br><span class="line">// [&quot;match&quot;, &quot;h&quot;, index: 10, input: &quot;this is a match function test.&quot;]</span><br></pre></td></tr></table></figure></li><li><p>如果加了<code>g</code>，则只会返回匹配项组成的数组（不包含括号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reg = /matc(h)/g;</span><br><span class="line"></span><br><span class="line">var str = &apos;this is a match function test.&apos;;</span><br><span class="line"></span><br><span class="line">var re = str.match(reg);</span><br><span class="line"></span><br><span class="line">re;</span><br><span class="line"></span><br><span class="line">// [&quot;match&quot;]</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><code>String.prototype.replace()</code>:replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。(自己写代码有用到这个函数多次，还算熟)。</p><blockquote><p>str.replace(regexp|substr, newSubStr|function)</p></blockquote><ol><li>第二个参数是<strong>字符串</strong>时, 可以使用下图中所示变量名。对于最后一个变量名<code>$n</code>，要特别说明下，第一个括号用1表示而不是0。</li></ol><p><img src="/images/js/3.png" alt="特殊变量名"></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//交换一个字符串中两个单词的位置</span><br><span class="line"></span><br><span class="line">var re = /(\w+)\s(\w+)/;</span><br><span class="line">var str = &quot;John Smith&quot;;</span><br><span class="line">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class="line">// Smith, John</span><br><span class="line">console.log(newstr);</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li>第二个参数是<strong>函数</strong>时，每次匹配成功都会调用这个函数，将返回结果作为替代字符串。</li></ol><p><img src="/images/js/4.png" alt="函数参数"></p></li><li><p><code>String.prototype.search()</code>: 如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p><p>使用<strong>-1</strong>来判断是否有匹配成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function testinput(re, str)&#123;</span><br><span class="line">var midstring;</span><br><span class="line">if (str.search(re) != -1)&#123;</span><br><span class="line">    midstring = &quot; contains &quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    midstring = &quot; does not contain &quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log (str + midstring + re);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.repeat()</code>：记得以前看python的时候好像字符串和乘号能直接翻倍字符串，js中好像没有这种功能。</p></li><li><p><code>String.prototype.trim()</code>: <strong>trim方法</strong>只会删除开头和结尾的空白，对于字符中的空白无能为力。</p></li></ol></li><li><p>模板字符串</p><ol><li>换行：这个超方便。超方便！</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之五——《数字和日期》</title>
      <link href="/2018/07/07/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/"/>
      <url>/2018/07/07/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates" target="_blank" rel="noopener">译文地址</a></p><ol><li><p>js中数字的范围和类型</p><p>范围： -(2^53 - 1) ~ (2^53 - 1)</p><p>类型： 普通数字， +Infinity， -Infinity， NaN</p></li></ol><a id="more"></a><ol start="2"><li><p>数字对象属性和方法的引用</p><p>属性包括最大值、最小值、非数、正无穷、负无穷、比较值、最大安全数、最小安全数。</p><p><img src="/images/js/1.png" alt="数字对象属性"></p><p>方法调用的时候要使用<code>Number.</code>的形式，忘记这个在哪儿看到的了，总之就是有好处就对了。</p><p><img src="/images/js/2.png" alt="数字对象的方法"></p></li><li><p>实现精确四舍五入保留小数位数的方法</p><ol><li><p><code>Number.prototype.toFixed()</code>：这个写在数字对象原型上的方法就可以做到，只不过会返回字符串形式的结果。（负数因为操作符的优先级问题，在不加括号的情况下不会返回字符串形式）</p></li><li><p>使用这种方法保留小数后几（3）位：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const rounded = Math.round(output * 1000) / 1000;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Math对象的方法</p><p> Math对象不可以自定义。</p><ol><li><p><code>floor（）</code>往下舍;</p></li><li><p><code>ceil（）</code>往上进;</p></li><li><p><code>round（）</code>四舍五入，只可保证整数部分是精确的;</p></li><li><p><code>trunc（）</code>截掉数字的小数部分。</p></li><li><p><code>random（）</code>返回一个浮点,  伪随机数在范围[0，1)， <strong>不能使用它们来处理有关安全的事情。使用Web Crypto API 来代替, 和更精确的window.crypto.getRandomValues() 方法。</strong></p><ol><li><p>得到一个大于等于0，小于1之间的随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getRandom() &#123;</span><br><span class="line">  return Math.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到一个两数之间的随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到一个两数之间的随机整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  min = Math.ceil(min);</span><br><span class="line">  max = Math.floor(max);</span><br><span class="line">  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到一个两数之间的随机整数，包括两个数在内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomIntInclusive(min, max) &#123;</span><br><span class="line">  min = Math.ceil(min);</span><br><span class="line">  max = Math.floor(max);</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>日期对象</p><ol><li><p>如果不使用<em>new</em>调用<code>Date()</code>,则返回的是当前日期时间的字符串。</p></li><li><p>使用<em>new</em>调用<code>new Date()</code>。使用这种方式创建的时间对象都可以使用Date对象的相关方法进行操作。</p><ol><li><p>如果不传入参数，则返回当前日期时间的时间对象;</p></li><li><p>传入<code>1995, 11, 25, 9, 30, 0</code>表示传入的是1995年11月25日9点30分0秒。</p></li></ol></li><li><p>Date对象的常用方法</p><ol><li><p><code>Date.prototype.getDate()</code>: 根据本地时间返回指定日期对象的月份中的第几天（1-31）。</p></li><li><p><code>Date.prototype.getDay()</code>: 根据本地时间返回指定日期对象的星期中的第几天（0-6）。</p></li><li><p><code>Date.prototype.getFullYear()</code>: 根据本地时间返回指定日期对象的年份。</p></li><li><p><code>Date.prototype.getHours()</code>: 根据本地时间返回指定日期对象的小时（0-23）。</p></li><li><p><code>Date.prototype.getSeconds()</code>: 根据本地时间返回指定日期对象的秒数（0-59）。</p></li><li><p><code>Date.prototype.getMinutes()</code>: 根据本地时间返回指定日期对象的分钟（0-59）。</p></li><li><p><code>Date.prototype.getMonth()</code>: 根据本地时间返回指定日期对象的月份（0-11）。</p></li><li><p><code>Date.prototype.toDateString()</code>: 返回一个人类可读的日期字符串，比如 <em>“Mon Jul 09 2018”</em> 。</p></li><li><p><code>Date.prototype.toLocalDateString()</code>： 返回一个 <em>“2018/7/9”</em> 这样形式的日期字符串。术语叫<strong>该字符串格式与系统设置的地区关联</strong>。</p></li><li><p><code>Date.prototype.toLocaleString()</code>:<br>返回一个 <em>“2018/7/9 上午10:48:34”</em> 这样形式的日期字符串。术语叫<strong>该字符串与系统设置的地区关联</strong>。</p></li><li><p><code>Date.prototype.toLocaleTimeString()</code>:返回一个 <em>“上午10:48:34”</em> 这样形式的时间字符串。</p></li><li><p><code>Date.prototype.toString()</code>: 返回 <em>“Mon Jul 09 2018 10:48:34 GMT+0800 (CST)”</em> 这种形式的字符串。感觉上面那种 <em>toLocale</em> 形式的更有用些。</p></li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome开发者工具使用技巧</title>
      <link href="/2018/07/06/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/07/06/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用开发者工具查看dom节点的监听函数</p><ol><li>使用console查看</li></ol></li></ol><a id="more"></a><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. let btn = $(&apos;.btn&apos;)[0];//获取类名为btn的dom节点</span><br><span class="line"></span><br><span class="line">2. let listeners = getEventListeners(btn);//获取btn的事件监听函数</span><br><span class="line"></span><br><span class="line">3. debug（listeners.click[0].listen);//设置打断</span><br><span class="line"></span><br><span class="line">4. btn.click();//触发点击事件</span><br></pre></td></tr></table></figure>![查看节点监听函数](/images/chrome/get-debug-event-listeners.gif)2. 使用eventListeners</code></pre><ol start="2"><li><p>快速改变css的数字值</p><ol><li><p><code>up/ctrl+鼠标滚轮</code>:整数1;</p></li><li><p><code>alt+up/alt+鼠标滚轮</code>:小数1;</p></li><li><p><code>shift+up/shift+鼠标滚轮</code>：整数10;</p><p><img src="/images/chrome/quick-change-css-values.gif" alt="css样式数字值快速变化"></p></li></ol></li><li><p>设置条件断点</p><p> <img src="/images/chrome/conditional-breakpoint.gif" alt="设置条件断点"></p></li><li><p>在source panel中快速选择多个同样的词</p><p> <code>ctrl+d</code></p><p> <img src="/images/chrome/select-next-occurrence.gif" alt="快速选择多个同样的词"></p></li><li><p>添加移动设备</p><p> <img src="/images/chrome/add-new-device.gif" alt="添加移动设备"></p></li><li><p>使用<code>console.trace()</code></p><p> 查看代码的执行流程。可以点击跳转到相应的代码处。</p><p> <img src="/images/chrome/console-trace.gif" alt="console.trace()"></p></li><li><p>过滤资源</p><ol><li><p>large-than</p></li><li><p>status-code</p></li><li><p>mime-type</p></li><li><p>method</p></li><li><p>-larger-than</p><p><img src="/images/chrome/network-advanced-filter.gif" alt="过滤资源"></p></li></ol></li><li><p>搜索特定项</p><ol><li><p><code>item</code></p></li><li><p><code>item file:main.js</code></p><p><img src="/images/chrome/project-search-with-file-scope.gif" alt="搜索特定项"></p></li></ol></li><li><p>粘贴复制dom节点</p><p> <img src="/images/chrome/duplicate-dom.gif" alt="粘贴复制dom节点"></p></li><li><p>使用console修改节点</p><p><img src="/images/chrome/console-edit-html.gif" alt="使用console修改节点"></p></li><li><p>禁用css和js查看页面</p><p><img src="/images/chrome/block-requests.gif" alt="禁用css和js查看页面"></p></li><li><p>调整动画效果</p><p><a href="http://www.justinaguilar.com/animations/#" target="_blank" rel="noopener">示例网站</a></p><p><img src="/images/chrome/animation-inspector.gif" alt="调整动画效果"></p></li><li><p>查看jQuery监听函数定义</p><p><img src="/images/chrome/jquery-event-listeners.gif" alt="查看jQuery监听函数定义"></p></li><li><p>查看请求优先级</p><p><code>shift+hover</code></p><ol><li><p>红色表示这些request是由当前request发出的请求;</p></li><li><p>绿色表示当前request是由绿色request发出的请求;</p></li><li><p>右键调出 <em>priority</em> 一栏，显示请求的优先级。</p></li></ol><p><img src="/images/chrome/network-dependency.gif" alt="查看请求优先级"></p></li><li><p>使用style中的工具添加背景颜色和字体颜色——感觉没什么卵用</p><p><img src="/images/chrome/style-rule-toolbar.gif" alt="使用style中的工具添加背景颜色和字体颜色"></p></li><li><p>在console中隐藏不用的 <em>error</em> , <em>warning</em></p><p><img src="/images/chrome/hide-network-console.gif" alt="在console中隐藏不用的error,warning"></p></li><li><p>在style中长hover定位元素</p><p><img src="/images/chrome/hover-over-selector.gif" alt="在style中长hover定位元素"></p></li><li><p>使用<code>console.table</code>显示对象或数组</p><p><img src="/images/chrome/console-table.gif" alt="console.table"></p></li><li><p>使用<code>console.time</code>显示经历时长</p><p><img src="/images/chrome/console-time.gif" alt="console.time"></p></li><li><p>启闭元素的类</p><p><img src="/images/chrome/toggle-element-classes.gif" alt="启闭元素的类"></p></li><li><p>使用google搜索矿搜索github</p><p>git+tab</p></li><li><p>查看资源是如何加载的</p><p><img src="/images/chrome/resource-initiator.gif" alt="查看资源加载"></p></li><li><p><code>ctrl+shift+p</code>调出命令菜单</p></li><li><p>将动画输出到console</p><p>支持的操作：</p><ol><li><p>temp1.play() - Starts playing an animation.</p></li><li><p>temp1.pause() - Pause the playing animation.</p></li><li><p>temp1.reverse() - Play an animation backwards.</p></li><li><p>temp1.playbackRate - Get or set the playback rate of the animation.</p></li></ol><p><img src="/images/chrome/web-animation-api.gif" alt="动画输出到console"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之四——《表达式和运算符》</title>
      <link href="/2018/07/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/07/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<ol><li><p>假值</p><p> <code>false, null, 0, NaN, &quot;&quot;, undefined</code></p></li><li><p>逗号操作符</p><p> 对两个操作数进行求值并<strong>返回最终操作数的值</strong>。它常常用在 for 循环中，在每次循环时对多个变量进行更新。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = [0,1,2,3,4,5,6,7,8,9]</span><br><span class="line">var a = [x, x, x, x, x];</span><br><span class="line"></span><br><span class="line">for (var i = 0, j = 9; i &lt;= j; i++, j--)</span><br><span class="line">  console.log(&apos;a[&apos; + i + &apos;][&apos; + j + &apos;]= &apos; + a[i][j]);</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li><p>delete操作符</p><p> delete不能删除使用var，let，const声明的变量。</p><p> delete删除数组元素值，这个元素还存在，但是值变成了undefined,<br> 执行<code>index in array</code>返回<code>false</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obt1 = &#123;</span><br><span class="line">  test: &apos;test1&apos;,</span><br><span class="line">  test2: &apos;test2&apos;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let arr1 = [</span><br><span class="line">    1, 2, 3</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let obj1 = &#123;</span><br><span class="line">  test: &apos;test&apos;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(delete obj1);//false</span><br><span class="line">console.log(obj1);//&#123;test: &quot;test&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(delete obt1.test);//true</span><br><span class="line">console.log(obt1);//&#123;test2: &quot;test2&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(delete arr1[1]);//true</span><br><span class="line">console.log(arr1);//[1, , 3]</span><br><span class="line">conosle.log(arr1[1]);//undefined</span><br></pre></td></tr></table></figure></li><li><p>表达式和语句</p><p> 表达式： 用来计算出一个值</p><p> 语句： 用来使某个事情发生</p></li><li><p>typeof操作符</p><p> 返回值为字符串形式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof myFun;     // returns &quot;function&quot;</span><br><span class="line">typeof shape;     // returns &quot;string&quot;</span><br><span class="line">typeof size;      // returns &quot;number&quot;</span><br><span class="line">typeof today;     // returns &quot;object&quot;</span><br><span class="line">typeof dontExist; // returns &quot;undefined&quot;</span><br><span class="line">typeof true; // returns &quot;boolean&quot;</span><br><span class="line">typeof null; // returns &quot;object&quot; 这个要注意下</span><br></pre></td></tr></table></figure></li><li><p>in操作符</p><p> <strong>检查它（或其原型链）是否包含具有指定名称的属性的对象。</strong></p><p> <code>prop in object</code></p><p> <em>prop</em>: 一个字符串类型或者 symbol 类型的属性名或者数组索引</p><p> <em>object</em>: 对象或者数组</p></li><li><p>instance操作符</p><p> <strong>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</strong></p><p> <code>object instanceof constructor</code></p></li><li><p>基本表达式</p><ol><li><p>this</p><p> 下面这两种用法之前没有留意过诶。</p><ol><li><p>作为一个DOM事件处理函数</p><p> 当函数被用作事件处理函数时，它的this指向触发事件的元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">function bluify(e)&#123;</span><br><span class="line">console.log(this === e.currentTarget); // 总是 true</span><br><span class="line"></span><br><span class="line">// 当 currentTarget 和 target 是同一个对象时为 true</span><br><span class="line">console.log(this === e.target);        </span><br><span class="line">this.style.backgroundColor = &apos;#A5D9F3&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取文档中的所有元素的列表</span><br><span class="line">var elements = document.getElementsByTagName(&apos;*&apos;);</span><br><span class="line"></span><br><span class="line">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">elements[i].addEventListener(&apos;click&apos;, bluify, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为一个内联事件处理函数</p><p> 当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt;</span><br><span class="line">Show this</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//alert 会显示button</span><br></pre></td></tr></table></figure><p> 还有下面这种用法…感觉之前完全没有想过。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function validate(obj, lowval, hival)&#123;</span><br><span class="line">if ((obj.value &lt; lowval) || (obj.value &gt; hival))</span><br><span class="line">    console.log(&quot;Invalid Value!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Enter a number between 18 and 99:&lt;/p&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>扩展语句</p><p> <strong>注意！！！</strong>在数组或函数中使用展开语法时，该语法只可用于可迭代对象！！！！！</p><ol><li><p>函数调用</p><p> <code>myFunction(...iterableObj);</code></p><ol><li><p>普通函数调用时等价于apply的方式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(x, y, z) &#123; &#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">myFunction.apply(null, args);</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><pre><code>    2. 在new表达式中应用时，不能直接使用数组+apply的方式（apply 执行的是调用 [[Call]] , 而不是构造 [[Construct]]），这时，使用扩展语句就要方便的多        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dateFields = [1970，0，1]; // 1970年1月1日</span><br><span class="line">var d = new Date（... dateFields）;</span><br></pre></td></tr></table></figure>2. 字面量数组构造或字符串    `[...iterableObj, &apos;4&apos;, ...&apos;hello&apos;, 6];`    1. 利用扩展语法构造字面量数组    2. 数组拷贝        扩展语法与`Object.assign()`执行的都是浅拷贝（只遍历一层）。所以才会出现下述结果：        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [[1], [2], [3]];</span><br><span class="line">var b = [...a];</span><br><span class="line">b.shift().shift(); // 1</span><br><span class="line">// Now array a is affected as well: [[], [2], [3]]</span><br></pre></td></tr></table></figure>    3. 使用`扩展语句`和`Array.concat`有相同的效果        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用Array.concat</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">// 将 arr2 中所有元素附加到 arr1 后面并返回</span><br><span class="line">var arr3 = arr1.concat(arr2);</span><br><span class="line"></span><br><span class="line">//使用扩展语法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">var arr3 = [...arr1, ...arr2];</span><br></pre></td></tr></table></figure>    4. 使用`扩展语句`和`Array.unshift`有相同的效果        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用unshift函数</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">// 将 arr2 中的元素插入到 arr1 的开头</span><br><span class="line">Array.prototype.unshift.apply(arr1, arr2) // arr1 现在是 [3, 4, 5, 0, 1, 2]</span><br><span class="line"></span><br><span class="line">//使用扩展语法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">arr1 = [...arr2, ...arr1]; // arr1 现在为 [3, 4, 5, 0, 1, 2]</span><br></pre></td></tr></table></figure>3. 构造字面量对象时,进行克隆或者属性拷贝    `let objClone = { ...obj };`    1. **使用`扩展语句`和`Object.assign`有相同的效果**；    2. `Object.assign`仅会针对对象自身的可枚举的属性进行操作；    3. `Object.assign`会触发`setter`，而展开语句不会。        关于这条，触发了`setter`又如何，有什么特殊的影响？感觉没有诶。。。MDN的`Object.assign`页面上有下述描述：        &gt;该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。        sowhat？暂时搁置。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查缺补漏之三 —— 《循环和函数》</title>
      <link href="/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/"/>
      <url>/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<ol><li><p>break</p><ol><li>当在循环中执行break时，会立即终止当前所在的循环。比如下面这几行代码：</li></ol></li></ol><a id="more"></a><pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    for ( j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">        if (i === 0) &#123;</span><br><span class="line">            console.log(&apos;最里面:&apos;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&apos;里面：&apos;, i);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;外面：&apos;, i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;最外面&apos;);</span><br><span class="line"></span><br><span class="line">//输出顺序：</span><br><span class="line">    最里面: 0</span><br><span class="line">    外面： 0</span><br><span class="line">    里面： 1</span><br><span class="line">    外面： 1</span><br><span class="line">    里面： 2</span><br><span class="line">    外面： 2</span><br><span class="line">    最外面</span><br></pre></td></tr></table></figure>    说明break只跳出了内层循环（所在循环），并没有跳出外面包裹的循环。2. break label 语法    自己从来没有使用过这种语法，但通过下面这个列子感觉这个语法还是蛮方便的：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">var z = 0</span><br><span class="line">labelCancelLoops: while (true) &#123;</span><br><span class="line">console.log(&quot;外部循环: &quot; + x);</span><br><span class="line">x += 1;</span><br><span class="line">z = 1;</span><br><span class="line">while (true) &#123;</span><br><span class="line">    console.log(&quot;内部循环: &quot; + z);</span><br><span class="line">    z += 1;</span><br><span class="line">    if (z === 10 &amp;&amp; x === 10) &#123;</span><br><span class="line">    break labelCancelLoops;</span><br><span class="line">    &#125; else if (z === 10) &#123;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果满足 z === 10 &amp;&amp; x === 10 的条件，整个循环就会结束，就是使用了break labelCancelLoops 这条语法。</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p><code>for in</code> vs <code>for of</code> vs <code>for</code></p><ol><li><p>for…in 语句循环一个指定的变量来循环一个对象<strong>所有可枚举</strong>的属性。</p></li><li><p>for…of语句在可迭代的对象上创建了一个循环(包括Array, Map, Set, 参数对象（ arguments） 等等)</p></li><li><p>数组适合用传统for循环来操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 7];</span><br><span class="line">arr.foo = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">console.log(i); // logs &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">console.log(i); // logs &quot;3&quot;, &quot;5&quot;, &quot;7&quot; // 注意这里没有 hello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">console.log(i); //logs &quot;0&quot;, &quot;1&quot;, &quot;2&quot;// 注意这里没有 foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，传统for循环和for of循环的结果相似。</p></li></ol></li><li><p>函数表达式</p><p> 函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var factorial = function fac(n) &#123;return n&lt;2 ? 1 : n*fac(n-1)&#125;;</span><br><span class="line"></span><br><span class="line">console.log(factorial(3));</span><br></pre></td></tr></table></figure><p> 注意下面代码中<code>square</code>并非函数名，下面这个函数是匿名函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var square = function(number) &#123; return number * number; &#125;;</span><br><span class="line">var x = square(4); // x gets the value 16</span><br></pre></td></tr></table></figure></li><li><p>Arguments对象</p><p> arguments 是一个对应于传递给函数的参数的类数组对象。</p><p> arguments对象是所有<strong>非箭头</strong>函数中都可用的局部变量。可以使用arguments对象在函数中引用函数的参数。</p><p> arguments的元素可读可写。</p></li><li><p>apply()函数</p><p> <code>func.apply(thisArg, [argsArray])</code>，其中<code>[argsArray]</code>可以为数组也可以是类数组</p></li><li><p>类数组</p><p> 只要有一个 length 属性和[0…length) 范围的整数属性。比如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;length&apos;: 2, &apos;0&apos;: &apos;eat&apos;, &apos;1&apos;: &apos;bananas&apos;&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找一系列数字中的最大最小值</p><ol><li><p>使用apply和原生Math.max()、Math.min()方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [5, 6, 2, 3, 7];</span><br><span class="line">var max = Math.max.apply(null, numbers);</span><br><span class="line">var min = Math.min.apply(null, numbers);</span><br></pre></td></tr></table></figure></li><li><p>使用数组扩展符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var max = Math.max(...arr);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>类数组转为数组</p><ol><li><p>方法1： 对性能有影响<br> <code>Array.prototype.slice.call(arguments)</code>，这行代码的意思是将slice方法绑定在arguments对象上。</p><p> 简写形式:</p><p> <code>[].slice.call(arguments)</code>，依然是将slice方法绑定在arguments对象上。</p></li><li><p>方法2：</p><p> <code>const args = Array.from(arguments);</code></p></li><li><p>方法3：使用扩展运算符</p><p> <code>var args = [...arguments];</code></p></li></ol></li><li><p><code>arguments.length</code> vs <code>function.length</code></p><p> arguments.length：表示实际传入函数的参数的个数；</p><p> function.length: 指该函数有多少个必须要传入的参数，即形参的个数。形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数。</p></li><li><p>剩余参数 vs 默认参数 vs 解构赋值</p><ol><li><p>剩余参数</p><p> 如果函数的最后一个命名参数以…为前缀，则它将组成一个数组。<strong>剩余参数是货真价实的数组而arguments对象只是类数组。</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(...args) &#123;</span><br><span class="line">return args;</span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3);//[1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><p> <strong>默认参数是在函数被调用时解析的</strong>，所以如果默认参数是可变动的，则每次的结果可能是不一样的。</p></li><li><p>解构赋值</p><p> <strong>数组的解构赋值</strong>:目测是按数组元素的顺序。（此处仅记录了数组的解构赋值）。</p><ol><li><p>利用数组的解构赋值可以轻松交换值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1, b = 3;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">console.log(a);//3</span><br><span class="line">console.log(b);//1</span><br></pre></td></tr></table></figure></li><li><p>解析一个从函数返回的数组</p><p> 这个自己写代码已经遇到过多次返回数组的情况，但是都使用的传统获取数组对应位置的元素的方法，明显使用数组解构更简洁。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">return [1, 2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a, b; </span><br><span class="line">[a, b] = f(); </span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 2</span><br></pre></td></tr></table></figure></li><li><p>忽略一些值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [a, , b] = f();</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 3</span><br></pre></td></tr></table></figure></li><li><p>将剩余数组赋值给一个变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [a, ...b] = [1, 2, 3];</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // [2, 3]</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><pre><code>5. 用正则表达式匹配提取值    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var url = &quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;;</span><br><span class="line"></span><br><span class="line">var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);</span><br><span class="line">console.log(parsedURL); // [&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;, &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/Web/JavaScript&quot;]</span><br><span class="line"></span><br><span class="line">var [, protocol, fullhost, fullpath] = parsedURL;</span><br><span class="line"></span><br><span class="line">console.log(protocol); // &quot;https&quot;</span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li><p>函数递归</p><p>递归函数就使用了堆栈：函数堆栈。</p><ol><li><p>应用1：获取树结构中所有的节点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function walkTree(node) &#123;</span><br><span class="line">if (node == null) // </span><br><span class="line">    return;</span><br><span class="line">// do something with node</span><br><span class="line">for (var i = 0; i &lt; node.childNodes.length; i++) &#123;</span><br><span class="line">    walkTree(node.childNodes[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>箭头函数</p><p>箭头函数会捕捉闭包上下文的this值，以词法方式绑定this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">this.age = 0;</span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    this.age++; // |this| properly refers to the person object</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查缺补漏之二 ——《语法与类型》</title>
      <link href="/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types" target="_blank" rel="noopener">原文地址</a></p><ol><li><p>在 JavaScript 中大小写敏感，变量 früh 和 Früh 则是两个不同的变量。</p></li><li><p>当你对一个 null 变量求值时，空值 null 在数值类型环境中会被当作0来对待，而布尔类型环境中会被当作 false。</p></li></ol><a id="more"></a><ol start="3"><li><p>局部变量：在函数内部声明的变量。</p></li><li><p>函数提升：只有函数声明会被提升到顶部，而不包括函数表达式。</p></li><li><p>对象属性和数组元素不受保护，可以使用<code>const</code>来声明对象名或数组名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MY_OBJECT = &#123;&quot;key&quot;: &quot;value&quot;&#125;;</span><br><span class="line">MY_OBJECT.key = &quot;otherValue&quot;;</span><br><span class="line"></span><br><span class="line">const MY_ARRAY = [&apos;HTML&apos;,&apos;CSS&apos;];</span><br><span class="line">MY_ARRAY.push(&apos;JAVASCRIPT&apos;);</span><br><span class="line">console.log(MY_ARRAY); //logs [&apos;HTML&apos;,&apos;CSS&apos;,&apos;JAVASCRIPT&apos;];</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString()</p><p> 每个对象都包含一个<code>toString()</code>属性，默认情况会返回 “[object type]”（注意！！！此处返回值确实会带着引号），其中type是对象的类型。</p><p> 可以在对象中重写<code>toString()</code>来覆盖默认返回值。</p></li><li><p>给一个对象定义属性和值的一个不常用的写法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</span><br></pre></td></tr></table></figure></li><li><p>魔术字符串</p><p> 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。</p></li><li><p><code>for in</code> vs <code>Object.keys</code> vs <code>Object.getOwnPropertyNames</code></p><ul><li><p><code>for in</code> ：用来获取某个对象（<strong>该对象</strong>）及其<strong>原型链</strong>上的可枚举属性。如果仅想获取该对象自身的属性，要借助<code>hasOwnProperty</code>方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var key in child) &#123;</span><br><span class="line">    if (child.hasOwnProperty(key)) &#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `Object.keys` ：用来获取某个对象自身的可枚举属性。其效果等于`for in` + `hasOwnProperty`。- `Object.getOwnPropertyNames` ： 用来获取某个对象自身可枚举以及不可枚举的属性（不可获取以symbol命名的属性名）。</code></pre><ol start="10"><li><p>不要混淆原始的布尔值true和false与 Boolean对象的真和假</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var b = new Boolean(false);</span><br><span class="line">if (b) // this condition evaluates to true</span><br><span class="line">if (b == true) // this condition evaluates to false</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查缺补漏之一 ——《流程控制与错误处理》</title>
      <link href="/2018/07/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2018/07/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow_and_error_handling" target="_blank" rel="noopener">原文地址</a></p><ol><li><p>如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么。</p><p> 下面代码中有说明，catch中的return会挂起，直到finally中的代码完成，finally中的return会覆盖catch中的return。return之后的console都不会执行。</p></li></ol><a id="more"></a><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(0);</span><br><span class="line">    throw &quot;bogus&quot;;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    return true; // this return statement is suspended</span><br><span class="line">                // until finally block has completed</span><br><span class="line">    console.log(2); // not reachable</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    return false; // overwrites the previous &quot;return&quot;</span><br><span class="line">    console.log(4); // not reachable</span><br><span class="line">  &#125;</span><br><span class="line">  // &quot;return false&quot; is executed now  </span><br><span class="line">  console.log(5); // not reachable</span><br><span class="line">&#125;</span><br><span class="line">f(); // console 0, 1, 3; returns false</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>catch中可以再次抛出异常，但如果finally中有返回值，则这个返回值会覆盖catch中抛出的异常。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw &apos;bogus&apos;;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(&apos;caught inner &quot;bogus&quot;&apos;);</span><br><span class="line">    throw e; // this throw statement is suspended until </span><br><span class="line">            // finally block has completed</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    return false; // overwrites the previous &quot;throw&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // &quot;return false&quot; is executed now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套try…catch</p><p> 任何给定的异常只会被离它最近的封闭 catch 块捕获一次。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&quot;oops&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (ex) &#123;</span><br><span class="line">    console.error(&quot;inner&quot;, ex.message);</span><br><span class="line">    throw ex;</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    console.log(&quot;finally&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ex) &#123;</span><br><span class="line">  console.error(&quot;outer&quot;, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output:</span><br><span class="line">// &quot;inner&quot; &quot;oops&quot;</span><br><span class="line">// &quot;finally&quot;</span><br><span class="line">// &quot;outer&quot; &quot;oops&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React查缺补漏之二——《React模式》</title>
      <link href="/2018/07/03/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C/"/>
      <url>/2018/07/03/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="http://sangka-z.com/react-in-patterns-cn/" target="_blank" rel="noopener">译文链接</a></p><ol><li><p>通过给一个通用函数传入参数定制特定函数的用法</p><p> <code>_onFieldChange</code>函数是一个通用实例方法，通过给这个函数传入不同的参数来实现返回结果的不同。</p><p> 在构造函数中，进行绑定（没有想过这种用法）。</p></li></ol><a id="more"></a><pre><code>  1. `this._onNameChanged = this._onFieldChange.bind(this, &apos;name&apos;);`  2. `this._onPasswordChanged =this._onFieldChange.bind(this, &apos;password&apos;);`**注意点击的回调事件要写在事件处理函数参数的最后**，上述在绑定的过程中传入的参数相当于第一个参数。这是因为：1. 使用箭头函数,事件对象e要显式传递;2. 使用bind方法，事件对象e会隐式传递，e要放在参数的最后。这里使用的是bind方法，事件对象会隐士传递，所以可以直接在`input`的`onChange`属性中单纯传入回调函数并且回调事件要写在回调函数参数的最后。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Form extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this._onNameChanged = this._onFieldChange.bind(this, &apos;name&apos;);</span><br><span class="line">    this._onPasswordChanged =</span><br><span class="line">      this._onFieldChange.bind(this, &apos;password&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;input onChange=&#123; this._onNameChanged &#125; /&gt;</span><br><span class="line">        &lt;input onChange=&#123; this._onPasswordChanged &#125; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _onFieldChange(field, event) &#123;</span><br><span class="line">    console.log(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>解绑强耦合组件的讨论——组合</p><p> 作者认为<strong>组合</strong>是React的最强大的优势之一。</p><p> 书中的组合部分涉及<code>组件作为属性传递</code>，<code>高阶组件</code>，自己现在在写代码的时候会有意的将每个组件都写成单一功能的组件，自己感觉主要的好处还是视觉上的，不会出现看起来庞大数量巨大到恐怖的组件，改bug比较好定位。现在写的多数都是一次性组件，也没有写过组件测试，所以代码重用的优点感受的不明显，降低测试难度完全没有体会。</p><ol><li><p><code>children</code>属性</p><p> 这个属性之前没有好好关注过，如今看来是个相当好用的属性。书里说这个属性一大用途是用来解绑父组件和子组件的强耦合。</p></li><li><p>将组件作为参数传入另一个组件</p><p> 其实上面的<code>children</code>属性也相当与将组件作为参数传入另一个组件。之所以现在不太用这种写法是因为自己还没有写过通用组件，比如项目里的各种modal。写的全都是一次性的组件，写成强耦合的组件或许更直观，代码量也能减少，但如果涉及到组件测试就完逼了，最近写的组件业务逻辑都比较复杂了，组件的测试也肯定会相当复杂。（之前自己从没写过测试组件，现在要练习下。）</p></li><li><p>高阶组件</p><p> <strong>高阶组件的调用要在render（）之前，生成一个唯一的组件，如果在render（）中调用，每次生成的都不一样，会产生性能问题</strong>，见<a href="https://github.com/krasimir/react-in-patterns/issues/12" target="_blank" rel="noopener">作者观点</a>。</p><p> 下面是一个典型的高阶组件，在组件强化函数中，<code>Component</code>组件的参数title和remoteTitle的数据来源一个是配置文件，一个是ajax请求，即能控制原始组建的输入，同时还能传入高阶组件的props，书里说这是高阶组件的最大优点（<strong>控制数据来源</strong>）。感觉甚至可以把ajax请求作为高阶组件的参数传入，这样即保证组件的功能单一可复用，又能让数据和对应的组件组合在一起，还能避免原先的在上层的父组件中写入和父组件完全不相关的数据请求函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  var config = require(&apos;path/to/configuration&apos;);</span><br><span class="line"></span><br><span class="line">  var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line"></span><br><span class="line">      this.state = &#123; remoteTitle: null &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      fetchRemoteData(&apos;path/to/endpoint&apos;).then(data =&gt; &#123;</span><br><span class="line">        this.setState(&#123; remoteTitle: data.title &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          title=&#123; config.appTitle &#125;</span><br><span class="line">          remoteTitle=&#123; this.state.remoteTitle &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle  = (&#123; title, remoteTitle &#125;) =&gt;</span><br><span class="line">  &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>4. 将函数作为children和render props    下面这个例子里，App组件中不仅有全部数据，而且还有如何显示数据的方法。TodoList组件单纯只是一个显示数据的容器。使用时，将数据和操作显示数据的方法传入TodoList组件。感觉这个模式和自己之前的想法不太一样。之前自己写代码只是考虑组件功能的单一性，单从这个角度我肯定会把显示数据的方法写在TodoList组件里面，这样做完全没有考虑TodoList组件的复用，显然也没有让TodoList组件成为纯粹的样式渲染组件，明显`将函数作为children`模式以及`render props`模式更胜一筹。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function TodoList(&#123; todos, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section className=&apos;main-section&apos;&gt;</span><br><span class="line">      &lt;ul className=&apos;todo-list&apos;&gt;&#123;</span><br><span class="line">        todos.map((todo, i) =&gt; (</span><br><span class="line">          &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const todos = [</span><br><span class="line">    &#123; label: &apos;Write tests&apos;, status: &apos;done&apos; &#125;,</span><br><span class="line">    &#123; label: &apos;Sent report&apos;, status: &apos;progress&apos; &#125;,</span><br><span class="line">    &#123; label: &apos;Answer emails&apos;, status: &apos;done&apos; &#125;</span><br><span class="line">  ];</span><br><span class="line">  const isCompleted = todo =&gt; todo.status === &apos;done&apos;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;TodoList todos=&#123; todos &#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        todo =&gt; isCompleted(todo) ?</span><br><span class="line">          &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; :</span><br><span class="line">          todo.label</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/TodoList&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    这里作者举了他们项目的一个例子：    &gt;最近，我们在工作中使用这种模式，我们必须将某些界面限制只对具有 read:products 权限的用户开放。我们使用的是 render prop 模式。      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Authorize</span><br><span class="line">permissionsInclude=&#123;[ &apos;read:products&apos; ]&#125;</span><br><span class="line">render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure>    这样写组件语义真的好清晰啊,上面的这三行代码不言自明：`Authorize`组件**验证**是否是有（`permissionsInclude`）权限（`[ &apos;read:products&apos; ]`），如果有，则渲染（`render`）产品列表（`&lt;ProductsList /&gt;`）。**这个组件仅靠组件名称、属性名称就完整描述了这个组件的功能，数据和渲染规则来自父组件，具体渲染细节则被封装进单纯的显示组件`Authorize`中。**    哇擦！有些激动！这真的变成代码写的文章了，而不是冗繁的字码，tsubarashi，真的是代码的艺术啊！    **所以今后写组件，不要盲目的用单一性拆分代码，从语义的角度考虑明显更优雅。**</code></pre><ol start="3"><li><p>展示型组件vs容器型组件</p><p> 以现在写的项目为例，<em>配置选型的创建功能</em>使用了三个组件：<code>base</code>,<code>first_step</code>,<code>second_step</code>。其中后两个组件为函数组件，遵循了展示型组件的原则，最大限度的不去管理数据。<code>base</code>组件则为一个混合组件，有几乎全部的业务逻辑，还有一部分组合<code>first_step</code>和<code>second_step</code>两个组件的显示代码，这一部分可以拆出来作为一个独立的组件，这样就会变成一个纯粹的容器型组件。</p></li><li><p>在组件中更新组件外部数据</p><p> 下面的代码中，<code>Store.set.bind(Store)</code>中的<code>bind(Store)</code>是关键。将函数的执行环境和Store对象绑定。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Store = &#123;</span><br><span class="line">  _flag: false,</span><br><span class="line">  set: function(value) &#123;</span><br><span class="line">    this._flag = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return this._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return &lt;Switcher onChange=&#123; Store.set.bind(Store) &#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>双向绑定</p><p> 之前写的代码里，有几处用到了下面这种写法：</p><p> 父组件向子组件传递了一个<strong>能setState的函数</strong>，当子组件满足某个要求时执行这个函数，修改了父组件中的数据，同时子组件的数据完全来源于父组件，当数据有变化时，子组件再次渲染。</p><p> 但上述写法感觉不是双向绑定，双向绑定是相同数据状态存在多处，此刻再进行类似上述操作，数据状态彼此影响，感觉这个是双向绑定。</p></li><li><p>单项数据流</p><p> 将数据状态存储在全局的一个<code>store</code>对象中，这里作为整个应用数据属性更新的唯一地方。感觉这个是理解Redux的关键啊。下面是书中的例子：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//数据状态存储和更新的唯一地点</span><br><span class="line"></span><br><span class="line">var Store = &#123;</span><br><span class="line">  _handlers: [],</span><br><span class="line">  _flag: &apos;&apos;,</span><br><span class="line">  subscribe: function(handler) &#123;</span><br><span class="line">    this._handlers.push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(value) &#123;</span><br><span class="line">    this._flag = value;</span><br><span class="line">    this._handlers.forEach(handler =&gt; handler(value))</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return this._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//状态组件的数据来源依然是store</span><br><span class="line">//这个组件初始化的时候注册了一个本组件修改状态的函数</span><br><span class="line">//然后将最终修改函数Store.set传给子组件，当子组件满足条件时发动</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; value: Store.get() &#125;;</span><br><span class="line">    Store.subscribe(value =&gt; this.setState(&#123; value &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Switcher</span><br><span class="line">          value=&#123; this.state.value &#125;</span><br><span class="line">          onChange=&#123; Store.set.bind(Store) &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Switcher(&#123; value, onChange &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123; e =&gt; onChange(!value) &#125;&gt;</span><br><span class="line">      &#123; value ? &apos;lights on&apos; : &apos;lights off&apos; &#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>感觉这本书里讲redux虽然没有很深入但是很好理解，译文点击<a href="http://sangka-z.com/react-in-patterns-cn/chapter-9/" target="_blank" rel="noopener">此处</a>。</p></li><li><p>React context</p><p> 之前没有用过这个功能，只在redux中有见过<code>Provider</code>，但这个组件来自<code>react-redux</code>。</p><p> 下面这段是文章中对context功能的使用说明：</p><blockquote><p>createContext 返回的对象具有 Provider 和 Consumer 属性。它们实际上是有效的 React 类。Provider 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createContext &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const Context = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">export const Provider = Context.Provider;</span><br><span class="line">export const Consumer = Context.Consumer;</span><br></pre></td></tr></table></figure><p> 使用：</p><ol><li><p>传入context</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from &apos;./context&apos;;</span><br><span class="line"></span><br><span class="line">const context = &#123; title: &apos;React In Patterns&apos; &#125;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider value=&#123; context &#125;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在子组件中使用<code>Comsumer</code></p><p> <strong>Consumer 类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Consumer &#125; from &apos;./context&apos;;</span><br><span class="line"></span><br><span class="line">function Title() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Consumer&gt;&#123;</span><br><span class="line">      (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt;</span><br><span class="line">    &#125;&lt;/Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用模块系统</p><p> 技术：模块创建全局对象+高阶组件</p><p> 描述：之前的项目中，创建数据缓存和router都使用了类似的技术。</p><p> 方法：在创建三个函数和一个存储对象</p><ol><li><p>存储对象</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dependencies = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注册函数用来获取属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export function register(key, dependency) &#123;</span><br><span class="line">dependencies[key] = dependency;</span><br></pre></td></tr></table></figure></li><li><p>获取函数用来拿到需要的值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function fetch(key) &#123;</span><br><span class="line">if (dependencies[key]) return dependencies[key];</span><br><span class="line">throw new Error(`$&#123; key &#125; is not registered as dependency.`);</span><br></pre></td></tr></table></figure></li><li><p>高阶函数用来包装原始组件，获取属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export function wire(Component, deps, mapper) &#123;</span><br><span class="line">  return class Injector extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this._resolvedDependencies = mapper(...deps.map(fetch));</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.state&#125;//这里表示的是Injector这个组件维护的状态，但感觉不太有用的到的机会，这种通用函数因该很少有这样的状态吧</span><br><span class="line">          &#123;...this.props&#125;//父组件传入的属性</span><br><span class="line">          &#123;...this._resolvedDependencies&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React查缺补漏之一——《React官方文档》</title>
      <link href="/2018/06/25/2018-6-25-react%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E4%B8%80/"/>
      <url>/2018/06/25/2018-6-25-react%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>使用React写项目有一个多月了，现返回头重新翻一下官网文档，查缺补漏。</p><a id="more"></a><ol><li><p>使用先前<code>this.state.attr</code>来确定新的属性要使用函数这种第二种状态更新方式。</p><p> <strong>好像自己写的代码有好几处都使用了最常用的方式更新状态，这是错误的！！！</strong></p><p> <img src="/images/react_patch/1.png" alt="第二种更新状态的方式"></p></li><li><p>这里要明确一下绑定类函数的地方</p><p> 事件的回调函数（没有在函数名后加括号的地方），这里想起来之前看到的一篇文章，貌似是阮老师写的，大概意思是函数是独立的，在不同的环境下运行this的指向不同，而事件的回调函数应该也是进入事件队列的，从事件队列被拿到主线程里执行，要保证执行结果就要绑定this的指向。</p></li><li><p>回调函数绑定方法<br> 自己最常用的是在构造函数中使用bind手动绑定，明天要看下箭头函数。使用这种方法，每次初始渲染的时候就会创建一个不同的构造函数。所以，貌似使用bind更保险一些。</p><p> <img src="/images/react_patch/2.png" alt="使用箭头函数绑定this"></p></li><li><p>向事件处理程序传递参数<br> 有两种方法，通常自己常用的是下面使用箭头函数的这种。利用bind可以传递参数的特性也蛮不错的诶，只是自己没有这个意识，以后可以用上。</p><p> <img src="/images/react_patch/3.png" alt="向事件处理程序传递参数的方法"></p><p> 区别：</p><ol><li>使用箭头函数，事件对象e要显式传递</li><li><p>使用bind方法，事件对象e会隐式传递，e要放在参数的最后，如下</p><p><img src="/images/react_patch/4.png" alt="bind方法隐式传递事件对象"></p></li></ol></li><li><p>不参与显示在render中的参数不需要放进<code>this.state</code>中，作为类的静态变量即可</p></li><li><p>哪些参数或状态应该包含在当前组件中，哪些应该作为参数传递进当前组件，现在写的代码有些混乱。感觉要遵循下面的原则：</p><ol><li><p>每个组件尽量完成单一任务，但没必要刻意分割，组件的命名应该是表明当前组件的作用。</p></li><li><p>从语义上判断某个参数是从上层组建传递还是作为当前组件的state的一部分，比如前面的Clock组件，自动更新的状态应该作为组件的一部分。</p></li><li><p>从组建结构判断某个参数是否应该从上层组建传递，比如上层组件有个开关控制按钮。</p></li></ol></li><li><p>渲染多个组件<br> 以前都是直接在主组件中直接写map函数，事实上把map函数生成的多个子元素赋给一个变量是合法有效的，像下面这样。</p><p> <img src="/images/react_patch/5.png" alt="map渲染多个元素"></p><p> 然后在将这个变量包在一个标签中。</p></li><li><p>使用map生成多个兄弟元素时，key的用法</p><p> <strong>数组元素中使用的key在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键。</strong></p><p> <code>key会作为给React的提示，但不会传递给你的组件。如果您的组件中需要使用和key相同的值，请将其作为属性传递。</code>之前写代码就遇到过这个诶。通过事件点击回调函数<code>e.target.getAttribute(&#39;key&#39;)</code>获取不到key值，原来是这样。</p></li><li><p>不能修改传入组件的props的属性</p><p> 这些属性是只读的，在最近写的代码中总是出现修改属性而报错的情况，这个要记住！</p></li><li><p>受控组件</p><p>之前咩有想过可以在捕获值之后再进行处理诶。</p><p>使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。例如，我们如果想限制输入全部是大写字母，我们可以将handleChange 写为如下：</p><p><img src="/images/react_patch/6.png" alt="受控组件"></p></li><li><p>多个输入的解决方法</p><ol><li><p>首先注意一下这个用法：<br> <code>event.target.type/event.target.name</code>不需要使用节点的函数来获取属性值，直接获取是合法有效的！自己写的代码里很多都用了多此一举的函数来获取。</p></li><li><p>状态名和输入框名称属性名一致，然后利用对象属性名的动态方式改变属性。如下用法：</p></li></ol><p><img src="/images/react_patch/7.png" alt="多个输入的解决方法"></p></li><li><p>插播一个不关react的tip</p><p>四舍五入的保留要求的小数位数：<code>const rounded = Math.round(output * 1000) / 1000;</code>使用这种写法会四舍五入后保留小数后三位。因为<code>Math.round()</code>只能保证整数部分精确，乘以1000后，小数点后移三位，经过Math.Round，小数后一位四舍五入进位成整数，再除1000后正好为四舍五入后的小数后三位。</p></li></ol><h4 id="以下三项感觉都使用在构建通用组件中的"><a href="#以下三项感觉都使用在构建通用组件中的" class="headerlink" title="以下三项感觉都使用在构建通用组件中的"></a>以下三项感觉都使用在构建通用组件中的</h4><ol start="13"><li><p>children属性的使用</p><p>自己写的代码里好像从没有主动使用过this.props.children这个属性，官网里展示的例子看起来很方便啊。</p><p>嵌套 JSX 来传递子组件</p><ol><li><p>感觉这个用法一个是在写通用组件的时候用的上，比如现在项目里的各种modal。其他场合为啥要传递子组件？</p><p> <img src="/images/react_patch/8.png" alt="children属性的使用1"><br> <img src="/images/react_patch/9.png" alt="children属性的使用2"></p><p> 如果是我自己写，现在只会想到把数据或者函数作为参数从父组件传递到子组件中，把h1和p两个标签这种结构上的东西移入子组件中。</p></li><li><p>另一个用法是这些组件写在父组件中作为children属性向子组件中传递，可以不用向下传递需要修改数据的函数。感觉可以作为传递函数的一个替代写法。但依然感觉是在写通用组件的时候用的多。</p><p> <img src="/images/react_patch/12.png" alt="children属性的使用3"></p></li><li><p>当传递给自定义组件的子代的是一个函数</p><p> 哇擦，这个牛逼啊，要注意的是组件在React渲染前要将其转换成React能理解的，所以在Repeat中要返回一个div。<strong>这个用法可以用于扩展JSX</strong>，真妥么是神了。</p><p> <img src="/images/react_patch/13.png" alt="children属性的使用4"></p></li></ol></li><li><p>传递组件</p><p><strong>组件可以接受任意元素，包括基本数据类型、React 元素或函数。</strong>之前完全没有想过要这样用。<br><img src="/images/react_patch/10.png" alt="传递组件"></p></li><li><p>通过配置属性用较特殊的组件来渲染较通用的组件</p><p>现在写的项目里使用modal通用组件的时候通常会带一个<code>config.js</code>的配置文件，就是用来作为通用组件<code>modal</code>的属性进行传递的。</p><p><img src="/images/react_patch/11.png" alt="配置属性渲染通用组件"></p></li><li><p>如果要在组件之间复用 UI 无关的功能，我们建议将其提取到单独的 JavaScript 模块中。这样可以在不对组件进行扩展的前提下导入并使用该函数、对象或类。<em>现在写组件就在这么用。</em></p></li><li><p>JSX中标签的编译</p><p><code>&lt;div className=&quot;sidebar&quot;&gt;</code>会被编译为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">&apos;div&apos;,</span><br><span class="line">&#123;className: &apos;sidebar&#125;,</span><br><span class="line">null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之前一直认为JSX中的div标签和dom中的div标签没有区别。</p></li><li><p>JSX中一对闭合标签中的内容会被转译为<strong>HTML非转义字符串</strong></p></li><li><p>布尔值，Null， Undefined在渲染中会被忽略。</p><ol><li><p>这个有在现在的项目中遇到。</p></li><li><p><strong>这个可以用在条件渲染中。</strong> 如果showHeader为true，那么会渲染出<code>&lt;Header /&gt;</code>组件，为假则不会渲染出来，<code>&lt;Content /&gt;</code>组件则一直会渲染出来。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&#123;showHeader &amp;&amp; &lt;Header /&gt;&#125;</span><br><span class="line">&lt;Content /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果你想让类似 false、true、null 或 undefined 出现在输出中，你必须先把它转成字符串。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  My JavaScript variable is &#123;String(myVariable)&#125;.</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用refs</p><ol><li><p>当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。</p><p> React 会在组件加载时将 DOM 元素传入 current 属性，在卸载时则会改回 null。ref 的更新会发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前。</p></li><li><p>当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。</p></li><li><p>不能在函数式组件上使用 ref 属性，因为它们没有实例。</p></li><li><p>可以在函数式组件内部使用 ref，只要它指向一个 DOM 元素或者 class 组件。</p><p> <img src="/images/react_patch/14.png" alt="refs用于函数组件内部"></p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的软件收集处</title>
      <link href="/2018/04/14/2018-4-14-%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
      <url>/2018/04/14/2018-4-14-%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><p>开发类</p><ul><li><p>vs code</p><ul><li>配色主题：one dark pro</li><li>图标主题：vscode great icons</li></ul></li></ul></li></ul><a id="more"></a><ul><li><p>zeal</p><p>离线文档（这个好好用）</p></li></ul><ul><li><p>应用类</p><ul><li>终端英汉词典：ydcv<ul><li>克隆地址：<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:felixonmars/ydcv.git`</li><li>安装：<code>sudo python setup.py install</code></li><li>设置快捷别名：<a href="https://blog.csdn.net/u011630575/article/details/48030663" target="_blank" rel="noopener">参考这里</a></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reStructuredText语法</title>
      <link href="/2017/11/20/reStructuredText/"/>
      <url>/2017/11/20/reStructuredText/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html" target="_blank" rel="noopener">reStructuredText官网-使用手册</a></li><li><a href="http://docutils.sourceforge.net/docs/user/rst/quickstart.html" target="_blank" rel="noopener">reStructuredTex官方语法</a></li><li><a href="http://www.pythondoc.com/sphinx/markup/toctree.html" target="_blank" rel="noopener">关于TOC树</a></li><li><a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a></li><li><a href="http://blog.csdn.net/u012150179/article/details/37743605" target="_blank" rel="noopener">博客2</a></li><li><a href="http://www.jianshu.com/p/1885d5570b37" target="_blank" rel="noopener">博客3</a></li></ol><a id="more"></a><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>一般语法可以参考上述所有资料，本文记录reStructedText的特殊语法。</p><h3 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h3><ul><li><p>文档内链接跳转语法</p><ol><li><p>在目标前 标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.. highlight:: rst</span><br><span class="line">.. _3.1.1 云主机服务:</span><br></pre></td></tr></table></figure><p>..后有一个空格，::后有一个空格</p></li><li><p>在起始处 标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ref:`“3.4.1 报警” &lt;3.4.1 报警&gt;`</span><br></pre></td></tr></table></figure><p>前后各有一个空格，&lt;&gt;前有一个空格</p></li></ol></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>实际使用中发现，生成的pdf里，表格中的内容如果是以下划线连接的文字、斜杠连接的文字，表格在宽度不够的情况下无法自动分割文字至多行来适应有限的宽度。（也可能行数超过30行，但目前写的文档最后一列可以自动分割，推测是上述原因）</p><ul><li>写表格使用vim配合vim-table-mode插件。<ul><li>安装：<ol><li>首先安装<strong><a href="https://github.com/Shougo/neobundle.vim" target="_blank" rel="noopener">NeoBundle</a></strong> ；<ul><li>注意：.vimrc文件要自己创建，内容可以复制官方文档中给出的内容。</li></ul></li><li>调出vim，执行<code>:NeoBundleInstall</code> 在官方文档上有说明；</li><li>在<strong>~/.vimrc</strong>文档中添加<code>NeoBundle &#39;dhruvasagar/vim-table-mode&#39;</code> ；</li></ol></li><li>使用：vim界面输入<code>:TableModeToggle</code> 开启表格模式，接着分别输入<code>let g:table_mode_corner_corner=&#39;+&#39;</code> 以及<code>let g:table_mode_header_fillchar=&#39;=&#39;</code> 进入reStructuredText模式。详细使用见<a href="https://github.com/dhruvasagar/vim-table-mode" target="_blank" rel="noopener">官方文档</a> 。</li><li>修改：如果是重新打开文档，那么修改前要输入上述三个命令，进入正确的模式。<strong>修改只要修改内容，不用管边框是否对齐，不要手动调整！vim-table-mode插件会自动补齐。</strong></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> reStructuredText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sphinx</title>
      <link href="/2017/11/20/sphinx/"/>
      <url>/2017/11/20/sphinx/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.sphinx-doc.org/en/stable/contents.html" target="_blank" rel="noopener">sphinx官方-主页</a></li><li><a href="http://www.sphinx-doc.org/en/stable/config.html" target="_blank" rel="noopener">sphinx官方-config.py</a> ：生成html、latex以及转换成pdf的多数格式均在这个文件里进行配置</li><li><a href="http://www.sphinx-doc.org/en/stable/theming.html#builtin-themes" target="_blank" rel="noopener">sphtinx官方-模板</a>：本次使用第三方模板 <em>sphinx_rtd_theme</em></li><li><a href="http://www.sphinx-doc.org/en/stable/latex.html" target="_blank" rel="noopener">sphinx官方-latex输出配置说明</a></li><li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/invocation.html" target="_blank" rel="noopener">sphinx官方-创建指令</a></li><li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/invocation.html" target="_blank" rel="noopener">sphinx使用手册中文译文</a></li><li><a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a>：环境搭建、快速构建</li></ol><a id="more"></a><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>环境搭建参考<a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a>。</p><ol><li>安装python</li><li>安装sphinx</li><li>安装textlive（可选）</li><li>安装汉字字体（可选）<ul><li>以装宋体为例（<a href="http://blog.csdn.net/wxwpxh/article/details/50532363" target="_blank" rel="noopener">simsun.ttc</a>），字体文件要注意是否可用</li></ul></li><li>安装第三方模板（可选）</li></ol><h3 id="构建文档"><a href="#构建文档" class="headerlink" title="构建文档"></a>构建文档</h3><p>快速构建参考<a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a> 。</p><h3 id="文档结构配置"><a href="#文档结构配置" class="headerlink" title="文档结构配置"></a>文档结构配置</h3><ul><li><p>入口文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :hidden:</span><br><span class="line"></span><br><span class="line">   README</span><br><span class="line">   book/UOS4.0介绍</span><br><span class="line">   book/快速入门/index</span><br><span class="line">   book/UOS项目平台/index</span><br><span class="line">   book/UOS管理平台/index</span><br><span class="line">   book/UOS计费系统/index</span><br><span class="line">   book/UOS审批系统/index</span><br><span class="line">   book/UOS存储平台/index</span><br><span class="line">   book/UOS工单系统/index</span><br></pre></td></tr></table></figure><ul><li><code>.. toctree::</code>：这个指令用来设置文档组织结构，其中<ul><li><code>:maxdepth: 2</code> ：用来设置目录显示层级</li><li><code>:hidden: 用来设置是否在每个主页（index）中显示该目录</code></li><li><code>:number:</code>用来设置是否在目录前列出编号</li><li><code>:caption: 目录</code>用来修改在pdf中index前显示的文字，更多设置详见<a href="http://www.sphinx-doc.org/en/stable/markup/toctree.html#toctree-directive" target="_blank" rel="noopener">官方配置文档</a> </li></ul></li><li>下面的部分表示组织起来的结构，这里分别是各个章节的主页，会显示章节标题。每个章节的主页中再以此种形式列出各自的结构组织。</li></ul></li></ul><h3 id="config-py配置选项"><a href="#config-py配置选项" class="headerlink" title="config.py配置选项"></a>config.py配置选项</h3><ul><li><p>值得注意的通用配置</p><ol><li>文档格式：<code>source_suffix = &#39;.rst&#39;</code></li><li>编码类型（中文一定要用这个）：<code>source_encoding = &#39;utf-8&#39;</code></li><li>文档入口：<code>master_doc = &#39;index&#39;</code>       </li></ol></li><li><p>值得注意的html输出配置</p><ul><li>使用第三方模板（可以参考<a href="http://www.sphinx-doc.org/en/stable/theming.html#builtin-themes" target="_blank" rel="noopener">sphtinx官方-模板</a> 、<a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a>）<ol><li>文档开头：<code>import sphinx_rtd_theme</code></li><li>“Options for HTML output”部分：<code>html_theme = &#39;sphinx_rtd_theme&#39;</code></li></ol></li><li>html_sidebars: html侧边栏显示（可以参考<a href="http://www.sphinx-doc.org/en/stable/theming.html#builtin-themes" target="_blank" rel="noopener">sphtinx官方-模板</a>）</li><li>不显示文档源文件： <code>html_show_sourcelink = False</code></li><li>不在底边显示“sphinx创建”字样： <code>html_show_sphinx = False</code></li></ul></li><li><p>latex输出配置1（用于转换pdf）</p><ul><li><p>处理引擎配置：<code>latex_engine = &#39;xelatex&#39;</code></p></li><li><p>latex_elements配置中：</p><ul><li><p>纸张大小： <code>&#39;papersize&#39;: &#39;a4paper&#39;</code></p></li><li><p>字体大小： <code>&#39;pointsize&#39;: &#39;10pt&#39;</code></p></li><li><p>preamble配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">\\usepackage&#123;xeCJK&#125;</span><br><span class="line">\\usepackage&#123;indentfirst&#125;</span><br><span class="line">\\setlength&#123;\\parindent&#125;&#123;2em&#125;</span><br><span class="line">\\setCJKmainfont&#123;SimSun&#125; #针对中文使用中文字体</span><br><span class="line">\\setCJKmonofont[Scale=0.9]&#123;SimSun&#125;</span><br><span class="line">\\setCJKfamilyfont&#123;song&#125;&#123;SimSun&#125;</span><br><span class="line">\\setCJKfamilyfont&#123;sf&#125;&#123;SimSun&#125;</span><br><span class="line">\\XeTeXlinebreakskip = 0pt plus 1pt</span><br><span class="line">\\setcounter&#123;tocdepth&#125;&#123;2&#125; #目录显示的层级</span><br><span class="line">    \\setcounter&#123;secnumdepth&#125;&#123;0&#125; #文档中标题前显示的编号等级</span><br><span class="line">    &apos;&apos;&apos;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单页输出： <code>&#39;classoptions&#39;: &#39;,oneside&#39;</code></p></li><li><p>章节样式：<code>&#39;fncychap&#39;: &#39;&#39;</code>空字符不使用章节</p></li><li><p>latex_documents配置的最后一项： 使用<code>&#39;howto&#39;</code> ，chm格式。</p></li></ul></li><li><p>latex输出配置2（用于输出pdf）</p><p>latex输出配置1输出的pdf不带页码，为了解决这个问题：</p><ul><li>增加：<code>latex_toplevel_sectioning = &#39;section&#39;</code></li><li>修改：’howto’改为’manual’</li></ul><p>关于latex配置选项，详见：<a href="http://www.sphinx-doc.org/en/stable/latex.html" target="_blank" rel="noopener">官方配置文档1</a>和<a href="http://www.sphinx-doc.org/en/stable/config.html#confval-latex_additional_files" target="_blank" rel="noopener">官方配置文档2</a> 。</p></li></ul><h3 id="表格配置"><a href="#表格配置" class="headerlink" title="表格配置"></a>表格配置</h3><p>表格配置指令使用：<code>.. tabularcolumns::</code> <code>column spec</code> ，放在表格所在文档表格前，详见：<a href="http://www.sphinx-doc.org/en/stable/markup/misc.html#tables" target="_blank" rel="noopener">官方配置文档</a> 。<strong>注意：超过30行的表格latex无法自动控制宽度，可以使用p{width}手动控制</strong> 。</p><h3 id="转换pdf指令"><a href="#转换pdf指令" class="headerlink" title="转换pdf指令"></a>转换pdf指令</h3><p>首先生成latex文档，之后使用xelatex（主要是为了处理中文）生成pdf，第二次使用xelatex为了生成pdf文档目录和文档中的连接。</p><ol><li>make latex</li><li>cd build/latex</li><li>xelatex *.tex</li><li>xelatex *.tex</li></ol><h3 id="关于转换pdf的方法"><a href="#关于转换pdf的方法" class="headerlink" title="关于转换pdf的方法"></a>关于转换pdf的方法</h3><p>试用过四种方法，只有xelatex成功。以下是其他三种未成功的方法：</p><ol><li>latexpdf指令：生成文档错误，未继续；</li><li>借用rst2pdf：sphinx官网上有说rst2pdf已停止维护，针对最新版可能有问题，实际使用中英文能够正常显示，中文显示未乱码，即便编码规则设定为utf-8依然不能正常显示；</li><li>借用rinohtype：sphinx官方推荐的一种直接转换pdf的方法。但实际使用中发现转换时间过长，且依然没有能处理好中文显示的问题。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> sphinx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu系统使用记录</title>
      <link href="/2017/11/20/ubuntu%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/11/20/ubuntu%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文是ubuntu使用方法汇总。</strong></p><a id="more"></a><h3 id="资料列表"><a href="#资料列表" class="headerlink" title="资料列表"></a>资料列表</h3><ol><li><a href="https://jingyan.baidu.com/article/60ccbceb18624464cab197ea.html" target="_blank" rel="noopener">双系统安装</a></li><li><a href="http://www.jianshu.com/p/2b24cd430a7d" target="_blank" rel="noopener">ubuntu下安装nodejs</a></li><li><a href="http://blog.csdn.net/txl910514/article/details/52136821" target="_blank" rel="noopener">ubuntu安装webstorm</a></li><li><a href="https://www.cnblogs.com/netfoxman/p/5994697.html" target="_blank" rel="noopener">ubuntu下多个python版本切换</a></li><li><a href="http://blog.csdn.net/wangjingfei/article/details/5614203" target="_blank" rel="noopener">ubuntu安装中文字体</a></li><li><a href="http://blog.csdn.net/kevinhg/article/details/5934462" target="_blank" rel="noopener">ubuntu下deb包的安装方法</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">ubuntu下科学上网配置</a></li><li><a href="https://blog.csdn.net/u011630575/article/details/48030663" target="_blank" rel="noopener">ubuntu下给指令设置别名</a></li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><p>上述第7个链接只是<strong>shadowsocks-qt5</strong>的安装，火狐浏览器安装FoxyProxy Standard插件，并进行如下配置：</p><ul><li>Proxy Type: SOCKS5</li><li>IP address: 127.0.0.1</li><li>Port: 1080</li></ul></li></ol><h3 id="系统问题"><a href="#系统问题" class="headerlink" title="系统问题"></a>系统问题</h3><ol><li><p><strong>Kernel Panic -not syncing:VFS:Unable to mount foot fs on Unknown-block(0,0)</strong></p><ul><li>症状： 开机启动卡在紫色界面无法进入桌面，在重启后自动运行一系列代码，最后出现上述错误</li><li>原因： 查到的相关信息表明是由于系统的什么核升级没有升级完全导致</li><li>参考： <a href="https://askubuntu.com/questions/41930/kernel-panic-not-syncing-vfs-unable-to-mount-root-fs-on-unknown-block0-0" target="_blank" rel="noopener">Kernel Panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</a></li><li>解决办法：<ol><li>在选择系统的界面进入ubuntu高级选项，然后尝试各个可用版本的<code>recover mode</code>;</li><li>进入<code>recover mode</code>后，不需要点击任何选项，直接<code>tab</code>键进入最下面，点<code>enter</code>，之后可能还得<code>enter</code>，然后会自动执行一串命令行代码，进入当前版本的桌面；</li><li>启动终端；</li><li><code>uname -r</code>查看当前版本；</li><li><code>update-initramfs -u -k version</code>重新恢复/升级安装当前版本</li><li><code>update-grub</code>更新grub</li></ol></li></ul></li><li><p><strong>stdout no space left on device</strong></p><ul><li>症状： 恢复上述版本安装的时候可能会出现这个错误，怀疑平时更新不成功说没有地方也是这个原因。<strong>这个叫移除ubuntu系统中旧版内核，搜索可以这样搜</strong>。</li><li>原因： 就是某个盘给的空间可能小了，然后还存在多个版本，地儿不够，以后再说吧，懒得整</li><li>参考：<br><a href="https://askubuntu.com/questions/929305/gzip-stdout-no-space-left-on-device-e-mkinitramfs-failure-cpio-141-gzip-1/929681#929681" target="_blank" rel="noopener">gzip: stdout: No space left on device E: mkinitramfs failure cpio 141 gzip</a><br><a href="https://askubuntu.com/questions/223248/gzip-stdout-no-space-left-on-device-while-upgrading-the-kernel" target="_blank" rel="noopener">gzip: stdout: No space left on device” while upgrading the kernel</a></li><li>解决办法：<ol><li><code>uname -r</code>查看当前版本；</li><li><code>ls /boot</code>查看所有版本；</li><li><code>sudo apt-get autoremove linux-image-old-version</code>删除不需要的版本释放空间</li></ol></li></ul></li><li><p><strong>启动桌面不显示工具栏</strong></p><ol><li><p>尝试重启，依次输入下面的命令<br><code>ctrl_alt+f1</code></p><p><code>sudo service lightdm restart</code></p></li><li><p>重启不行就重装unity（这是个what），依次输入下面的命令<br><code>sudo apt-get update</code></p><p><code>sudo apt-get install --reinstall ubuntu-desktop</code></p><p><code>sudo apt-get install unity</code></p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习</title>
      <link href="/2017/07/24/D3%20learn/"/>
      <url>/2017/07/24/D3%20learn/</url>
      
        <content type="html"><![CDATA[<p>这篇是D3的学习总结。由于Freecodecamp的D3新版教程还没有上线，D3的基础学习资料是自己从网上搜集来跟着学的，然后完成了Freecodecamp上的5个小项目。</p><a id="more"></a><h3 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h3><ol><li><p><a href="https://github.com/d3/d3/wiki/Tutorials" target="_blank" rel="noopener">这里</a>是D3官方给出的一些教程，我看了Introductions &amp; Core Concepts部分的前10篇，全部是D3的作者Mike Bostock大神写，其中<a href="https://bost.ocks.org/mike/join/" target="_blank" rel="noopener">Thinking with Joins</a>以及<a href="https://bost.ocks.org/mike/selection/" target="_blank" rel="noopener">How Selections Work</a>这两篇看过之后豁然开朗，大概明白了D3为何要写成这样，比如先引用不存在的节点再创造节点。D3做出来的东西真的很惊艳，是我最喜欢的一个库（虽然我也没接触几个…）。<a href="https://codepen.io/ginnko/pen/MoqwPr" target="_blank" rel="noopener">basic bar</a>、<a href="https://codepen.io/ginnko/pen/bRmorb" target="_blank" rel="noopener">letter frequencies</a>、<a href="https://codepen.io/ginnko/pen/GEwqxp" target="_blank" rel="noopener">general update 1</a>、<a href="https://codepen.io/ginnko/pen/YQRGNG" target="_blank" rel="noopener">general update 2</a>、<a href="https://codepen.io/ginnko/pen/eRQdxY" target="_blank" rel="noopener">general update 3</a>、<a href="https://codepen.io/ginnko/pen/pwxVGM" target="_blank" rel="noopener">circle</a>这6个练习是跟着Mike Bostock大神的教程自己敲进去的代码实现。上述给出的教程链接感觉很重要，日后遗忘可以进行参考。</p></li><li><p>使用codepen写练习有时需要外部获取数据文件，比如图片、json文件、tsv文件。对于图片，使用google drive和dropbox均可以达到目的，google drive使用<a href="http://gdurl.com/" target="_blank" rel="noopener">gdurl</a>或<a href="https://sites.google.com/site/gdocs2direct/" target="_blank" rel="noopener">这个</a>均可以生成永久链接（gdurl有时会生成http形式的链接，在codepen中无法使用）。而json文件、tsv文件存储在google drive中无法使用ajax技术获取，目前的办法是存储在dropbox，生成分享链接，稍作修改，作为最后的url。<br>正确的url: <code>https://dl.dropboxusercontent.com/s/</code> + <strong>hfgg7cdoedkv1he/ky-counties.json(dropbox生成的链接中包含这部分，相应替换)</strong> + <code>?dl=1</code>。</p></li><li><p>这里插一段题外话，这三个月的自学让自己发现，那种从非常基础的底层理论入手，全面学习后再进行各项练习的学习方法或许真的不适合自己，当然这也是对特定的学科，特定阶段而言。比如学习语法，就需要全面了解一下常用基础语法，才能顺利进行下一步。但是更重要的进一步的提升需要的是大量的练习，从目的出发，反向学习需要的东西，更有效率。目前发现对于语言（机器语言、自然语言）的学习，这种方法对自己特别有效。但对于写程序而言，这么说似乎有些耍小聪明，毕竟计算机科学是一套完整的理论的体系，还有大量的基础等着我去学习，任重道远。</p></li></ol><p>下面是freecodecamp中的5个项目练习，主要记录自己遇到的一些问题，解决办法，没有解决的问题以及一些感想。</p><h3 id="Visualize-Data-with-a-Bar-Chart"><a href="#Visualize-Data-with-a-Bar-Chart" class="headerlink" title="Visualize Data with a Bar Chart"></a><a href="https://codepen.io/ginnko/full/YQRgxM/" target="_blank" rel="noopener">Visualize Data with a Bar Chart</a></h3><p>这个项目是利用D3做了一张柱状图，涉及的是D3的基本的标准使用方法。  </p><ul><li><strong>引用的库：</strong> d3标准库和d3-tip库  </li><li><strong>过程：</strong> 1. 准备阶段：获取json文件的url、数据转换方式、图纸大小、坐标轴的比例和转换；2.画图阶段：利用d3.json获取数据，完善坐标轴标尺，绘制图形、坐标轴、标题等。  </li><li><p><strong>遇到的问题：</strong><br>1.时间数据的转换<br><code>var parseTime = d3.timeParse(&quot;%Y-%m-%d&quot;);</code><br><code>var timeFormat = d3.timeFormat(%Y-%m);</code><br>利用上面两行代码将以string格式表示的时间数据和js中的时间类型相互转换，更多的转换类型点击<a href="https://github.com/d3/d3-scale/blob/master/README.md#band_bandwidth" target="_blank" rel="noopener">这里</a>。可以在使用数据前统一对数据进行预处理，如下。</p><pre><code>var data = json.data;data.forEach(function(d){d[0] = parseTime(d[0]);d[1] = +d[1];});</code></pre><p>2.比例尺<br>这个项目使用了三种比例尺，时间、线性、序数比例尺，对应d3.scaleTime(用来设置横坐标轴)、d3.scaleLinear（用来设置纵坐标轴以及图形的y值定位）以及d3.scaleBand（用来设置图形的宽度以及图形x值定位）。同时利用<strong>d3.scaleBand</strong>和<strong>d3.scaleTime</strong>来进行图形x方向定位和宽度设置时，图纸宽度的选择是关键！<code>图纸有效宽度/数据数量 = 一个整数</code>，否则画出的bar之间会有间距。其实，只是用d3.scaleBand可以实现目的，在后面的项目中有用法。<br>3.绑定问题<br>将g绑定到svg后，再绑定数据时，不用使用tag名称，会出现数据绑定不全的问题，此时应使用class名称来绑定。具体原因没有找到说法。  </p></li></ul><h3 id="Visualize-Data-with-a-Scatterplot-Graph"><a href="#Visualize-Data-with-a-Scatterplot-Graph" class="headerlink" title="Visualize Data with a Scatterplot Graph "></a><a href="https://codepen.io/ginnko/pen/mwvmdW" target="_blank" rel="noopener">Visualize Data with a Scatterplot Graph </a></h3><p>这个项目的图形是用circle表示的，和bar大同小异。  </p><ul><li><strong>遇到的问题</strong><br>1.在固定的位置用来显示tip：先创建一个固定位置，然后在具体操作代码处稍作调整。<br>创建固定位置：  <pre><code>chart.call(tip);var show = chart.append(&quot;g&quot;).attr(&quot;id&quot;, &quot;show&quot;).attr(&quot;cx&quot;, &quot;5&quot;).attr(&quot;cy&quot;, &quot;5&quot;);</code></pre>调整代码：<br><code>.on(&quot;mouseover&quot;, function(d){tip.show(d,document.getElementById(&quot;show&quot;))})</code></li></ul><h3 id="Visualize-Data-with-a-Heat-Map"><a href="#Visualize-Data-with-a-Heat-Map" class="headerlink" title="Visualize Data with a Heat Map "></a><a href="https://codepen.io/ginnko/pen/bRZeWy?editors=0010" target="_blank" rel="noopener">Visualize Data with a Heat Map </a></h3><p>这个项目用来表示地表温度，画出来有些震撼，基本没有遇到难点。  </p><h3 id="Show-National-Contiguity-with-a-Force-Directed-Graph"><a href="#Show-National-Contiguity-with-a-Force-Directed-Graph" class="headerlink" title="Show National Contiguity with a Force Directed Graph "></a><a href="https://codepen.io/ginnko/pen/xreaEp" target="_blank" rel="noopener">Show National Contiguity with a Force Directed Graph </a></h3><p>这张图使用了d3的force layout。说实话，对force layout的学习并不深入，很多东西还不太明白，此处只记录了force的基本实现过程，其他同上。  </p><ul><li><strong>引用的库：</strong>d3标准库  </li><li><strong>参考文档：</strong><a href="https://github.com/d3/d3/blob/master/API.md#forces-d3-force" target="_blank" rel="noopener">官方文档</a>、<a href="https://bl.ocks.org/mbostock/f584aa36df54c451c94a9d0798caed35" target="_blank" rel="noopener">实例1</a>、<a href="https://bl.ocks.org/mbostock/950642" target="_blank" rel="noopener">实例2</a>、<a href="https://css-tricks.com/css-sprites/" target="_blank" rel="noopener">sprite</a>  </li><li><p><strong>注意：</strong><br>1.div使用left、right属性来定位<br>2.为了在svg中使用css-sprite, link和node要放在同一个div内<br>html：</p><pre><code>&lt;div id=&quot;root&quot; width=&quot;900px&quot; height=&quot;600px&quot;&gt;  &lt;h2&gt;Force Directed Graph of State Contiguity&lt;/h2&gt;  &lt;div id=&quot;node&quot; &gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>js:</p><pre><code>var link = svg.append(&quot;g&quot;).attr(&quot;class&quot;, &quot;links&quot;).selectAll(&quot;line&quot;).data(graph.links).enter().append(&quot;line&quot;).attr(&quot;stroke-width&quot;, 1);var node = d3.select(&quot;#node&quot;).selectAll(&quot;.flag&quot;).data(graph.nodes).enter().append(&quot;div&quot;).attr(&quot;class&quot;, function(d){  return &quot;flag flag-&quot; + d.code;})</code></pre><p>2.这个练习没有使用d3-tip库来实现tooltip，方法如下</p><pre><code>var tip = d3.select(&quot;#root&quot;).append(&quot;div&quot;).attr(&quot;class&quot;, &quot;tooltip&quot;).style(&quot;opacity&quot;, 0);  ....on(&quot;mouseover&quot;, function(d) {  tip.transition()    .duration(200)    .style(&quot;opacity&quot;, .9);  tip.html(d.country)    .style(&quot;left&quot;, (d3.event.pageX) + &quot;px&quot;)    .style(&quot;top&quot;, (d3.event.pageY) + &quot;px&quot;);}).on(&quot;mouseout&quot;, function(d) {  tip.transition()    .style(&quot;opacity&quot;, 0);</code></pre><p>3.css的设置，涉及绝对位置显示和居中的问题</p><pre><code>svg{  border: 1px black solid;  display: block;  margin: auto;}#node{  position: absolute;  margin:auto;  width: 900px;  left: 0;  right: 0;}div.tooltip {  position: absolute;  text-align: center;  padding: 2px;  font: 12px sans-serif;  color: white;  background: steelblue;  border: 0px;  border-radius: 8px;  pointer-events: none;}.flag {    position: absolute;    width: 16px;    height: 11px;    background: url(&apos;http://gdurl.com/R0x1&apos;) no-repeat;}</code></pre></li><li><p><strong>过程：</strong><br>1.创建一个force模拟对象</p><pre><code>var simulation = d3.forceSimulation().force(&quot;link&quot;, d3.forceLink().id(function(d){return d.index;})).force(&quot;charge&quot;, d3.forceManyBody()).force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2)).force(&quot;y&quot;, d3.forceY(0)).force(&quot;x&quot;, d3.forceX(0));</code></pre><p>2.数据绑定</p><pre><code>simulation  .nodes(graph.nodes)  .on(&quot;tick&quot;, ticked);simulation.force(&quot;link&quot;)  .links(graph.links);</code></pre><p>3.正常创建link和node</p><pre><code>var link = svg.append(&quot;g&quot;).attr(&quot;class&quot;, &quot;links&quot;).selectAll(&quot;line&quot;).data(graph.links).enter().append(&quot;line&quot;).attr(&quot;stroke-width&quot;, 1);var node = d3.select(&quot;#node&quot;).selectAll(&quot;.flag&quot;).data(graph.nodes).enter().append(&quot;div&quot;).attr(&quot;class&quot;, function(d){  return &quot;flag flag-&quot; + d.code;}).call(d3.drag()      .on(&quot;start&quot;, dragstarted)      .on(&quot;drag&quot;, dragged)      .on(&quot;end&quot;, dragended)).on(&quot;mouseover&quot;, function(d) {  tip.transition()    .duration(200)    .style(&quot;opacity&quot;, .9);  tip.html(d.country)    .style(&quot;left&quot;, (d3.event.pageX) + &quot;px&quot;)    .style(&quot;top&quot;, (d3.event.pageY) + &quot;px&quot;);}).on(&quot;mouseout&quot;, function(d) {  tip.transition()    .style(&quot;opacity&quot;, 0);</code></pre><p>4.对node和link的操作</p><pre><code>  function ticked(){  link    .attr(&quot;x1&quot;, function(d){return d.source.x;})    .attr(&quot;y1&quot;, function(d){return d.source.y;})    .attr(&quot;x2&quot;, function(d){return d.target.x;})    .attr(&quot;y2&quot;, function(d){return d.target.y;});  node    .style(&quot;left&quot;, function(d){return d.x + &quot;px&quot;;})    .style(&quot;top&quot;, function(d){return d.y + &quot;px&quot;;});}</code></pre><h3 id="Map-data-across-the-globe"><a href="#Map-data-across-the-globe" class="headerlink" title="Map data across the globe"></a><a href="https://codepen.io/ginnko/pen/LLwyvv" target="_blank" rel="noopener">Map data across the globe</a></h3><p>使用D3来绘制地图，做完这个项目，我意识到D3绘图是一层一层画的，不同的内容位于不同的图层，后画的内容显示在上层。开始做项目之前，先跟着下面的两个教程预热了一下，画了<a href="https://codepen.io/ginnko/pen/yXdYQd" target="_blank" rel="noopener">波士顿老鼠分布地图</a>和<a href="https://codepen.io/ginnko/pen/gRNzRB" target="_blank" rel="noopener">美国失业情况地图</a>。  </p></li><li><strong>教程：</strong><a href="https://github.com/topojson/topojson/wiki/Gallery" target="_blank" rel="noopener">地图gallery</a>，<a href="http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/" target="_blank" rel="noopener">DUSPviz</a>  </li><li><strong>涉及的库：</strong>D3标准库，topojson库，D3 queue库  </li><li><strong>重要概念：</strong>1.projection: 自己理解为某种模板，用来处理地理坐标和图纸坐标的关系；2.topojson：用来处理数据的一种方法，主要用了其中的topojson.feature()（用来转换数据）和topojson.mesh()（转换同时筛选数据）；3.queue：用于下载完所需的全部数据再执行后续的操作。  </li><li><strong>过程：</strong> 1.基本设置；2.画地图；3.添加陨石数据；4；添加zoom  </li><li><p><strong>遇到的问题：</strong><br>1.大圆遮挡了小圆<br>使用sort方法对数据进行了从大到小的排序，利用后画的图形在上层的特点。</p><pre><code>data.sort(function(a, b){  if(a.properties.mass &gt; b.properties.mass)    return -1;  else if(a.properties.mass &lt; b.properties.mass)    return 1;  return 0;});  </code></pre><p>2.append数据时，遇到null的情况处理办法</p><pre><code>.attr(&quot;cx&quot;, function(m){return m.geometry == null ? projection([0, 0])[0] : projection(m.geometry.coordinates)[0];}).attr(&quot;cy&quot;, function(m){return m.geometry == null ? projection([0, 0])[0] : projection(m.geometry.coordinates)[1];}).attr(&quot;fill&quot;, function(m, i){return color(i);}).attr(&quot;r&quot;, function(m){return m.geometry == null ? 0 : size(Math.sqrt(m.properties.mass));})  </code></pre><p>3.使用zoom</p><pre><code>var zoom = d3.zoom().scaleExtent([1, 8]).on(&quot;zoom&quot;, zoomed);function zoomed(){  var transform = d3.zoomTransform(this);  g.attr(&quot;transform&quot;, transform);  d3.selectAll(&quot;circle&quot;).attr(&quot;transform&quot;, transform);}svg.call(zoom);  </code></pre><p>4.svg的居中</p><pre><code>svg  border: 1px solid black  display: block  margin: auto</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习</title>
      <link href="/2017/06/19/React%20learn/"/>
      <url>/2017/06/19/React%20learn/</url>
      
        <content type="html"><![CDATA[<p>这篇是React入门的学习总结，主要参考阮一峰大神的教程（如下）和官方文档，用codepen完成了教程里的<a href="https://codepen.io/ginnko/pen/EXWaaw" target="_blank" rel="noopener">demo</a>。</p><a id="more"></a><h2 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h2><h3 id="1-资料"><a href="#1-资料" class="headerlink" title="1. 资料"></a>1. 资料</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮大角虫的教程</a></li><li><a href="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="noopener">官网</a></li><li><a href="https://codepen.io/gaearon/#" target="_blank" rel="noopener">Dan Abramov大神的实例</a></li></ul><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h3><ul><li><p>不太清楚React具体能做什么</p><blockquote><p>通过这段时间的练习，感觉React确实很适合UI，大神们说的没错。</p></blockquote></li><li><p>教程里有个使用Promise的例子，虽然明白Promise最主要的有点就是将执行过程和结果分开，但是并没有觉得这有什么特别好处，只是看起来更清晰了？关于Promise的部分参考了<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">廖大角虫的教程</a>。</p></li><li><p>当使用setInterval()和Ajax的同时使用了bind（）函数，不太理解这个地方。</p><blockquote><p>bind(this)是将当前作用域传入相应的函数，在ES6中被要求要明确的表示，因为不再自动匹配，在下面的<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">“是否使用ES6的方法对比”</a>中有说明。  </p></blockquote></li><li><p>receive box这个应用中，自己写的代码是把所有的功能放进一个组件类中，别人的代码是像函数那样将完成一个功能的代码组合放进一个单独的组件类，在其他组件类中进行调用。后面的练习要使用这种方式。</p></li></ul><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><ul><li>组件类的变量名的首字母要<strong>大写</strong>！！！</li><li>rent中的顶级标签只能有一个，所以示例中的全部用<div>标签包裹</div></li><li>关于<a href="https://facebook.github.io/react/docs/handling-events.html" target="_blank" rel="noopener">handle事件和this</a><br>如果一个方法后面没有直接跟着一个括号，就要手动绑定this和这个方法。解决办法有三：  <blockquote><ol><li>手动在constructor方法里绑定，例如：this.handleClick = this.handleClick.bind(this);</li><li>使用属性初始化语法 handleClick = () =&gt;{//其他代码}<strong>结束没有分号</strong></li><li>使用箭头函数，前面不需要事先绑定或使用属性初始化语法，在元素中使用箭头函数： <button onclick="{(e)" => this.handleClick(e)}&gt;Click me</button></li></ol></blockquote></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-Leaderboard"><a href="#1-Leaderboard" class="headerlink" title="1. Leaderboard"></a>1. Leaderboard</h3><p>这个<a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">demo</a>是<a href="https://www.freecodecamp.com/challenges/build-a-camper-leaderboard" target="_blank" rel="noopener">FreeCodeCamp</a>的一个练习，使用React实现（2017.6.23完成）。</p><h4 id="一个方法：componentDidUpdate"><a href="#一个方法：componentDidUpdate" class="headerlink" title="一个方法：componentDidUpdate()"></a>一个方法：componentDidUpdate()</h4><p>第一版使用如下代码，但现在看来是自己对componentDidUpdate()这个方法理解有问题，虽然能够实现下述的功能，但这个方法的真正使用方法应该不是这样。</p><blockquote><p>这个方法用来实现当属性或状态发生变化时，对页面中的相应内容进行变更。<a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">demo</a>中点击30天内的分数排名和总分数排名的切换就是通过这个方法实现的。实现的代码如下：  </p></blockquote><pre><code>componentDidUpdate(){  this.props.promise.then(    value =&gt; this.setState({loading: false, data: value}),    error =&gt; this.setState({loading: false, error: error})  );},handleClick: function(event){  if(flag === 0){    flag = 1;    this.props.promise = $.getJSON(alltime);  }else{    flag = 0;    this.props.promise = $.getJSON(recent);  }}</code></pre><blockquote><p>handleClick属性传给标题中的30天内排名和总分数排名两个标题，当点击时，会相应的改变ajax请求的api并把返回结果传递给promise属性，发生的改变会被componentDidUpdate()方法捕捉，然后使用新的数据重新渲染模板。</p></blockquote><h4 id="一个属性handleClick"><a href="#一个属性handleClick" class="headerlink" title="一个属性handleClick"></a>一个属性handleClick</h4><p>这个<a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">demo</a>最终是通过handleClick属性完成切换是根据30天分数排名还是根据总分数排名，还可以选择是正序显示还是倒序显示，不再使用componentDidUpdate()方法。具体代码如下。</p><pre><code>handleClick: function(event){  var id = event.target.parentElement.getAttribute(&apos;id&apos;);  if(id === &quot;alltime&quot;){    this.props.promise = $.getJSON(alltime);    if(flag2 === 1){      flag1 = 1;      flag2 = 0;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value, mark2 :&quot;↓&quot;, mark1 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }else{      flag1 = 1;      flag2 = 1;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value.reverse(), mark2 :&quot;↑&quot;, mark1 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }  }  if(id === &quot;recent&quot;){    this.props.promise = $.getJSON(recent);    if(flag1 === 1){      flag2 = 1;      flag1 = 0;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value, mark1 :&quot;↓&quot;, mark2 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }else{      flag2 = 1;      flag1 = 1;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value.reverse(), mark1 :&quot;↑&quot;, mark2 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }  }}</code></pre><p>有两处引用了handleClick，使用<strong>event.target.parentElement.getAttribute(‘id’)</strong>来判断是哪个发生了点击，并据此显示是根据哪类分数显示。<br>这条代码的使用参考<a href="https://stackoverflow.com/questions/39559222/react-onclick-event-on-link" target="_blank" rel="noopener">此处</a>。event.target可以获得发生点击事件的DOM node本身。然后使用操纵DOM node的方法<a href="https://developer.mozilla.org/en/docs/Web/API/Node/parentElement" target="_blank" rel="noopener">parentElement</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute" target="_blank" rel="noopener">getAttribute()</a>进行判断。event.target真是方便啊！</p><h4 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h4><ol><li>第一次加载时，由于需要渲染，页面是完全白色的，渲染完成后加载相应的内容。但是在初始加载完成后，后面更新数据重新渲染不会再重新加载页面而只是渲染页面变更的部分，之前一直不太明白React的用途，只是听过适合开发UI，或许上面的描述就是一个证据。</li><li>本例中，使用componentDidMount方法来处理ajax请求，根据现在掌握的资料，推断这个方法只能使用一次，也就是在组件加载完成后，之后属性或状态再发生变化要通过componentDidUpdate()方法（有待研究）或handleEvent系列属性来实现。另一个handleEvent属性的实例：<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮大角虫的教程</a>中第9个demo是一个实时显示的应用，使用的是handleChange属性，属性函数里用event.target.value来获取实时改变的值并显示。</li></ol><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ol><li>最初的代码是，关于图标和表格标题的部分都写在html文档中，页面一加载就能看到这两项内容，表格的数据部分用json获取后通过React返回。当React使用render返回一个被DOM元素包裹的数组时，React会自动将其展开一条一条列出。但是，render函数中要求只能有一个顶级标签，导致返回的表格数组和已经写好的表格标题不一样大小，只占其第一列的宽度。没有查到解决办法，参考别人的项目，也没有这样写的，最后只能让所有的部分都由React来实现。希望能找到解决上述问题的方法。</li><li>colspan 属性名在JSX中要写成colSpan才会被识别。</li><li><p>ES6发布后，React的一些方法有了改变，阮一峰大神的教程使用的是ES6发布前的方法。这个demo也没有使用ES6，但是在之后的练习中都要使用最新的方法。下面两个链接是React官方文档和是否使用ES6的一些方法的改变对比：  </p><ul><li><a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">常用方法</a></li><li><a href="https://facebook.github.io/react/docs/react-without-es6.html" target="_blank" rel="noopener">是否使用ES6的方法对比</a>  </li></ul></li></ol><h3 id="2-Recipe-game"><a href="#2-Recipe-game" class="headerlink" title="2. Recipe game"></a>2. Recipe game</h3><p>这个<a href="https://codepen.io/ginnko/full/XgzqKG/" target="_blank" rel="noopener">demo</a>是FreeCodeCamp的一个练习，使用React实现（2017.6.28完成）。大结构使用了Bootstrap的<a href="https://v4-alpha.getbootstrap.com/components/modal/" target="_blank" rel="noopener">Modal</a>和cards中的<a href="https://v4-alpha.getbootstrap.com/components/card/" target="_blank" rel="noopener">list group</a>。使用动态Modal弹出一个窗口接受和修改数据，list group用来组织数据，静态Modal用来显示数据。</p><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>参考资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener">localStorage接口</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">JSON.stringify()</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">JSON.parse()</a>  </p><ol><li>能存入localstorage的数据没有限制原数据结构，只要转成字符串都可以存入。存入前使用JSON.stringify（）将原对象转成字符串，取出后使用JSON.parse()还原成原数据结构。  </li><li>使用localStorage.setItem(key, value)存入对象，localStorage.getItem(key)获取对象。  </li><li>对于有默认初始值得情况，使用下面的方法进行第一次赋值，借鉴了<a href="https://codepen.io/awesom3/pen/Hlfma?editors=1010" target="_blank" rel="noopener">Awesomen3ss 大神</a>的方法。  </li></ol><p>项目中的代码如下：  </p><pre><code>var recipeList = [[&quot;Braised string bean with noodle&quot;, &quot;garlic&quot;, &quot;noodle&quot;, &quot;string bean&quot;,&quot;coriander&quot;, &quot;salt&quot;, &quot;light soy sauce&quot;], [&quot;Braised hairtail&quot;, &quot;hairtail&quot;, &quot;vinegar&quot;, &quot;scallion&quot;, &quot;garlic&quot;, &quot;ginger&quot;, &quot;distilled spirit&quot;, &quot;salt&quot;], [&quot;Scrambled eggs with tomatoes&quot;, &quot;tomatoes&quot;, &quot;egg&quot;, &quot;scallion&quot;, &quot;salt&quot;]];  var condition = localStorage.getItem(&quot;recipeList&quot;);if(condition === null){  localStorage.setItem(&quot;recipeList&quot;, JSON.stringify(recipeList));}</code></pre><h4 id="handle事件的绑定和使用"><a href="#handle事件的绑定和使用" class="headerlink" title="handle事件的绑定和使用"></a>handle事件的绑定和使用</h4><ul><li>React的ES6版本中，handle事件要在初始化中明确绑定，参考<a href="https://facebook.github.io/react/docs/handling-events.html" target="_blank" rel="noopener">官方文档</a>。  </li></ul><p>下面的代码是这个项目中的使用：</p><pre><code>constructor(props){  super(props);  this.state = {list: localStorage.getItem(&quot;recipeList&quot;), value: [temRecipe,temIngredients]};  this.handleClick = this.handleClick.bind(this);  this.handleChange = this.handleChange.bind(this);}  </code></pre><ul><li>“this”位于一个函数中时，它的作用域就是这个函数，正常函数的写法无法接触到需要的DOM对象，导致无法加载DOM对象，页面一篇空白的错误，解决方法是使用<a href="https://stackoverflow.com/questions/41174980/handling-clicks-on-dynamically-generated-buttons" target="_blank" rel="noopener">arrow function</a>，handle函数和后面的应用函数都使用箭头函数的形式。<strong>关于this的使用还是不太理解！</strong></li></ul><p>下面的代码是这个项目中的使用：  </p><pre><code>handleChange = (event) =&gt; {//。。。}handleClick = (event) =&gt; {//。。。}var recipeStructure = JSON.parse(this.state.list).map((val, index) =&gt; {//。。。}var ingredientsList = val.slice(1).map((ele, index) =&gt; {//。。。}</code></pre><ul><li>如果一个map函数循环一个数组并作为组件对象输出到最后的DOM结构中时，要在每次输出过程中包含一个类似id的成为key的属性，来帮助React识别哪一条发生了改变，参考<a href="https://facebook.github.io/react/docs/lists-and-keys.html" target="_blank" rel="noopener">官方文档</a>。</li></ul><h4 id="Forms的Controlled-Components"><a href="#Forms的Controlled-Components" class="headerlink" title="Forms的Controlled Components"></a>Forms的Controlled Components</h4><p>“input”、”textarea”标签使用value属性定义页面加载后输入框中的内容，要想实现能够被编辑，需要再添加onChange属性，参考<a href="https://facebook.github.io/react/docs/forms.html#default-value" target="_blank" rel="noopener">官网文档</a>。</p><h3 id="3-Game-of-Life"><a href="#3-Game-of-Life" class="headerlink" title="3. Game of Life"></a>3. Game of Life</h3><p>这个<a href="https://codepen.io/ginnko/full/YQvVRw/" target="_blank" rel="noopener">demo</a>是FreeCodeCamp的一个练习，使用React实现（2017.7.05完成）。在做这个项目之前，把官方文档的基础部分全部看了一遍，这个项目中，尽量应用了学到的一些原则，比如把有具体单一功能的代码放到一个组件或函数中。  </p><ul><li><p>函数</p><blockquote><p>search：获取某个存活细胞周围的8个邻居<br>execute: 判断这当代细胞的存活<br>repeat： 重复执行判断过程  </p></blockquote></li><li><p>组件</p><blockquote><p>NewTable：制造board<br>TableConstruct: 加载board以及三类点击事件（控制、board大小、速度）  </p></blockquote></li></ul><p>感觉TableConstruct的内容依然过多，可以进一步分离。</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><ul><li>在React中，如果想要实现通过点击某个按钮来实现改变某个元素变化的速度，就要通过<a href="https://stackoverflow.com/questions/1280263/changing-the-interval-of-setinterval-while-its-running" target="_blank" rel="noopener">SetTimeout()</a>来实现。setTimeout()允许在运行过程中改变时间间隔，setInterval()没有这项功能。</li><li>如果要在setTimeout()或setInterval()的回调函数中直接使用所在组件的this，因为<a href="https://stackoverflow.com/questions/26348557/issue-accessing-state-inside-setinterval-in-react-js" target="_blank" rel="noopener">作用域</a>的原因，要var self = this;通过self传入this或手动绑定this。</li><li><p>setInterval()的循环不能直接放进for或while循环体中，要是用类似迭代的方式。<br>如下代码：</p><pre><code>function repeat(){  execute();  timer = setTimeout(repeat, self.state.speed);}</code></pre></li></ul><h4 id="state-amp-props"><a href="#state-amp-props" class="headerlink" title="state &amp; props"></a>state &amp; props</h4><p>本例中，NewTable组件里同时使用了props和state，忘记官方文档里是不是有说尽量把state和props分开使用了，这个有待确定。代码如下：</p><pre><code>class NewTable extends React.Component{  constructor(props){    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = {};  }  handleClick(e){    var flag = e.target.getAttribute(&quot;class&quot;);    if(flag === &quot;white&quot;){      e.target.setAttribute(&quot;class&quot;, &quot;red&quot;);    }else{      e.target.setAttribute(&quot;class&quot;, &quot;white&quot;);    }  }  render(){    var row = [];    var rowLen = this.props.rowNumber;    var columnLen = this.props.columnNumber;    var key = 0;    var flag = 0;    for(let j = 0; j&lt;rowLen; j++){      var tableData = [];      for(let i = 0; i&lt;columnLen; i++){        if(start === 0){          flag = Math.round(Math.random());        }else{          flag = 0;        }        tableData.push(&lt;td id={key++} r={0} onClick={this.handleClick} className={flag===0?&quot;white&quot;:&quot;red&quot;} role=&quot;button&quot;&gt;&lt;/td&gt;);      }      row.push(&lt;tr&gt;{tableData}&lt;/tr&gt;);    }    start = 1;    return &lt;tbody&gt;{row}&lt;/tbody&gt;;  }}</code></pre><h4 id="关于jQuery和DOM的操作"><a href="#关于jQuery和DOM的操作" class="headerlink" title="关于jQuery和DOM的操作"></a>关于jQuery和DOM的操作</h4><ul><li>使用jQuery删除属性，方法：<code>$(&quot;p&quot;).removeAttr(&quot;id&quot;);</code>即可成功删除id属性。</li><li>DOM元素使用<code>getAttribute()</code>和<code>setAttribute()</code>两个函数来操作属性；而jQuery使用<code>.attr()</code>来操作属性</li></ul><h4 id="JSX中的属性名称"><a href="#JSX中的属性名称" class="headerlink" title="JSX中的属性名称"></a>JSX中的属性名称</h4><p>官方文档中，有说JSX属性名称使用驼峰命名法，这个项目中NewTable组件里的这行代码<code>tableData.push(&lt;td id={key++} r={0} onClick={this.handleClick} className={flag===0?&quot;white&quot;:&quot;red&quot;} role=&quot;button&quot;&gt;&lt;/td&gt;);</code>最开始属性名<strong>r</strong>是写作<strong>relive</strong>但是在后面获取时失败，这明明是一个单词，不知道该在哪里驼峰。。。有待确认。  </p><h3 id="4-Roguelike-Dungeon-Crawler-Game-2017-7-28完成"><a href="#4-Roguelike-Dungeon-Crawler-Game-2017-7-28完成" class="headerlink" title="4. Roguelike Dungeon Crawler Game(2017.7.28完成)"></a>4. <a href="https://codepen.io/ginnko/full/JydBWO/" target="_blank" rel="noopener">Roguelike Dungeon Crawler Game</a>(2017.7.28完成)</h3><p>这个小项目是目前最耗时的一个，写了很久，也有很多想法。最重要的一个想法是基础太重要了，所以决定后面拿出一部分时间来复习css、js基础。下面来说这个项目。  </p><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><p>界面可以分成五个部分，左侧的状态、中间的游戏板、上方的阴影遮挡、右侧的解释以及下方的说明。  </p><ul><li>下方的说明：说明部分没有借助React，是使用html节点直接显示</li><li>左侧状态栏、右侧解释栏：独立组件，使用React生成，但是其中信息的更新使用了全局变量，没有通过React的状态更新（因为不知如何用React处理游戏板更新但状态栏和解释栏不变的情况）。</li><li>中间游戏板： 独立组件，使用React生成，每一层的随机设置使用Math.random()函数，层与层的转换借助floor state。</li><li>上方阴影遮挡： 独立组件，使用React生成，代码类似中间游戏板，去掉了随机布置的部分。透明部分使用jQuery和css完成定位和透明度转换。  </li></ul><h4 id="遇到的问题和解决办法"><a href="#遇到的问题和解决办法" class="headerlink" title="遇到的问题和解决办法"></a>遇到的问题和解决办法</h4><ol><li>第一个问题是在<table>标签中使用onKeyDown事件，搜索发现，有两种解决办法。第一种是，在table类的标签中增加<strong>tabindex=”0”</strong>属性，用来解决table类的节点不能focused的问题，但失败了，其没有找到原因，猜测和作用域有关系；第二种办法是，在componentDidMount中设置事件监听函数，进行窗口监听，获取onKeyDown事件，成功，监听代码见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key" target="_blank" rel="noopener">MozillaMDN</a>。  </table></li><li><p>在外部函数中改变组件的state，来re-render。解决办法是利用全局变量floor和新建一个变量var self = this;来消除作用域的隔绝。  </p><pre><code>floor = 1;//全局变量  var self = this;//用self变量消除作用域隔绝问题move (id, nav, self)//将self作为函数参数传入外部move函数  floor++;self.setState({floor: floor});//在move中改变组件的state</code></pre></li><li>地图死角问题。使用外部函数fix来解决，开始想在地图生成组件的最后来解决，但是发现捕捉到的节点全是未定义，由于React在加载前构建的全都是空节点，所以没办法使用这种方法，所以在componentDidMount、componentDidUpdate中调用fix函数通过jQuery来对地图调整。</li><li>左侧状态栏、中间游戏板、右侧解释栏以及上方阴影遮挡的布局问题。最后使用绝对位置和相对位置成功解决。<strong>基础就是这么的重要啊！！！</strong></li><li>上方阴影遮挡空白处随方向键移动问题。通过外部函数eye（），利用jQuery和css解决，使用了jQuery中我不太常用的.filter（）函数。另外，在实现这个功能的过程中，开始fighter从一层进入下一层时，上一层的空白可见区域会遗留而不跟随新的fighter位置变化。开始以为这个问题是因为阴影遮挡组件没有状态改变，所以不会重新加载的原因，但是通过获取fighter的更新位置，发现在地图生成组件和componentDidUpdate中获取的位置是一致的，而且只使用了jQuery和css实现，应该不是React的render问题。最后发现是在事件监听部分，先把fighter的id获取传给了一个变量，再将这个变量传给位于move（）后面的eye（）函数。move（）函数中已经变化了层数，更新了fighter的位置，但是传入的id是上一层的door的位置，所以此处不借助中间变量，直接使用<code>$(&quot;.red&quot;).attr(&quot;id&quot;)</code>获取最新的位置，解决了这个问题。  </li></ol><h4 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h4><ol><li>地图生成使用了最简单的随机生成，生成复杂的规整地图有些乏力；</li><li>目前没有实现固定小窗口，在小窗口内移动变换空间的功能，猜测使用了overflow属性，但查看资料overflow只对block元素有效，table类元素调整起来貌似有些困难。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RegExp</title>
      <link href="/2017/06/13/Regular%20Express/"/>
      <url>/2017/06/13/Regular%20Express/</url>
      
        <content type="html"><![CDATA[<h3 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">Mozilla MDN</a>：详细的RegExp说明和使用</li><li><a href="http://regexr.com/" target="_blank" rel="noopener">在线神器</a>：方便的在线测试和快速构造</li><li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499503920bb7b42ff6627420da2ceae4babf6c4f2000" target="_blank" rel="noopener">廖大角虫教程</a>：应用和主要函数一览无余  </li></ol><a id="more"></a><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h3><ol><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">exec()函数</a><br><strong>不要把正则表达式字面量（或者正则表达式构造器）放在 while 条件表达式里。由于每次迭代时 lastIndex 的属性都被重置，如果匹配，将会造成一个死循环。</strong></p><pre><code>var myRe = /ab*/g;var str = &apos;abbcdefabh&apos;;var myArray;while ((myArray = myRe.exec(str)) !== null) {  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;  msg += &apos;Next match starts at &apos; + myRe.lastIndex;  console.log(msg);}//Found abb. Next match starts at 3//Found ab. Next match starts at 9</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对使用jsonp进行跨域获取数据的三个项目的总结</title>
      <link href="/2017/06/13/using%20api/"/>
      <url>/2017/06/13/using%20api/</url>
      
        <content type="html"><![CDATA[<p>这篇是对使用API搜集需要的数据并传回到app中的总结。涉及三个应用：<a href="https://codepen.io/ginnko/full/WjgbMM/" target="_blank" rel="noopener">random quote</a>、<a href="https://codepen.io/ginnko/full/mmzqVj/" target="_blank" rel="noopener">local weather</a>以及<a href="https://codepen.io/ginnko/full/Omadzj/" target="_blank" rel="noopener">wikipedia viewer</a>。实质是利用jsonp进行跨域请求。</p><a id="more"></a><h2 id="1-jsonp的介绍和使用"><a href="#1-jsonp的介绍和使用" class="headerlink" title="1. jsonp的介绍和使用"></a>1. jsonp的介绍和使用</h2><p><a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">这篇文章</a>是我目前见过的对jsonp最清晰和简单的描述，感谢这位大神！</p><h2 id="2-random-quote"><a href="#2-random-quote" class="headerlink" title="2. random quote"></a>2. <a href="https://codepen.io/ginnko/full/WjgbMM/" target="_blank" rel="noopener">random quote</a></h2><p>第一次接触api的应用，由于今年6月codepen开始全面使用https协议，所以原本使用http的api已经无法正常显示，目前没有找到好的解决办法。<br>使用的api地址如下：</p><blockquote><p><a href="http://api.forismatic.com/api/1.0/?method=getQuote&amp;format=jsonp&amp;lang=en&amp;jsonp=" target="_blank" rel="noopener">http://api.forismatic.com/api/1.0/?method=getQuote&amp;format=jsonp&amp;lang=en&amp;jsonp=</a>?</p></blockquote><p><strong>endpoint：</strong> <a href="http://api.forismatic.com/api/1.0/" target="_blank" rel="noopener">http://api.forismatic.com/api/1.0/</a><br><strong>?：</strong> 端点和参数的分割<br><strong>=：</strong> 匹配参数和参数值<br><strong>&amp;：</strong> 连接两个不同的参数<br><strong>jsonp=？：</strong> jsonp是callback，即获得回调函数名的参数名，等号后面可以写回调函数名，写？则会由jQuery自动处理。</p><p>一个简单的实践：  </p><pre><code>function randomQuote() {    var url = &quot;http://api.forismatic.com/api/1.0/?method=getQuote&amp;format=jsonp&amp;lang=en&amp;jsonp=?&quot;;    $.getJSON(url, function(json) {      $(&quot;#quote&quot;).text(json.quoteText);      $(&quot;#author&quot;).text(&quot;--&quot; + json.quoteAuthor);    });}</code></pre><p>返回的数据依照相应的参数名进行调用即可。  </p><h2 id="3-local-weather"><a href="#3-local-weather" class="headerlink" title="3. local weather"></a>3. <a href="https://codepen.io/ginnko/full/mmzqVj/" target="_blank" rel="noopener">local weather</a></h2><p>这个应用使用了两个api。<br>获取天气数据使用了darksky的api：  </p><blockquote><p>“<a href="https://api.darksky.net/forecast/37afbe1af1965b09f5c7e0c6f710fc34/&quot;" target="_blank" rel="noopener">https://api.darksky.net/forecast/37afbe1af1965b09f5c7e0c6f710fc34/&quot;</a> + latitude + “,” + longitude + “/?units=auto&amp;callback=?”  </p></blockquote><p>获取位置数据使用了google map的api：</p><blockquote><p>google_map_url = “<a href="https://maps.googleapis.com/maps/api/geocode/json?latlng=&quot;" target="_blank" rel="noopener">https://maps.googleapis.com/maps/api/geocode/json?latlng=&quot;</a> + latitude + “,” + longitude + “&amp;key=xxxxxxx&amp;language=en”</p></blockquote><p>其中的latitude和longitude是使用<strong>navigator.geolocation.getCurrentPosition()</strong>获取的，详细文档点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/Using_geolocation" target="_blank" rel="noopener">此处</a>，简单的使用方法如下：</p><pre><code>navigator.geolocation.getCurrentPosition(function(position) {    var latitude;    var longitude;    latitude = position.coords.latitude;     longitude = position.coords.longitude;     //其他函数}</code></pre><h2 id="4-wikipedia-viewer"><a href="#4-wikipedia-viewer" class="headerlink" title="4. wikipedia viewer"></a>4. <a href="https://codepen.io/ginnko/full/Omadzj/" target="_blank" rel="noopener">wikipedia viewer</a></h2><p>Wikipedia的api使用起来感觉相当复杂，点击此处的<a href="https://www.mediawiki.org/wiki/API:Main_page" target="_blank" rel="noopener">使用文档</a>。下面是应用中对地址的具体表示：  </p><blockquote><p>var url = “<a href="https://en.wikipedia.org/w/api.php?action=query&amp;list=search&amp;format=json&amp;prop=extracts&amp;utf8=&amp;srlimit=10&amp;srsearch=&quot;" target="_blank" rel="noopener">https://en.wikipedia.org/w/api.php?action=query&amp;list=search&amp;format=json&amp;prop=extracts&amp;utf8=&amp;srlimit=10&amp;srsearch=&quot;</a>; </p></blockquote><p>var val = $(“#search”).val() + “&amp;callback=?”;  </p><blockquote></blockquote><p>url += val;</p><h2 id="5-实际跨域调用"><a href="#5-实际跨域调用" class="headerlink" title="5. 实际跨域调用"></a>5. 实际跨域调用</h2><p>使用jQuery的getJson函数。</p><blockquote><p>$.getJSON(google_map_url, function(json){//});</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> jsonp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个小项目总结</title>
      <link href="/2017/06/12/sumary%20about%20some%20projects/"/>
      <url>/2017/06/12/sumary%20about%20some%20projects/</url>
      
        <content type="html"><![CDATA[<h2 id="Tic-Tac-Toe游戏"><a href="#Tic-Tac-Toe游戏" class="headerlink" title="Tic Tac Toe游戏"></a><a href="https://codepen.io/ginnko/full/dRPXGv/" target="_blank" rel="noopener">Tic Tac Toe游戏</a></h2><h3 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h3><p>在计算器、番茄闹钟和这个项目中，都遇到了在for循环中用var定义一个循环变量后，即便出了for循环的范围依然可以使用的情况，现在返回头，从廖大角虫的<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344993159773a464f34e1724700a6d5dd9e235ceb7c000" target="_blank" rel="noopener">教程</a>里再明确一下变量作用域。</p><a id="more"></a><ul><li>今后在第一行都写上’use strict’，强制要求通过var申明变量。</li><li>若两个不同的函数各自中声明了相同名字的变量，该变量只在各自的函数体内起作用。</li><li><p>JavaScript的变量作用域是函数内部，<strong>在for循环等语句块中无法定义具有局部作用域的变量</strong>。比如： </p><pre><code>function foo() {    for(var i=0; i&lt;100; i++){    //    }    i += 100; //在for循环外仍然可以使用i！！！}在语句块中使用let声明局部变量：function foo() {    for(let i=0; i&lt;100; i++){    //    }    i += 100; //在for循环外仍然可以使用i！！！}</code></pre></li><li><p>名字空间：</p><pre><code>//唯一的全局变量var MYAPP = {};//其他变量MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;//其它函数MYAPP.foo = function(){    return &quot;foo&quot;;};</code></pre></li></ul><h3 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2. 布尔值"></a>2. 布尔值</h3><p>false不能用具体某个数字表示：-1 ！== false</p><h3 id="3-遇到的具体问题"><a href="#3-遇到的具体问题" class="headerlink" title="3. 遇到的具体问题"></a>3. 遇到的具体问题</h3><ul><li>Tag div 没有disable这个属性</li><li><p>当使用jQuery时，开关click事件可以使用on， off函数，需要一个callback函数。当依次执行关闭、自动开启、手动开启操作时，为避免多次开启，采用下面的方法。<a href="https://codepen.io/ginnko/pen/dRPXGv" target="_blank" rel="noopener">实例</a>：place函数、another函数以及reset函数。</p><pre><code>$(&quot;.pit&quot;).off(&quot;click&quot;);//prevent from being disturbed by the same execution in another function $(&quot;.pit&quot;).on(&quot;click&quot;, place);</code></pre></li><li><p>数组的push（）函数，如果参数是一个数组，那么结果将是一个二维数组，如果改动这个二维数组中的元素，则原来那个作为参数传入的数组中的相应元素也会被改动，push（）函数执行的是浅复制操作。</p></li></ul><h2 id="番茄时钟"><a href="#番茄时钟" class="headerlink" title="番茄时钟"></a><a href="https://codepen.io/ginnko/full/EXxXJw/" target="_blank" rel="noopener">番茄时钟</a></h2><h3 id="1-关于延时函数"><a href="#1-关于延时函数" class="headerlink" title="1. 关于延时函数"></a>1. 关于延时函数</h3><p>这个项目里主要用了setInterval()和clearInterval()两个函数，必须成对出现，可<strong>反复延迟执行</strong>传入setInterval的函数直到遇到清除函数。把setInterval()的返回值赋给某个变量，入下列中的id作为唯一标识，并使用id传入clearInterval()停止循环过程。以下代码出自此项目</p><pre><code>function countSession(){if(timeSession &lt; 0){  st = 1;  clearInterval(id);//停止循环过程，但此清除函数不是针对下面的SetInterval()函数，详见项目中的代码  set();  optimize(timeRelax);  timeRelax--;  i++;  id = setInterval(countRelax, 1000);//每延迟一秒执行一次countRelax函数  $(&quot;circle&quot;).attr(&quot;fill&quot;, &quot;#00FF00&quot;);  $(&quot;#progress&quot;).text(&quot;break&quot;);  flag = true; }else{var arr = calculate(timeSession);$(&quot;#show&quot;).text(arr[0] + &quot;:&quot; + arr[1]);$(&quot;path&quot;).attr(&quot;stroke-dasharray&quot;, &quot;&quot; + i*stepSession + &quot;,&quot; + (251.2-i*stepSession));timeSession--;i++;st = 0;flag = true;}</code></pre><p>}</p><h3 id="2-关于svg标签"><a href="#2-关于svg标签" class="headerlink" title="2. 关于svg标签"></a>2. 关于svg标签</h3><p>svg标签的使用点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="noopener">此处</a>以下代码中，circle标签用来表示大圆，path标签用来表示随着时间变化的外环，text标签用来表示圆内的说明。这个项目参考了<a href="https://codepen.io/web-tiki/full/qEGvMN/" target="_blank" rel="noopener">web-tiki</a>的项目，感谢web-tiki大神。</p><pre><code>&lt;svg role=&quot;button&quot; id=&quot;svg&quot; viewbox=&quot;0 0 100 100&quot;&gt;    &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;45&quot; fill=&quot;#FF4500&quot;/&gt;    &lt;path fill=&quot;none&quot; stroke-linecap=&quot;round&quot; stroke-width=&quot;5&quot; stroke=&quot;#fff&quot; stroke-dasharray=&quot;0 251.2&quot;      d=&quot;M50 10         a 40 40 0 0 1 0 80         a 40 40 0 0 1 0 -80&quot;/&gt;    &lt;text id=&quot;show&quot; x=&quot;50&quot; y=&quot;50&quot; text-anchor=&quot;middle&quot; dy=&quot;7&quot; font-size=&quot;15&quot;&gt;START&lt;/text&gt;    &lt;text id=&quot;progress&quot; x=&quot;50&quot; y=&quot;75&quot; text-anchor=&quot;middle&quot; font-size=&quot;10&quot;&gt;&lt;/text&gt;&lt;/svg&gt;</code></pre><h3 id="3-role属性"><a href="#3-role属性" class="headerlink" title="3. role属性"></a>3. role属性</h3><p>role属性位于某个标签内，当拥有某个属性值后会使所在标签具有属性值得某些功能。比如上述代码中的svg标签，role=”button”是的svg标签拥有了click事件。</p><h2 id="JavaScrip计算器"><a href="#JavaScrip计算器" class="headerlink" title="JavaScrip计算器"></a><a href="https://codepen.io/ginnko/full/EXxXJw/" target="_blank" rel="noopener">JavaScrip计算器</a></h2><h3 id="1-RegExp"><a href="#1-RegExp" class="headerlink" title="1. RegExp"></a>1. RegExp</h3><p>这个项目中使用了RegExp的exec()函数，详见这篇<a href>总结</a>。</p><h3 id="2-this-amp-this"><a href="#2-this-amp-this" class="headerlink" title="2. this &amp; $(this)"></a>2. this &amp; $(this)</h3><p>this:表示一个html元素， this.title<br>$(this):表示一个jQuery对象， $(this).attr(“title”)</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
            <tag> variable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax和Promise的简单理解</title>
      <link href="/2017/04/27/JavaScript-summary-of-JSON-Ajax-promise/"/>
      <url>/2017/04/27/JavaScript-summary-of-JSON-Ajax-promise/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1. Ajax"></a>1. Ajax</h3><p>Ajax技术能够向服务器请求额外的数据而无需卸载页面，会带来更好的用户体验。</p><a id="more"></a><pre><code>function success(text) {var textarea = document.getElementById(&apos;test-response-text&apos;);textarea.value = text;}function fail(code) {    var textarea = document.getElementById(&apos;test-response-text&apos;);    textarea.value = &apos;Error code: &apos; + code;}var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调    if (request.readyState === 4) { // 成功完成        // 判断响应结果:        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}// 发送请求:request.open(&apos;GET&apos;, &apos;/api/categories&apos;);request.send();alert(&apos;请求已发送，请等待响应...&apos;);</code></pre><p>上述代码引自网络<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000" target="_blank" rel="noopener">点击这里</a>  </p><p>Ajax技术基于对象XMLHttpRequest，依赖于4个属性：onreadystatechange、readyState、status、responseText以及2个方法：open()、send()。</p><ul><li><p>open()方法<br>open()方法接受三个参数，如上述代码，<strong>第二个参数只能向同一个域发送请求</strong>。第三个表示是否异步发送请求的布尔值。open()方法启动一个请求准备发送。</p></li><li><p>send()方法<br>send()方法被调用后，请求会被发送至服务器。</p></li><li><p>readyState属性</p></li></ul><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">状态</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">未初始化</td><td style="text-align:center">尚未调用open()方法</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">启动</td><td style="text-align:center">已经调用open()方法，但尚未调用send()方法</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">发送</td><td style="text-align:center">已经调用send()方法，但尚未接收到相应</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">接收</td><td style="text-align:center">已经接收到部分相应数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">完成</td><td style="text-align:center">已经接收到全部响应数据，而且已经可以再客户端使用了</td></tr></tbody></table><ul><li><p>onreadystatechange属性<br>只要readyState属性的值由一个值变成另一个值，都会触发一次onreadystatechange事件，执行回调函数。</p></li><li><p>status属性<br>该属性表示响应的HTTP状态。收到响应后，检查status属性，将HTTP状态代码为200作为成功的标志。</p></li><li><p>responseText属性<br>被返回的文本包含在这个属性里</p></li></ul><p><strong>发送的异步请求能让JavaScript继续执行而不必等待相应。</strong> </p><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h3><p><strong>Promise最大的好处是在异步执行的过程中，把执行代码和处理结果的代码清晰的分离了。</strong></p><pre><code>function test(resolve, reject) {    var timeOut = Math.random() * 2;    log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);    setTimeout(function () {        if (timeOut &lt; 1) {            log(&apos;call resolve()...&apos;);            resolve(&apos;200 OK&apos;);        }        else {            log(&apos;call reject()...&apos;);            reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);        }    }, timeOut * 1000);}new Promise(test).then(function (result) {    console.log(&apos;成功：&apos; + result);}).catch(function (reason) {    console.log(&apos;失败：&apos; + reason);});</code></pre><p>上述代码引自网络<a href="www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000">点击这里</a></p><ul><li><p>test函数相当于定义了一个异步执行的操作，函数内清楚的表明了异步操作成功的结果处理和异步操作失败的结果处理。</p></li><li><p>test函数接收了两个参数，两个参数都是函数，在test中并未给出具体定义。</p></li><li><p>new Promise(test)定义了一个Promise对象，并把一个名为test的异步操作任务传递给了这个Promise对象。</p></li><li><p>Promise对象可以使用两个方法then()和catch()，当调用then()方法时，才真正发出异步请求。then()中定义的函数才是resolve实际代表的函数，当异步操作成功<br>执行其中的函数，并返回一个Promise对象；当异步操作失败，执行catch()中定义的函数，这个函数是reject的实际定义，并返回一个Promise对象。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Ajax </tag>
            
            <tag> Promise </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript常用对数组和字符串的操作方法</title>
      <link href="/2017/04/17/JavaScript-string&amp;array-function/"/>
      <url>/2017/04/17/JavaScript-string&amp;array-function/</url>
      
        <content type="html"><![CDATA[<h3 id="对字符串的操作方法"><a href="#对字符串的操作方法" class="headerlink" title="对字符串的操作方法"></a>对字符串的操作方法</h3><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">作用</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">toUpperCase()</td><td style="text-align:center">把一个字符串全部变为大写并返回一个新的字符串</td><td style="text-align:center">str.toUpperCase();</td></tr><tr><td style="text-align:center">toLowerCase()</td><td style="text-align:center">把一个字符串全部变为小写并返回一个新的字符串</td><td style="text-align:center">str.toLowerCase();</td></tr><tr><td style="text-align:center">indexOf()</td><td style="text-align:center">搜索并返回指定字符串出现的位置</td><td style="text-align:center">str.index(‘Hello’);</td></tr><tr><td style="text-align:center">substring()</td><td style="text-align:center">返回指定索引区间的字符串</td><td style="text-align:center">str.substring(0, 2);</td></tr><tr><td style="text-align:center">length</td><td style="text-align:center">返回字符串的长度</td><td style="text-align:center">str.length;</td></tr></tbody></table><a id="more"></a><h3 id="对数组的操作方法"><a href="#对数组的操作方法" class="headerlink" title="对数组的操作方法"></a>对数组的操作方法</h3><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">作用</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">length</td><td style="text-align:center">返回数组的长度</td><td style="text-align:center">arr.length</td></tr><tr><td style="text-align:center">indexOf()</td><td style="text-align:center">搜索并返回指定元素的位置</td><td style="text-align:center">arr.indexOf(30)</td></tr><tr><td style="text-align:center">slice()</td><td style="text-align:center">截取数组的一部分并返回新的数组,参数为空时可以复制一个数组</td><td style="text-align:center">arr.slice(0, 2);</td></tr><tr><td style="text-align:center">push()</td><td style="text-align:center">向数组末尾添加元素，返回新数组长度</td><td style="text-align:center">arr.push(1, 2);</td></tr><tr><td style="text-align:center">pop()</td><td style="text-align:center">删除数组末尾最后一个元素，返回删除的元素</td><td style="text-align:center">arr.pop();</td></tr><tr><td style="text-align:center">unshift()</td><td style="text-align:center">向数组头部添加原素，返回新数组的长度</td><td style="text-align:center">arr.unshift(1, 2);</td></tr><tr><td style="text-align:center">shift()</td><td style="text-align:center">删除数组第一个元素，并返回被删除的元素</td><td style="text-align:center">arr.shift();</td></tr><tr><td style="text-align:center">sort()</td><td style="text-align:center">对数组进行排序，改变数组本身</td><td style="text-align:center">arr.sort();</td></tr><tr><td style="text-align:center">reverse()</td><td style="text-align:center">反转数组元素的顺序，改变数组本身</td><td style="text-align:center">arr.reverse();</td></tr><tr><td style="text-align:center">splice()</td><td style="text-align:center">指定位置删除若干元素并添加若干元素(位置，删除元素个数，添加的元素)</td><td style="text-align:center">arr.splice(2, 0, ‘Google’);</td></tr><tr><td style="text-align:center">concat()</td><td style="text-align:center">连接两个数组，并返回链接后的数组</td><td style="text-align:center">arr1.concat(arr2);</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">用指定字符串连接一个数组中的元素，并返回连接后的数组</td><td style="text-align:center">arr.join(‘-‘);</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2017/04/16/basic-markdown-syntax/"/>
      <url>/2017/04/16/basic-markdown-syntax/</url>
      
        <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>  有几个#，就是几级标题，上面使用的是3级标题。</p><h3 id="2-斜体和加粗"><a href="#2-斜体和加粗" class="headerlink" title="2. 斜体和加粗"></a>2. 斜体和加粗</h3><p>  斜体用一个*包裹：<em>我是斜体</em></p><p>  加粗用两个**包裹：<strong>我是粗体</strong></p><a id="more"></a><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h3><p>  有序列表：1.+空格+内容</p><ol><li><p>我是有序列表</p><p>无序列表：-+空格+内容</p></li></ol><ul><li>我是无序列表</li></ul><h3 id="4-插入图片"><a href="#4-插入图片" class="headerlink" title="4. 插入图片"></a>4. 插入图片</h3><p>  ！+[名称]+(地址)<br>  <img src="/images/background-cover.jpg" alt="你的名字风景"></p><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p>使用&gt;符号  </p><blockquote><p>原谅我这一生不羁放纵爱自由<br>    也会怕有一天会跌倒<br>    背弃了理想 谁人都可以<br>    哪会怕有一天只你共我<br>    仍然自由自我 永远高唱我歌<br>    ————《海阔天空》</p></blockquote><h3 id="6-引用网址"><a href="#6-引用网址" class="headerlink" title="6. 引用网址"></a>6. 引用网址</h3><p>[+名称+]+(+地址+)<br><a href="https://github.com/" target="_blank" rel="noopener">Github</a>是一个伟大的平台！</p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7. 表格"></a>7. 表格</h3><pre><code>|CNY|HKD||:---|---:||1|1.1292|  英文冒号的位置表示文字在表格中的位置（居中、靠左、靠右）  使用表格前要在_config.yml文件中加入：  markdown: redcarpet  recarpet:      entensitons: [&quot;tables&quot;]</code></pre><blockquote><p>引自2017.4.16汇率  </p></blockquote><blockquote><table><thead><tr><th style="text-align:left">CNY</th><th style="text-align:right">HKD</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">1.1292</td></tr></tbody></table></blockquote><h3 id="7-代码区块"><a href="#7-代码区块" class="headerlink" title="7. 代码区块"></a>7. 代码区块</h3><p>每一行用4个空格开头</p><pre><code>print &quot;我是一行代码,用来输出我是一行代码&quot;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="/2017/04/14/construct-the-blog-with-jekyll/"/>
      <url>/2017/04/14/construct-the-blog-with-jekyll/</url>
      
        <content type="html"><![CDATA[<p>本想着从零开始搭建一个自己的博客，不过当下技术有限，借用大神的模板，勉强搭建起了这个博客，开始记录自己的学习过程。</p><p>昨天倒是完整的看了markdown的规则，不过这种闲聊似的记述貌似也用不上<em>手动扶额流泪</em>。</p><a id="more"></a><p>在本地这个博客已经能成功跑起来了，不过也是费了九牛二虎之力，倒是对博客用得到的技术有了个大概的了解。</p><p>现在是凌晨，睡一觉后，上传到GitHub，正式上线！</p><p>是骡子是马拉出去溜溜！<em>手动扶额流泪</em></p><p>估计把微信<em>扶额流泪</em>的表情添加进来是无望了。<em>手动扶额流泪</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
