---
layout: post
title: 《计算机网络概论》学习笔记整理之wireless LAN
date: 2020-03-22
tag: 
- 网络
---

在上一篇概述的基础上探讨wireless的运作原理，主要涉及以下10个方面：

1. 无线的两种重要特征
2. 无线采用的协议是CSMA/CA而不是CSMA/CD
3. RTC/CTS的作用和工作原理
4. ACK存在的作用和工作过程
5. carrier sense的方式
6. CSMA/CA的工作方式
7. 3个priority的级别：SIFS < PIFS < DIFS
8. DCF运行原理
9. PCF运行原理
10. SuperFrame运行原理

<!-- more -->

---

### IEEE802.11标准

无线技术使用的标准是：*IEEE802.11*，这个标准用来处理有限区域(比如家庭、办公室、校园)的无线传输。传输介质是空气(通过空气广播)，这个标准还规定了：电源管理和安全机制。

该标准使用的协议是：CSMA/CA，Carrier Sense Multiple Access with Collision Avoidance

该标准定义了2种物理层实现，以解决信息互相干扰的问题，具体情况不清楚，也不感兴趣：

1. frequency hopping(跳频技术)：把信息切分到不同的频道发送
2. direct sequence：对不同的频道进行不同的加密

---

### 无线传输的2个重要特征

1. hidden node problem(hidden terminal)

  下图中，A、C两个节点虽然听不到对方的信号，但同时传送给相同的节点B，会造成双方的信号碰撞，导致各自的封包都失效。

  在无线环境中，没有办法侦测到collision。

<img src="/images/network/hiddenNodeProblem.png" width="400" alt="hidden node problem" />

1. exposed node problem

  双方虽然听得到对方的信号，但同时传送给不同的节点不会发生干扰

---

### CSMA/CA协议中的封包

  1. 封包类型

    - control frames
      - RTS
      - CTS
      - ACK
      - POLL
    
    - management frams
      - Probe Request/Response
      - Beacon(用于扫描)
      - Authentication(验证)
    
    - 标准封包
      - data

  2. RTS和CTS

  RTS和CTS都是control frame类型的封包，作用是告诉起始工作站和目的地工作站范围内的其他节点，有信息将要开始传送，不要同时发送干扰。

     - RTS：Request to send，用于宣告要送的封包，附带有需要多长时间发送
     - CTS：Clear to send，用于宣告将要收封包，并附带需要多长时间接受

  RTS和CTS都以广播的形式在工作站范围内发送，下图的场景是B将向C发送信息，B先发送一个RTS，C收到后，发送一个CTS：

  <img src="/images/network/RTS&CTS.png" width="400" alt="RTS和CTS" />

     - B、D同时给C发送封包就会发生hidden terminal问题
     - 所有蓝色范围内的工作站，即听到CTS的等下都不能向C发送信号，但这些节点可以给其他节点发送

  后面将整理这两个封包实际是如何工作的。

  3. ACK frame

  这个控制封包用来在一个节点成功收到另一个节点发来的信息，且信息无误的情况下，会向源头节点返回一个ACK封包，表明刚才那个信息成功收到。

---

### 802.11分散式系统DS(distributed system)

   1. 现状：在无线环境中，node可以移动，并且是不完全连接(经由1~2次hub连接起来)(没搞明白什么叫不完全连接，没查到，不影响理解，直接跳过)

   2. node被分为两类：

          1. 允许移动的：手机，笔记本电脑
          2. 和有线网络相连的：AP(AP和后端建设的基础设施相连，这个基础设施就是DS，DS会将多个AP连接起来)

   3. 分散式系统

   DS是layer2的系统，下面是它的原理图：

   <img src="/images/network/DistributedSystem.png" width="400" alt="distributed system" />

   分散式系统的目的：用分散式系统将多个AP连接起来，让802.11覆盖的范围更广

    4. 扫描
      
    由上图可见，每一个AP都会覆盖一些节点，节点B处在AP1和AP2两个范围内，这就涉及到node选择AP的问题。有两种情况需要扫描：
    
      1. 节点刚进入无线环境
      2. node从一个AP范围进入另一个AP范围
    
    5. 扫描的类型
    
      - 主动扫描
    
        1. 笔电或者手机送一个probe frame(问一下周围有哪些基地台听到的我)
        2. 所有在范围里能听到的AP都会回一个probe Response frame
        3. node会从这些回应的AP里选一个向这个AP发送一个Association Request Frame，通常会选信号强、速度快的
        4. AP回复一个Association Response Frame后建立连接
    
      - 被动扫描
    
        1. AP会周期性的发送Beacon frame，告知自身的能力，包括其支持的transmission rate
        2. node如果要连接会发送一个Association Request frame给该AP
        3. AP再回复一个Association Response frame建立连接

---

### 802.11 MAC封包格式

  下面是一个MAC分包：

  <img src="/images/network/MACFrameFormat.png" width="800" alt="802.11 MAC封包格式" />



另外封包中有四个地址，有两个用来表示工作站，两个表示经过的基地台，将表示地址和来去向的字段总结成下表：

| ToDS | FromDS | Addr1 | Addr2 | Addr3 | Addr4 |
| ---- | ------ | ----- | ----- | ----- | ----- |
| 0    | 0      | DA    | SA    | BSSID | N/A   |
| 0    | 1      | DA    | BSSID | SA    | N/A   |
| 1    | 0      | BSSID | SA    | DA    | N/A   |
| 1    | 1      | RA    | TA    | DA    | SA    |

  - BBSID：MAC address of an AP
  - SA：Original Source address
  - DA：Final Destination address
  - TA：Transmitter address
  - RA：Receiver address

上表中：

  - 第一行表示两个node直接互相发送信息
  - 最后一行是最复杂的情况，表示由一个基地台送到另一个基地台

当A向E发送消息时，封包中四个地址的变化如下：

  <img src="/images/network/DistributedSystem.png" width="400" alt="distributed system" />

  1. A => AP1：封包由A送给AP1，但最终的目的是E，四个地址为：|AP1|A|E|N/A|
  2. AP1 => AP3：封包由AP1送给AP3，起始是A，最终的目的地是E，四个地址为： |AP3|AP1|E|A|
  3. AP3 => E：封包由AP3送到E，起始是A，四个地址为：|E|AP3|A|N/A|

---

### 802.11 MAC Archetecture

  下图是无线环境下的MAC架构：

  <img src="/images/network/DCF&PCF.png" width="400" alt="DCF&PCF" />

  1. DCF：DCF本身提供竞争式服务，适合于没有即时性需求的，比如一般的信息、文件的传输

    - DCF使用的最关键的技术是CSMA/CA，CA只能做到尽量不冲撞，没有办法100%保证
    - DCF的使用权完全是分散式的，交由相连的node，大家去竞争使用权
    - 所有的节点、AP都需要有DCF并实现CSMA/CA
    - DCF的IFS要大于PCF的IFS，一般使用DIFS表示，优先级低于PCF
    - DCF可以建立在下面的结构上：
      - Ad hoc：不通过AP，直接是node之间的通信
      - 建立在一个基础设施之上，比如DS

  2. PCF：PCF建构在DCF上，使用竞争式的服务提供非竞争式的服务，会做比较优先权的控制。频宽和延迟都能得到保证，适合传送即时性信息，比如视频、音频

    - 实现的方式是通过设置某些参数(SIFS)，让PCF可以控制频宽的使用
    - PCF由point coordinator(通常就是基地台)来控制当前的频宽由谁来控制，下一个由谁来使用
    - point coordinator有一个清单，清单的内容是该AP服务的node本身。PC会按照这个List一个一个去轮询有没有信息要传送
    - PCF的高优先级，是通过Inter-Frame-Space(两个frame之间的时间间隔)参数实现的
    - PCF也是用CSMA/CA

  3. Super Frame

  下图是超级讯框的图示：

  <img src="/images/network/superFrame.png" width="400" alt="superFrame" />

    - AP会周期性的重复SF
    - 每一个SF的长度不固定
    - PCF和DCF的分割点也不固定


---

### DCF细节

1. 时间间隔

  每一个封包送完之后，其他节点都会监听channel上是idle还是busy，发现是idle，需要等一个*间隔*，当光等这一个间隔还是不够，还是会发生collision，所以还需要一个*random back-off*，这两个间隔共同作用能够尽量保证错开冲撞，但不能完全保证。

  所以DCF中有两个时间间隔：

  - IFS：就是上面提到的两个封包之间的时间间隔，有长短不同的三种：

    - SIFS：时间最短，用于RTS、CTS、ACK、station responding to poll
    - PIFS：时间长度中等，用于PCF环境下的封包
    - DIFS：时间最长，用于一般的数据封包，DCF环境下

  - random back-off：作用是尽量保证发送的公平和进一步错开可能的冲撞

2. ACK frame(MAC-Level ACK，Positive Acknowledgement)

  A送给B一个封包，如果B成功收到了，要*立刻*(立刻就是一个SIFS)返回一个ACK封包，表明这个封包发送成功，对方已经成功收到。

  也就是说：
    1. 必须返回一个ACK
    2. 这个ACK必须立刻返回
    3. 这个立刻使用最短间隔SIFS(short inter frame space)
    4. 需要返回ACK的场景(如果没有返回就会被以错误处理)
      - data
      - poll
      - probe request
      - probe response

3. Carrier sense的两种方式

  - physical：使用物理的形式，比如天线实际去侦听channel
  - virtual mechanism：比如CTS、RTS中带有发送和接受*所需的时间(duration time)*，就把这段时间当成busy。MAC提供的这种机制被称为NAV(Net Allocation Vector)，会根据duration field来做一段对未来traffic的预测。

4. 优先级

  就是上面描述的时间间隔，这里复制一下：

  - SIFS：时间最短，用于RTS、CTS、ACK、station responding to poll
  - PIFS：时间长度中等，用于PCF环境下的封包
  - DIFS：时间最长，用于一般的数据封包，DCF环境下


  时间越短，优先级越高。

5. Random Back-off Time

  back-off time = INT(CW × random()) × slot time

  上面公式中：
  - slot time = Transmitter turn-on delay + medium propagation delay + medium busy detect response time
  - random会生成一个随机数
  - CW指contention window，是CWmin(7)和CWmax(255)之间的一个整数，和第几次传输数据有关系，随着送的次数增大而增大。对于同一条数据，重送的次数越多，这个值越大，表明网络越拥挤

---

### DCF Access Procedure

1. CSMA/CA的运作方式

  802.3中node听到是idle可以立刻送；802.11中node听到是idle不能立刻送，以为此刻可能正介于发送ACK前的时间点。

  1. station送信息前，监听medium如果听到的是idle，在一个DIFS时长后，如果还是idle就可以送消息了
  2. 如果station听到的busy，就听完，再听一个DIFS时长后再加一个random back-off

  <img src="/images/network/DCFAccess.png" width="700" alt="DCFAccess" />

2. back-off procedure

  back-off time存在的主要目的是希望实现FCFS(first come first sercice)，达到公平的目的

  - 先计算一个CW
  - 计算出back-off time之后就开始倒计时，变成0才可以开始送封包
  - 如果在倒计时的过程中，侦测到medium变为busy状态，就暂停倒计时(frozen)
  - 当侦测到medium再次变为idle状态，且等了1个DIFS之后，medium依然为idle，才可以再次开启倒计时
  - 如果1个station刚刚发送了1个封包，准备好传送另一个，同样需要执行back-off过程(出于公平的目的)

  <img src="/images/network/backoffTime.png" width="800" alt="backoffTime" />

3. 设定NAV(Net allocation Vector)

  Duration filede的计算：from the end of the RTS or CTS frame until the end od the ACK frame

  <img src="/images/network/NAVsetting.png" width="800" alt="NAVsetting" />

4. 频道控制

  抢到channel控制权的station允许进行多次传送。

  <img src="/images/network/fragmentBurst.png" width="800" alt="fragmentBurst" />

  Once a station has contended for the channel, it will continue to send fragments until *either*：

  - all fragments(每一个fragment都对应一个ACK frame) of a station have been sent
  - an ack is not received(这种情况会在一个back-off time之后尝试重送，当过了这段时间后，sender station将在contention window中竞争控制权)
  - the station can not send any additional fragment due to a dwell time boundary(出于公平性，有控制时间的上限)

5. RTS/CTS在fragmentBurst中的使用

  - 如果有多个fragment，前1个data和ACK就扮演RTS和CTS的角色，定义下一个fragment和ACK的duration field
  - 最后一个fragment和ACK duration会被设置为0

    <img src="/images/network/fragmentBurstWithNAVsetting.png" width="800" alt="fragmentBurstWithNAVsetting" />

  - 如果目标工作站没有发出ACK，仅能听到目标工作站的station就不会再更新它们的NAV，这些station将能free to access the channel
  - 起始工作站没有收到ACK必须等到NAV(来自封包1)过期才能去竞争channel
  - all station will be free to access the channel after the NAV from 封包1 到时间

    <img src="/images/network/fragmentBurstWithNAVsettingWhenACKnotsent.png" width="800" alt="fragmentBurstWithNAVsettingWhenACKnotsent" />

  - 如果封包的大小太短，就不需要RTS、CTS(反而浪费带宽);如果比较大，就很有用，因为802.11会将封包完全发出，发出后又发生collision就会很浪费，所以大封包使用RTS/CTS才有意义。这个区分是否使用RTS/CTS的大小被称为*RTS-Threshhold*

    <img src="/images/network/DCMwithoutRTSandCTS.png" width="800" alt="DCMwithoutRTSandCTS" />

---

### PCF

1. The PCF provides contention free services
2. It is an option（PCF是station提供的，有的工作站有，有的没有）for a station to become the Point Coordination(PC), which genatates the Super Frame(SF)
3. PCF protocol基于polling scheme
4. PIFS小于DIFS，优先权高
5. PCF中有两类封包
    - node => cf-up封包 => PC
    - PC => cf-down封包 => node

---

### PCF Access Procedure

1. 一个SF开始，PC先侦测medium
2. 如果medium是idle，PC将等1个PIFS，然后传送
   1. Data frame with CF-Poll subtype bit，这是一个cf-down类型的封包，用来问station有无数据要传送，按轮询列表的顺序挨个征询
   2. 都征询完毕会广播一个cf-end frame
3. 不参与contention-free的station要将NAV设定为cf-period length的最大值(在每一次SF开始的时候)
4. 在PCF的结尾，所有收到cf-end frame 的station都会重置NAV，将其清零，在清零前都假设这个channel busy

---

### PCF Transfer Procedure

1. station必须立刻(这个立刻的时间就是SIFS)回复CF-Poll，否则就会被PC认定没有信息需要发送，转而去征询下一个station
2. a burst of CF traffic：就是PC按照列表上的顺序挨个去征询station，每次都执行相同的过程：PC先发一个CF-poll给station，station在1个SIFS后回复一个封包给PC
3. cf-up frame带有1个bit的cf-ack，用来表明成功送到以及验证封包的正确性

  <img src="/images/network/PCFprocedure.png" width="800" alt="PCFprocedure" />

4. 当被问的station需要将封包送给第三者，第三者返回1个ACk后经过1个SIFS，PC才能拿回轮询控制权，再去征询下一个

  <img src="/images/network/PCFprocedureWithStationToStation.png" width="800" alt="PCFprocedureWithStationToStation" />