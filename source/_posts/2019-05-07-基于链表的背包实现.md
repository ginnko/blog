---
layout: post
title: 基于链表的背包实现
date: 2019-05-07
tag: 
- algorithm
- 《算法》
- java
---

本文记录java中基于链表包的实现。有数据类型通用性，链表的大小可调整，能够迭代。

<!-- more -->

# 迭代的实现描述

  在集合数据类型中实现迭代的步骤：

  1. 添加并引用java的接口：`import java.util.Iterator`
  2. 在类声明中添加`implements Iterable<Item>`，这行代码保证了类必然会提供一个`iterator()`的方法。
  3. 在背包结构的具体实现中，`iterator()`方法本身只是简单地从实现了Iterator借口的类中返回了一个对象：

    ```java
      public Iterator<Item> iterator() {
        return new ListIterator();
      }
    ```
  4. 上面这段代码保证了类必然会实现方法`hasNext()`，`next()`以及`remove()`供用例的foreach语法使用，这也在下面的实现中表明。

# java实现

  ```java
    import edu.princeton.cs.algs4.StdIn;
    import edu.princeton.cs.algs4.StdOut;

    import java.util.Iterator;

    public class Bag<Item> implements Iterable<Item> {
      private Node first;
      private class Node {
        Item item;
        Node next;
      }
      public void add(Item item) {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
      }
      public Iterator<Item> iterator() {
        return new ListIterator();
      }
      private class ListIterator implements Iterator<Item> {
        private Node current = first;
        public boolean hasNext() {
          return current != null;
        }
        public Item next() {
          Item item = current.item;
          current = current.next;
          return item;
        }
      }
      public static void main(String[] args) {
        Bag<String> b = new Bag<String>();
        while (!StdIn.isEmpty()) {
          String item = StdIn.readString();
          if (!item.equals("-")) {
            b.add(item);
          }
        }

        for (String n : b) {
          StdOut.println(n+ " ");
        }
      }
    }
  ```
# 上述实现的特性

  满足上述描述的实现几乎达到了任意集合类数据类型的实现的最佳性能：

   - 每项操作的用时都与集合大小无关
   - 空间需求总是不超过集合大小乘以一个常数

# 参考

- 《算法》p96-p98