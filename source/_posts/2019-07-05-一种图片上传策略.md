---
layout: post
title: 一种图片上传策略
date: 2019-07-05
tag: 
- html5
- upload
---

## 背景

最近在写图片上传功能，使用antd提供的[upload组件](https://ant.design/components/upload-cn/)，并使用`beforeUpload`函数拦截，再批量读进浏览器之后手动上传。

## 第一次实现
传输使用的协议是http2，如果不做处理，并发传输的数量没有限制。第一次的实现使用`Promise.all`，并发传输，测试时，使用单张16.7M的图片，同时上传20张，会给后端带来不小的压力，多次测试中都会有部分图片上传失败，返回502或504。

使用`Promise.all`的实现方式带来的问题是：

1. 没有并发的数量限制，会占用大量带宽，同时给后端带来压力；
2. `Promise.all`的执行方式是全部成功才算成功，有一个失败即算失败，就会将这个失败的结果返回，不管其他的项是否完成，这带来的问题是每一个失败的err没有办法单独隔离处理，导致没有办法进行后续操作，比如单独重新上传，也就是说，使用`Promise.all`没有办法单独对每一项进行操作，限制了灵活度。

## 优化的上传策略

改进的实现使用下面这种传输策略：

**创建比如3个transmitter，点击发送发送按钮时，三个transmitter并发发出一张图片，哪个transmitter完成自己的发送任务，就去任务队列中拿下一张图片发送，直至全部图片发送完成。**

这样做能很好的解决第一次实现的问题。下面是传输策略的实现。

<!-- more -->

## 优化代码

```js
class Transmition {
  constructor(num, data, func, cb, handleErr) {
    this.num = num; // 这个属性用来控制transmitter的数量
    this.data = data; // 这个属性是数组类型，保存任务队列
    this.func = func; // 这个函数用来实际处理异步任务
    this.index = -1; // 这个属性用来存储当前的任务指针
    this.callback = cb; // 所有任务处理完成的回调函数
    this.len = data.length; // 任务的数量
    this.handleErr = handleErr; // 任务失败的处理函数
  }

  // 这个函数是用来实际执行任务的异步处理
  // 第一版是写进了transmit函数中
  // 但要写闭包保存index
  // 为了更清晰，单独拿出来写成一个函数
  executeTask = async (index, data) => {
    const { func } = this;
    try {
      await func(data, index);
      if (this.index === this.len) {
        this.callback();
      }
    } catch (e) {
      this.handleErr(e, data[index], index);
    }
  }

  // 这个函数表示的是单个transmitter的执行情况
  // await在这里很重要
  transmit = async () => {
    const { data } = this;
    let currentData = data[++this.index];
    while (currentData) {
      await this.executeTask(this.index, currentData);
      currentData = data[++this.index];
    }
  }

  // 根据num创建相应数量的transmitter
  // 并发启动
  createTransmitter = () => {
    const { num } = this;
    for (let i = 0; i < num; i++) {
      this.transmit();
    }
  }
}

 export default Transmition;

```

*注：transmit中的await关键字很重要，如果没写，会导致下图中的情景。*

![多核](/images/js/multipleCore.jpeg)

在写这篇的时候，突然想到，图片读进浏览器的过程是不是也可以使用这个策略实现，这样可以降低读入文件的压力，读完的文件也可以先显示，在交互上有比较好的反馈。