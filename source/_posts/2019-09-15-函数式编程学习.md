---
layout: post
title: 函数式编程学习
date: 2019-09-15
tag: 
- 函数式编程
---

正在学习redux的源码，感觉redux的实现很多地方都是基于函数式编程，函数式编程思想好像也在前端的很多库中都有广泛使用。为了更好的理解redux的源码，加深实现的记忆，也为了帮助日后学习其他库，现在插个空儿，入个函数式编程的门儿。

学习材料是列在最后的《JS函数式编程指南》的中文译本。

<!-- more -->

### 笔记

#### 第二章 一等公民的函数

看过这一章，有两点需要在日后的开发中注意：

1. 使用函数无论在赋值给变量还是作为参数传入函数，都要注意函数是一等公民
2. 变量、函数命名时要更具有通用性

关于上述第一点的理解，若日后不记得，可参考这里的[例子](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#%E4%B8%BA%E4%BD%95%E9%92%9F%E7%88%B1%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91)。

---

#### 第三章 纯函数

这一章主要讲了函数式编程中的重要概念，纯函数，以及纯函数的优点。

<!-- TODO 这里可以把之前看的redux中关于纯函数的使用放进来 -->

1. 纯函数的定义

> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

2. 作用

> 作用，我们可以理解为一切除结果计算之外发生的事情。

3. 副作用

> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。

副作用可能包含但不限于：

  - 更改文件系统
  - 往数据库插入记录
  - 发送一个http请求
  - 可变数据
  - 打印/log
  - 获取用户输入
  - DOM查询
  - 访问系统状态
  - 。。。

概括来讲，只要是跟函数外部环境发生的交互就都是副作用。

---

#### 第四章 函数柯里化

1. curry的概念

> 只传给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

curry的用途是参数复用，降低通用性，提高适用性。

<!-- TODO 再看下这个 -->
文中给出的例子可以进一步参考这里：https://github.com/lodash/lodash/wiki/FP-Guide#capped-iteratee-arguments

2. curry函数的实现

实现代码来自[参考资料2](https://github.com/mqyqingfeng/Blog/issues/42)第二版（使用占位符的第三版判断条件较多，过于复杂）。

```js
// 实现方式1

// sub_curry的作用就是用一个新的函数包裹原函数，然后给原函数传入之前的参数
function sub_curry(fn) {
  const args = [].slice.call(arguments, 1);
  return function() {
    // 此处实际已经执行
    return fn.apply(this, args.concat([].slice.call(arguments)));
  };
}

function curry(fn, length) {
  length = length || fn.length;
  return function() {
    if (arguments.length < length) {
      const combined = [fn].concat(Array.prototype.slice.call(arguments));
      // 注意：此处sub_curry.apply(this.combined)是执行了
      // 返回一个包裹了原函数和参数的新函数
      // 这个新函数用于获取后续参数
      return curry(sub_curry.apply(this, combined), length - arguments.length);
    } else {
      return fn.apply(this, aruments);
    }
  };
}

// 执行步骤分析
// 这里fn0是一个纯函数
// curry函数也是一个纯函数
// 下述步骤分析过程
// 使用了纯函数中的`等式推导`
// 也就是`引用透明`
const fn0 = function(a, b, c, d) {
  return [a, b, c, d];
}
const fn1 = curry(fn0);
fn1('a', 'b')('c')('d');

// 当执行fn1('a', 'b')时

// fn1('a', 'b')相当于
curry(fn0)('a', 'b');
// 相当于
curry(sub_curry(fn0, 'a', 'b'));
// 相当于
curry(function(..) {return fn0('a', 'b', ...)});

// 当执行fn1('a', 'b')('c')时

// fn1('a', 'b')('c')返回
curry(sub_curry(function(..) {return fn0('a', 'b', ...)}, 'c'));
// 相当于
curry(function(...) {return fn0('a', 'b', 'c', ...)});

// 当执行fn1('a', ''b)('c')('d')时，此时arguments.length < length 为false，执行fn(arguments)

// 相当于
(function(...) {
  return fn0('a', 'b', 'c', ...);
})('d)

// 相当于
fn0('a', 'b', 'c', 'd');

// 函数执行完毕

// =================================

// 实现方式2
// 这种方式更直观
// 每次只组合参数
// 最后一次性传入原函数中
// 而实现方式1是每次都会向原函数中传入参数但延迟执行
function curry(fn, args) {
  const length = fn.length;
  args = args || [];
  return function() {
    const _args = args.slice();
    let arg, i;
    for (i = 0; i < arguments.length; i++) {
      arg = arguments[i];
      _args.push(arg);
    }
    if (_args.length < length) {
      return curry.call(this, fn, _args);
    } else {
      return fn.apply(this, _args);
    }
  }
}

```

实现的本质是通过高阶函数，利用闭包递归保存每次传入的参数同时延迟业务函数的执行，只有当参数数量等于业务函数参数数量时，才执行业务函数计算结果。

---

### 参考资料

1. https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ （《JS函数式编程指南》）
2. https://github.com/mqyqingfeng/Blog/issues/42 （关于柯里化的资料）
3. https://github.com/lodash/lodash/wiki/FP-Guide#capped-iteratee-arguments （lodash中的fp关于《JS函数式编程指南》纯函数部分举的例子的描述）