---
layout: post
title: react源码学习之首次渲染调度更新的过程
date: 2020-07-15
tag: 
- react
- 源码
---


之前知道了首次渲染创建更新的过程，现在进入调度更新的过程（下图中的右侧部分，从scheduleUpdateOnFiber开始进入调度阶段）。

<!-- more -->


```mermaid
graph TD;

  render --> legacyRenderSubtreeIntoContainer;
  legacyRenderSubtreeIntoContainer --> legacyCreateRootFromDOMContainer;
  legacyCreateRootFromDOMContainer --> createLegacyRoot;
  createLegacyRoot --> ReactDOMBlockingRoot;
  ReactDOMBlockingRoot --> createRootImpl;
  createRootImpl --> createContainer;
  createContainer --> createFiberRoot;
  createFiberRoot --> FiberRootNode;
  createFiberRoot --> createHostRootFiber;
  createFiberRoot --> initializeUpdateQueue;
  createHostRootFiber --> createFiber;
  createFiber --> FiberNode;
  legacyRenderSubtreeIntoContainer --> unbatchedUpdates;
  unbatchedUpdates --> updateContainer;
  updateContainer --> requestCurrentTimeForUpdate;
  requestCurrentTimeForUpdate --> msToExpirationTime;
  msToExpirationTime --> getCurrentTime;
  updateContainer --> requestCurrentSuspenseConfig;
  updateContainer --> computeExpirationForFiber;
  updateContainer --> getContextForSubtree;
  updateContainer --> createUpdate;
  updateContainer --> enqueueUpdate;
  updateContainer --> scheduleUpdateOnFiber;
  scheduleUpdateOnFiber --> checkForNestedUpdates;
  scheduleUpdateOnFiber --> markUpdateTimeFromFiberToRoot;
  markUpdateTimeFromFiberToRoot --> markRootUpdatedAtTime;
  scheduleUpdateOnFiber --> getCurrentPriorityLevel;
  scheduleUpdateOnFiber --> schedulePendingInteractions;
  schedulePendingInteractions --> scheduleInteractions;
  scheduleUpdateOnFiber --> performSyncWorkOnRoot;
  performSyncWorkOnRoot --> renderRootSync；
```

|  函数名     |   参数(类型)    |   位置    |
|  ---  |  ---  |  ---  |
|scheduleUpdateOnFiber|fiber(Fiber)、expirationTime(ExpirationTime)|react-reconciler/src/ReactFiberWorkLoop|
|checkForNestedUpdates|-|react-reconciler/src/ReactFiberWorkLoop|
|markUpdateTimeFromFiberToRoot|-|react-reconciler/src/ReactFiberWorkLoop|
|markRootUpdatedAtTime|fiber(Fiber)、expirationTime(ExpirationTime)|react-reconciler/src/ReactFiberRoot|
|getCurrentPriorityLevel|-|react-reconciler/src/SchedulerWithReactIntegration|
|schedulePendingInteractions|-|react-reconciler/src/SchedulerWithReactIntegration|
|scheduleInteractions|root, expirationTime, interactions|react-reconciler/src/ReactFiberWorkLoop|
|performSyncWorkOnRoot|root(FiberRoot)|react-reconciler/src/ReactFiberWorkLoop|
|renderRootSync|root(FiberRoot), expirationTime|react-reconciler/src/ReactFiberWorkLoop|

---

### 函数调用

1. scheduleUpdateOnFiber

```js
  // export const NoContext = /*             */ 0b0000000;
  // const BatchedContext = /*               */ 0b0000001;
  // const EventContext = /*                 */ 0b0000010;
  // const DiscreteEventContext = /*         */ 0b0000100;
  // const LegacyUnbatchedContext = /*       */ 0b0001000;
  // const RenderContext = /*                */ 0b0010000;
  // const CommitContext = /*                */ 0b0100000;
  export function scheduleUpdateOnFiber(
    fiber: Fiber,
    expirationTime: ExpirationTime,
  ) {
    checkForNestedUpdates();
    // warnAboutRenderPhaseUpdatesInDEV(fiber); // 这个函数运行在测试环境
    // 首次渲染这个函数给FiberRoot的pendingTime设置了范围(firstPendingTime = MAX_SIGNED_31_BIT_INT, lastPendingTime = MAX_SIGNED_31_BIT_INT)
    const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
    if (root === null) {
      warnAboutUpdateOnUnmountedFiberInDEV(fiber);
      return;
    }

    // TODO: computeExpirationForFiber also reads the priority. Pass the
    // priority as an argument to that function and this one.
    const priorityLevel = getCurrentPriorityLevel(); // 首次渲染 NormalPriority = 3

    if (expirationTime === Sync) { // 首次渲染等于Sync
      // 首次渲染过程中，处理过executionContext的地方位于unbatchedUpdates中
      // 经过如下步骤：
      // const prevExecutionContext = executionContext;
      // executionContext &= ~BatchedContext;
      // executionContext |= LegacyUnbatchedContext;
      // 此时的executionContext中加入了LegacyUnbatchedContext，所以值为0b0001000，也就是8
      if (
        // Check if we're inside unbatchedUpdates
        (executionContext & LegacyUnbatchedContext) !== NoContext &&
        // Check if we're not already rendering
        (executionContext & (RenderContext | CommitContext)) === NoContext
      ) { // 首次渲染进入该分支
        // Register pending interactions on the root to avoid losing traced interaction data.
        schedulePendingInteractions(root, expirationTime);

        // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
        // root inside of batchedUpdates should be synchronous, but layout updates
        // should be deferred until the end of the batch.
        performSyncWorkOnRoot(root);
      } else {
        ensureRootIsScheduled(root);
        schedulePendingInteractions(root, expirationTime);
        if (executionContext === NoContext) {
          // Flush the synchronous work now, unless we're already working or inside
          // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
          // scheduleCallbackForFiber to preserve the ability to schedule a callback
          // without immediately flushing it. We only do this for user-initiated
          // updates, to preserve historical behavior of legacy mode.
          flushSyncCallbackQueue();
        }
      }
    } else {
      // Schedule a discrete update but only if it's not Sync.
      if (
        (executionContext & DiscreteEventContext) !== NoContext &&
        // Only updates at user-blocking priority or greater are considered
        // discrete, even inside a discrete event.
        (priorityLevel === UserBlockingPriority ||
          priorityLevel === ImmediatePriority)
      ) {
        // This is the result of a discrete event. Track the lowest priority
        // discrete update per root so we can flush them early, if needed.
        if (rootsWithPendingDiscreteUpdates === null) {
          rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);
        } else {
          const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);
          if (
            lastDiscreteTime === undefined ||
            lastDiscreteTime > expirationTime
          ) {
            rootsWithPendingDiscreteUpdates.set(root, expirationTime);
          }
        }
      }
      // Schedule other updates after in case the callback is sync.
      ensureRootIsScheduled(root);
      schedulePendingInteractions(root, expirationTime);
    }
  }
```

2. checkForNestedUpdates

```js
  const NESTED_UPDATE_LIMIT = 50;
  let nestedUpdateCount: number = 0;

  function checkForNestedUpdates() {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = null;
      invariant(
        false,
        'Maximum update depth exceeded. This can happen when a component ' +
          'repeatedly calls setState inside componentWillUpdate or ' +
          'componentDidUpdate. React limits the number of nested updates to ' +
          'prevent infinite loops.',
      );
    }
  }
```
3. markUpdateTimeFromFiberToRoot

传入该函数的fiber值：

```js
// ====================fiber============================
  {
    actualDuration: 0,
    actualStartTime: -1,
    alternate: null,
    child: null,
    childExpirationTime: NoWork, // 0
    dependencies_old: null,
    effectTag: NoEffect, // 0
    elementType: null,
    expirationTime: NoWork, // 0
    firstEffect: null,
    index: 0,
    key: null,
    lastEffect: null,
    memoizedProps: null,
    memoizedState: null,
    mode: NoMode, // 0
    nextEffect: null,
    pendingProps: null,
    ref: null,
    return: null,
    setBaseDuration: 0,
    sibling: null,
    stateNode: container,
    tag: HostRoot, // 3
    treeBaseDuration: 0,
    type: null,
    updateQueue: {
      baseState: null,
      effects: null,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
      },
    },
  }

  // ======================expirationTime==================

  MAX_SIGNED_31_BIT_INT, // 1073741823

  // ======================FiberRoot=======================

  {
    callbackNode: null,
    callbackPriority_old: Nopriority, // 90
    containerInfo: '<div id="root">', // dom元素()
    context: {},
    current,
    finishedExpirationTime: NoWork, // 0
    finishedWork: null,
    firstPendingTime: NoWork, // 0
    firstSuspendedTime: NoWork, // 0
    hydrate: false,
    interactionThreadID: 1,
    lastExpiredTime: NoWork, // 0
    lastPendingTime: NoWork, // 0
    lastPingedTime: NoWork, // 0
    lastSuspendedTime: NoWork, // 0
    memoizedInteractions: Set[],
    mutableSourceEagerHydrationData: null,
    mutableSourceLastPendingUpdateTime: NoWork, // 0
    nextKnownPendingLevel: NoWork, // 0
    pendingChildren: null,
    pendingContext: null,
    pendingInteractionMap_old: Map(0),
    pingCache: null,
    timeoutHandle: noTimeout, // -1
    tag: LegacyRoot, // 0
  }
```

```js
  let workInProgressRoot: FiberRoot | null = null;


  // This is split into a separate function so we can mark a fiber with pending
  // work without treating it as a typical update that originates from an event;
  // e.g. retrying a Suspense boundary isn't an update, but it does schedule work
  // on a fiber.
  function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
    // Update the source fiber's expiration time
    if (fiber.expirationTime < expirationTime) {
      fiber.expirationTime = expirationTime;
    }
    let alternate = fiber.alternate;
    if (alternate !== null && alternate.expirationTime < expirationTime) { // 首次渲染alternate是null，不会进入这个分支
      alternate.expirationTime = expirationTime;
    }

    // Walk the parent path to the root and update the child expiration time.
    let node = fiber.return; // 首次渲染，值为null
    let root = null;
    if (node === null && fiber.tag === HostRoot) { // 首次渲染进入该分支
      root = fiber.stateNode; // 首次渲染值为FiberRoot
    } else {
      while (node !== null) {
        alternate = node.alternate;
        if (node.childExpirationTime < expirationTime) {
          node.childExpirationTime = expirationTime;
          if (
            alternate !== null &&
            alternate.childExpirationTime < expirationTime
          ) {
            alternate.childExpirationTime = expirationTime;
          }
        } else if (
          alternate !== null &&
          alternate.childExpirationTime < expirationTime
        ) {
          alternate.childExpirationTime = expirationTime;
        }
        if (node.return === null && node.tag === HostRoot) {
          root = node.stateNode;
          break;
        }
        node = node.return;
      }
    }

    if (root !== null) {
      if (workInProgressRoot === root) { // 首次渲染 workInProgressRoot === null，不进入该分支
        // Received an update to a tree that's in the middle of rendering. Mark
        // that's unprocessed work on this root.
        markUnprocessedUpdateTime(expirationTime);

        if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
          // The root already suspended with a delay, which means this render
          // definitely won't finish. Since we have a new update, let's mark it as
          // suspended now, right before marking the incoming update. This has the
          // effect of interrupting the current render and switching to the update.
          // TODO: This happens to work when receiving an update during the render
          // phase, because of the trick inside computeExpirationForFiber to
          // subtract 1 from `renderExpirationTime` to move it into a
          // separate bucket. But we should probably model it with an exception,
          // using the same mechanism we use to force hydration of a subtree.
          // TODO: This does not account for low pri updates that were already
          // scheduled before the root started rendering. Need to track the next
          // pending expiration time (perhaps by backtracking the return path) and
          // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.
          markRootSuspendedAtTime(root, renderExpirationTime);
        }
      }
      // Mark that the root has a pending update.
      markRootUpdatedAtTime(root, expirationTime);
    }

    return root;
  }
```
4. markRootUpdatedAtTime

首次渲染的时候上面的函数没有执行实质性的操作，该函数做的实质性操作是给FiberRoot的pending times设置了范围

```js
// Mark that the root has a pending update.

export function markRootUpdatedAtTime(
  root: FiberRoot,
  expirationTime: ExpirationTime,
): void {
  // Update the range of pending times
  const firstPendingTime = root.firstPendingTime; // 首次渲染 NoWork = 0
  if (expirationTime > firstPendingTime) {
    root.firstPendingTime = expirationTime; // 首次渲染 MAX_SIGNED_31_BIT_INT = 1073741823
  }
  const lastPendingTime = root.lastPendingTime; // 首次渲染 NoWork = 0
  if (lastPendingTime === NoWork || expirationTime < lastPendingTime) {
    root.lastPendingTime = expirationTime; // 首次渲染 MAX_SIGNED_31_BIT_INT = 1073741823
  }

  // Update the range of suspended times. Treat everything lower priority or
  // equal to this update as unsuspended.
  const firstSuspendedTime = root.firstSuspendedTime; // 首次渲染 NoWork = 0
  if (firstSuspendedTime !== NoWork) { // 首次渲染不会进入该分支
    if (expirationTime >= firstSuspendedTime) {
      // The entire suspended range is now unsuspended.
      root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
    } else if (expirationTime >= root.lastSuspendedTime) {
      root.lastSuspendedTime = expirationTime + 1;
    }

    // This is a pending level. Check if it's higher priority than the next
    // known pending level.
    if (expirationTime > root.nextKnownPendingLevel) {
      root.nextKnownPendingLevel = expirationTime;
    }
  }
}
```
5. getCurrentPriorityLevel

```js
  export const NoPriority = 0;
  export const ImmediatePriority = 1;
  export const UserBlockingPriority = 2;
  export const NormalPriority = 3;
  export const LowPriority = 4;
  export const IdlePriority = 5;

  var currentPriorityLevel = NormalPriority;
  // Scheduler_getCurrentPriorityLevel就是unstable_getCurrentPriorityLevel
  function unstable_getCurrentPriorityLevel() {
    return currentPriorityLevel;
  }

  // ImmediatePriority as unstable_ImmediatePriority,
  // UserBlockingPriority as unstable_UserBlockingPriority,
  // NormalPriority as unstable_NormalPriority,
  // IdlePriority as unstable_IdlePriority,
  // LowPriority as unstable_LowPriority,

  // unstable_ImmediatePriority: Scheduler_ImmediatePriority,
  // unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,
  // unstable_NormalPriority: Scheduler_NormalPriority,
  // unstable_LowPriority: Scheduler_LowPriority,
  // unstable_IdlePriority: Scheduler_IdlePriority,

  function getCurrentPriorityLevel(): ReactPriorityLevel {
    switch (Scheduler_getCurrentPriorityLevel()) {
      case Scheduler_ImmediatePriority:
        return ImmediatePriority;
      case Scheduler_UserBlockingPriority:
        return UserBlockingPriority;
      case Scheduler_NormalPriority:
        return NormalPriority;
      case Scheduler_LowPriority:
        return LowPriority;
      case Scheduler_IdlePriority:
        return IdlePriority;
      default:
        invariant(false, 'Unknown priority level.');
    }
  }
```
首次渲染返回的结果是NormalPriority

6. schedulePendingInteractions

```js
  function schedulePendingInteractions(root, expirationTime) {
    // This is called when work is scheduled on a root.
    // It associates the current interactions with the newly-scheduled expiration.
    // They will be restored when that expiration is later committed.
    if (!enableSchedulerTracing) { // enableSchedulerTracing = true
      return;
    }
    scheduleInteractions(root, expirationTime, __interactionsRef.current); // __interactionsRef.current = Set[]
  }
```

代码中的`__interactionsRef`初始值是null，但何时更改了新值完全没发现。。。最一开始调用`createElement`的时候就已经是此处看到的值了。。。

7. scheduleInteractions

首次渲染，不进入任何分支

```js
  function scheduleInteractions(root, expirationTime, interactions) {
    if (!enableSchedulerTracing) {
      return;
    }

    if (interactions.size > 0) {
      const pendingInteractionMap = root.pendingInteractionMap_old;
      const pendingInteractions = pendingInteractionMap.get(expirationTime);
      if (pendingInteractions != null) {
        interactions.forEach(interaction => {
          if (!pendingInteractions.has(interaction)) {
            // Update the pending async work count for previously unscheduled interaction.
            interaction.__count++;
          }

          pendingInteractions.add(interaction);
        });
      } else {
        pendingInteractionMap.set(expirationTime, new Set(interactions));

        // Update the pending async work count for the current interactions.
        interactions.forEach(interaction => {
          interaction.__count++;
        });
      }

      const subscriber = __subscriberRef.current;
      if (subscriber !== null) {
        const threadID = computeThreadID(root, expirationTime);
        subscriber.onWorkScheduled(interactions, threadID);
      }
    }
  }
```

8. performSyncWorkOnRoot

首次渲染走同步流程

```js
  // This is the entry point for synchronous tasks that don't go
  // through Scheduler
  function performSynliuchengcWorkOnRoot(root) {
    invariant(
      (executionContext & (RenderContext | CommitContext)) === NoContext,
      'Should not already be working.',
    );

    flushPassiveEffects(); // 首次渲染内部不会进入分支，直接跳出

    const lastExpiredTime = root.lastExpiredTime; // 首次渲染NoWork

    let expirationTime;
    if (lastExpiredTime !== NoWork) {
      // There's expired work on this root. Check if we have a partial tree
      // that we can reuse.
      if (
        root === workInProgressRoot &&
        renderExpirationTime >= lastExpiredTime
      ) {
        // There's a partial tree with equal or greater than priority than the
        // expired level. Finish rendering it before rendering the rest of the
        // expired work.
        expirationTime = renderExpirationTime;
      } else {
        // Start a fresh tree.
        expirationTime = lastExpiredTime;
      }
    } else {
      // There's no expired work. This must be a new, synchronous render.
      expirationTime = Sync; // 首次渲染 MAX_SIGNED_31_BIT_INT 1073741823
    }

    let exitStatus = renderRootSync(root, expirationTime);

    if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
      executionContext |= RetryAfterError;

      // If an error occurred during hydration,
      // discard server response and fall back to client side render.
      if (root.hydrate) {
        root.hydrate = false;
        clearContainer(root.containerInfo);
      }

      // If something threw an error, try rendering one more time. We'll
      // render synchronously to block concurrent data mutations, and we'll
      // render at Idle (or lower) so that all pending updates are included.
      // If it still fails after the second attempt, we'll give up and commit
      // the resulting tree.
      expirationTime = expirationTime > Idle ? Idle : expirationTime;
      exitStatus = renderRootSync(root, expirationTime);
    }

    if (exitStatus === RootFatalErrored) {
      const fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, expirationTime);
      markRootSuspendedAtTime(root, expirationTime);
      ensureRootIsScheduled(root);
      throw fatalError;
    }

    // We now have a consistent tree. Because this is a sync render, we
    // will commit it even if something suspended.
    const finishedWork: Fiber = (root.current.alternate: any);
    root.finishedWork = finishedWork;
    root.finishedExpirationTime = expirationTime;
    root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
    commitRoot(root);

    // Before exiting, make sure there's a callback scheduled for the next
    // pending level.
    ensureRootIsScheduled(root);

    return null;
  }
```

9. renderRootSync

```js
  function renderRootSync(root, expirationTime) {
    const prevExecutionContext = executionContext;
    executionContext |= RenderContext;
    const prevDispatcher = pushDispatcher(root);

    // If the root or expiration time have changed, throw out the existing stack
    // and prepare a fresh one. Otherwise we'll continue where we left off.
    if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {
      prepareFreshStack(root, expirationTime);
      startWorkOnPendingInteractions(root, expirationTime);
    }

    const prevInteractions = pushInteractions(root);

    do {
      try {
        workLoopSync();
        break;
      } catch (thrownValue) {
        handleError(root, thrownValue);
      }
    } while (true);
    resetContextDependencies();
    if (enableSchedulerTracing) {
      popInteractions(((prevInteractions: any): Set<Interaction>));
    }

    executionContext = prevExecutionContext;
    popDispatcher(prevDispatcher);

    if (workInProgress !== null) {
      // This is a sync render, so we should have finished the whole tree.
      invariant(
        false,
        'Cannot commit an incomplete root. This error is likely caused by a ' +
          'bug in React. Please file an issue.',
      );
    }

    // Set this to null to indicate there's no in-progress render.
    workInProgressRoot = null;

    return workInProgressRootExitStatus;
  }
```







---

### 参考资料