---
layout: post
title: 关于promise的理解
date: 2019-04-28
tag:
- javascript
- Promise
---

# 基于回调函数的异步编程

>回调函数真正的问题在于它剥夺了我们使用return和throw这些关键字的能力。相反，我们的整个diamante流程都是基于副作用的：一个函数会附带调用其他函数。<sup>1</sup>

>并且，它会将我们通常在大部分编程语言中能获得的堆栈破坏。<sup>1</sup>

>**`Primise`给予我们的是在我们使用异步时丢失的最重要的语言基石：`return`，`throw`以及`堆栈`。**<sup>1</sup>

<!-- more -->

# promise是什么

>promise是一种代码结构和流程<sup>1</sup>

>依照 promises 规范，一旦一个 promise 被创建，它就被执行了。<sup>1</sup>

# 使用promise

1. 在then()函数内部能处理的事情

```js
somePromise().then(function() {
  // I'm inside a then() function
});
```

可以处理以下三件事<sup>1</sup>：
  
  - return另外一个promise：这个用在`composing promises`写法中
  - return 一个 **同步** 的值(或者undefined)

    下面第二个函数不需要关心`userAccount`是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步的值。
    ```js
      getUserByName('nolan').then(function (user) {
        if (inMemoryCache[user.id]) {
          return inMemoryCache[user.id];    // returning a synchronous value!
        }
        return getUserAccountById(user.id); // returning a promise!
      }).then(function (userAccount) {
        // I got a user account!
      });
    ```

    一个好的习惯：**在then()函数内部，永远返回或抛出**
  - throw一个 **同步** 异常：catch()函数在捕获异常的时候，不关心异常是同步的还是异步的

    >任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。

    可以 **直接** 使用`Promise.resolve`来进行同步或异步的封装，`Promise.reject()`同理。

2. 永远都是往 then() 中传递函数<sup>1</sup>


参考:

1. http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/