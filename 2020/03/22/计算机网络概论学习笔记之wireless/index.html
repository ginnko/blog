
<!DOCTYPE html>
<html lang="">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-139540194-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-139540194-1');
</script>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  <!-- <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6846579683645896",
    enable_page_level_ads: true
  });
</script> -->
  
  
    <meta name="keywords" content="网络,">
  

  
    <meta name="description" content="《计算机网络概论》学习笔记整理之wireless LAN">
  
  
  <link rel="icon" type="image/x-icon" href="https://ginnko.github.io/images/ginnko.jpeg">
  <title>《计算机网络概论》学习笔记整理之wireless LAN [ Ginnko&#39;s ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="https://ginnko.github.io/images/ginnko.jpeg">
    <span class="title">Ginnko&#39;s</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
          
            <li class="pure-menu-item"><a href="https://github.com/ginnko" class="pure-menu-link">关于</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <div class="left-ads-container">
      

<div id="ads-left" class="ads-left">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- left -->
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6846579683645896" data-ad-slot="9201612849" data-ad-format="auto" data-full-width-responsive="true"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
  </div>
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        《计算机网络概论》学习笔记整理之wireless LAN
      </h1>
      <span>
        
        <time class="time" datetime="2020-03-21T16:00:00.000Z">
        2020-03-22
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 24 分钟</span>
    </header>

    <div class="post-content">
      <p>在上一篇概述的基础上探讨wireless的运作原理，主要涉及以下10个方面：</p>
<ol>
<li>无线的两种重要特征</li>
<li>无线采用的协议是CSMA/CA而不是CSMA/CD</li>
<li>RTC/CTS的作用和工作原理</li>
<li>ACK存在的作用和工作过程</li>
<li>carrier sense的方式</li>
<li>CSMA/CA的工作方式</li>
<li>3个priority的级别：SIFS &lt; PIFS &lt; DIFS</li>
<li>DCF运行原理</li>
<li>PCF运行原理</li>
<li>SuperFrame运行原理</li>
</ol>
<a id="more"></a>
<hr>
<h3 id="IEEE802-11标准"><a href="#IEEE802-11标准" class="headerlink" title="IEEE802.11标准"></a>IEEE802.11标准</h3><p>无线技术使用的标准是：<em>IEEE802.11</em>，这个标准用来处理有限区域(比如家庭、办公室、校园)的无线传输。传输介质是空气(通过空气广播)，这个标准还规定了：电源管理和安全机制。</p>
<p>该标准使用的协议是：CSMA/CA，Carrier Sense Multiple Access with Collision Avoidance</p>
<p>该标准定义了2种物理层实现，以解决信息互相干扰的问题，具体情况不清楚，也不感兴趣：</p>
<ol>
<li>frequency hopping(跳频技术)：把信息切分到不同的频道发送</li>
<li>direct sequence：对不同的频道进行不同的加密</li>
</ol>
<hr>
<h3 id="无线传输的2个重要特征"><a href="#无线传输的2个重要特征" class="headerlink" title="无线传输的2个重要特征"></a>无线传输的2个重要特征</h3><ol>
<li><p>hidden node problem(hidden terminal)</p>
<p>下图中，A、C两个节点虽然听不到对方的信号，但同时传送给相同的节点B，会造成双方的信号碰撞，导致各自的封包都失效。</p>
<p>在无线环境中，没有办法侦测到collision。</p>
</li>
</ol>
<p><img src="/images/network/hiddenNodeProblem.png" width="400" alt="hidden node problem"></p>
<ol>
<li><p>exposed node problem</p>
<p>双方虽然听得到对方的信号，但同时传送给不同的节点不会发生干扰</p>
</li>
</ol>
<hr>
<h3 id="CSMA-CA协议中的封包"><a href="#CSMA-CA协议中的封包" class="headerlink" title="CSMA/CA协议中的封包"></a>CSMA/CA协议中的封包</h3><ol>
<li><p>封包类型</p>
<ul>
<li><p>control frames</p>
<ul>
<li>RTS</li>
<li>CTS</li>
<li>ACK</li>
<li>POLL</li>
</ul>
</li>
<li><p>management frams</p>
<ul>
<li>Probe Request/Response</li>
<li>Beacon(用于扫描)</li>
<li>Authentication(验证)</li>
</ul>
</li>
<li><p>标准封包</p>
<ul>
<li>data</li>
</ul>
</li>
</ul>
</li>
<li><p>RTS和CTS</p>
<p>RTS和CTS都是control frame类型的封包，作用是告诉起始工作站和目的地工作站范围内的其他节点，有信息将要开始传送，不要同时发送干扰。</p>
<ul>
<li>RTS：Request to send，用于宣告要送的封包，附带有需要多长时间发送</li>
<li>CTS：Clear to send，用于宣告将要收封包，并附带需要多长时间接受</li>
</ul>
<p>RTS和CTS都以广播的形式在工作站范围内发送，下图的场景是B将向C发送信息，B先发送一个RTS，C收到后，发送一个CTS：</p>
<p><img src="/images/network/RTS&CTS.png" width="400" alt="RTS和CTS"></p>
<ul>
<li>B、D同时给C发送封包就会发生hidden terminal问题</li>
<li>所有蓝色范围内的工作站，即听到CTS的等下都不能向C发送信号，但这些节点可以给其他节点发送</li>
</ul>
<p>后面将整理这两个封包实际是如何工作的。</p>
</li>
<li><p>ACK frame</p>
<p>这个控制封包用来在一个节点成功收到另一个节点发来的信息，且信息无误的情况下，会向源头节点返回一个ACK封包，表明刚才那个信息成功收到。</p>
</li>
</ol>
<hr>
<h3 id="802-11分散式系统DS-distributed-system"><a href="#802-11分散式系统DS-distributed-system" class="headerlink" title="802.11分散式系统DS(distributed system)"></a>802.11分散式系统DS(distributed system)</h3><ol>
<li><p>现状：在无线环境中，node可以移动，并且是不完全连接(经由1~2次hub连接起来)(没搞明白什么叫不完全连接，没查到，不影响理解，直接跳过)</p>
</li>
<li><p>node被分为两类：</p>
<pre><code>1. 允许移动的：手机，笔记本电脑
2. 和有线网络相连的：AP(AP和后端建设的基础设施相连，这个基础设施就是DS，DS会将多个AP连接起来)
</code></pre></li>
<li><p>分散式系统</p>
<p>DS是layer2的系统，下面是它的原理图：</p>
<p><img src="/images/network/DistributedSystem.png" width="400" alt="distributed system"></p>
<p>分散式系统的目的：用分散式系统将多个AP连接起来，让802.11覆盖的范围更广</p>
<ol start="4">
<li>扫描</li>
</ol>
<p>由上图可见，每一个AP都会覆盖一些节点，节点B处在AP1和AP2两个范围内，这就涉及到node选择AP的问题。有两种情况需要扫描：</p>
<ol>
<li>节点刚进入无线环境</li>
<li><p>node从一个AP范围进入另一个AP范围</p>
</li>
<li><p>扫描的类型</p>
</li>
</ol>
<ul>
<li><p>主动扫描</p>
<ol>
<li>笔电或者手机送一个probe frame(问一下周围有哪些基地台听到的我)</li>
<li>所有在范围里能听到的AP都会回一个probe Response frame</li>
<li>node会从这些回应的AP里选一个向这个AP发送一个Association Request Frame，通常会选信号强、速度快的</li>
<li>AP回复一个Association Response Frame后建立连接</li>
</ol>
</li>
<li><p>被动扫描</p>
<ol>
<li>AP会周期性的发送Beacon frame，告知自身的能力，包括其支持的transmission rate</li>
<li>node如果要连接会发送一个Association Request frame给该AP</li>
<li>AP再回复一个Association Response frame建立连接</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="802-11-MAC封包格式"><a href="#802-11-MAC封包格式" class="headerlink" title="802.11 MAC封包格式"></a>802.11 MAC封包格式</h3><p>  下面是一个MAC分包：</p>
<p>  <img src="/images/network/MACFrameFormat.png" width="800" alt="802.11 MAC封包格式"></p>
<p>另外封包中有四个地址，有两个用来表示工作站，两个表示经过的基地台，将表示地址和来去向的字段总结成下表：</p>
<table>
<thead>
<tr>
<th>ToDS</th>
<th>FromDS</th>
<th>Addr1</th>
<th>Addr2</th>
<th>Addr3</th>
<th>Addr4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>DA</td>
<td>SA</td>
<td>BSSID</td>
<td>N/A</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>DA</td>
<td>BSSID</td>
<td>SA</td>
<td>N/A</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>BSSID</td>
<td>SA</td>
<td>DA</td>
<td>N/A</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>RA</td>
<td>TA</td>
<td>DA</td>
<td>SA</td>
</tr>
</tbody>
</table>
<ul>
<li>BBSID：MAC address of an AP</li>
<li>SA：Original Source address</li>
<li>DA：Final Destination address</li>
<li>TA：Transmitter address</li>
<li>RA：Receiver address</li>
</ul>
<p>上表中：</p>
<ul>
<li>第一行表示两个node直接互相发送信息</li>
<li>最后一行是最复杂的情况，表示由一个基地台送到另一个基地台</li>
</ul>
<p>当A向E发送消息时，封包中四个地址的变化如下：</p>
<p>  <img src="/images/network/DistributedSystem.png" width="400" alt="distributed system"></p>
<ol>
<li>A =&gt; AP1：封包由A送给AP1，但最终的目的是E，四个地址为：|AP1|A|E|N/A|</li>
<li>AP1 =&gt; AP3：封包由AP1送给AP3，起始是A，最终的目的地是E，四个地址为： |AP3|AP1|E|A|</li>
<li>AP3 =&gt; E：封包由AP3送到E，起始是A，四个地址为：|E|AP3|A|N/A|</li>
</ol>
<hr>
<h3 id="802-11-MAC-Archetecture"><a href="#802-11-MAC-Archetecture" class="headerlink" title="802.11 MAC Archetecture"></a>802.11 MAC Archetecture</h3><p>  下图是无线环境下的MAC架构：</p>
<p>  <img src="/images/network/DCF&PCF.png" width="400" alt="DCF&PCF"></p>
<ol>
<li><p>DCF：DCF本身提供竞争式服务，适合于没有即时性需求的，比如一般的信息、文件的传输</p>
<ul>
<li>DCF使用的最关键的技术是CSMA/CA，CA只能做到尽量不冲撞，没有办法100%保证</li>
<li>DCF的使用权完全是分散式的，交由相连的node，大家去竞争使用权</li>
<li>所有的节点、AP都需要有DCF并实现CSMA/CA</li>
<li>DCF的IFS要大于PCF的IFS，一般使用DIFS表示，优先级低于PCF</li>
<li>DCF可以建立在下面的结构上：<ul>
<li>Ad hoc：不通过AP，直接是node之间的通信</li>
<li>建立在一个基础设施之上，比如DS</li>
</ul>
</li>
</ul>
</li>
<li><p>PCF：PCF建构在DCF上，使用竞争式的服务提供非竞争式的服务，会做比较优先权的控制。频宽和延迟都能得到保证，适合传送即时性信息，比如视频、音频</p>
<ul>
<li>实现的方式是通过设置某些参数(SIFS)，让PCF可以控制频宽的使用</li>
<li>PCF由point coordinator(通常就是基地台)来控制当前的频宽由谁来控制，下一个由谁来使用</li>
<li>point coordinator有一个清单，清单的内容是该AP服务的node本身。PC会按照这个List一个一个去轮询有没有信息要传送</li>
<li>PCF的高优先级，是通过Inter-Frame-Space(两个frame之间的时间间隔)参数实现的</li>
<li>PCF也是用CSMA/CA</li>
</ul>
</li>
<li><p>Super Frame</p>
<p>下图是超级讯框的图示：</p>
<p><img src="/images/network/superFrame.png" width="400" alt="superFrame"></p>
<ul>
<li>AP会周期性的重复SF</li>
<li>每一个SF的长度不固定</li>
<li>PCF和DCF的分割点也不固定</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DCF细节"><a href="#DCF细节" class="headerlink" title="DCF细节"></a>DCF细节</h3><ol>
<li><p>时间间隔</p>
<p>每一个封包送完之后，其他节点都会监听channel上是idle还是busy，发现是idle，需要等一个<em>间隔</em>，当光等这一个间隔还是不够，还是会发生collision，所以还需要一个<em>random back-off</em>，这两个间隔共同作用能够尽量保证错开冲撞，但不能完全保证。</p>
<p>所以DCF中有两个时间间隔：</p>
<ul>
<li><p>IFS：就是上面提到的两个封包之间的时间间隔，有长短不同的三种：</p>
<ul>
<li>SIFS：时间最短，用于RTS、CTS、ACK、station responding to poll</li>
<li>PIFS：时间长度中等，用于PCF环境下的封包</li>
<li>DIFS：时间最长，用于一般的数据封包，DCF环境下</li>
</ul>
</li>
<li><p>random back-off：作用是尽量保证发送的公平和进一步错开可能的冲撞</p>
</li>
</ul>
</li>
<li><p>ACK frame(MAC-Level ACK，Positive Acknowledgement)</p>
<p>A送给B一个封包，如果B成功收到了，要<em>立刻</em>(立刻就是一个SIFS)返回一个ACK封包，表明这个封包发送成功，对方已经成功收到。</p>
<p>也就是说：</p>
<ol>
<li>必须返回一个ACK</li>
<li>这个ACK必须立刻返回</li>
<li>这个立刻使用最短间隔SIFS(short inter frame space)</li>
<li>需要返回ACK的场景(如果没有返回就会被以错误处理)<ul>
<li>data</li>
<li>poll</li>
<li>probe request</li>
<li>probe response</li>
</ul>
</li>
</ol>
</li>
<li><p>Carrier sense的两种方式</p>
<ul>
<li>physical：使用物理的形式，比如天线实际去侦听channel</li>
<li>virtual mechanism：比如CTS、RTS中带有发送和接受<em>所需的时间(duration time)</em>，就把这段时间当成busy。MAC提供的这种机制被称为NAV(Net Allocation Vector)，会根据duration field来做一段对未来traffic的预测。</li>
</ul>
</li>
<li><p>优先级</p>
<p>就是上面描述的时间间隔，这里复制一下：</p>
<ul>
<li>SIFS：时间最短，用于RTS、CTS、ACK、station responding to poll</li>
<li>PIFS：时间长度中等，用于PCF环境下的封包</li>
<li>DIFS：时间最长，用于一般的数据封包，DCF环境下</li>
</ul>
</li>
</ol>
<p>  时间越短，优先级越高。</p>
<ol start="5">
<li><p>Random Back-off Time</p>
<p>back-off time = INT(CW × random()) × slot time</p>
<p>上面公式中：</p>
<ul>
<li>slot time = Transmitter turn-on delay + medium propagation delay + medium busy detect response time</li>
<li>random会生成一个随机数</li>
<li>CW指contention window，是CWmin(7)和CWmax(255)之间的一个整数，和第几次传输数据有关系，随着送的次数增大而增大。对于同一条数据，重送的次数越多，这个值越大，表明网络越拥挤</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DCF-Access-Procedure"><a href="#DCF-Access-Procedure" class="headerlink" title="DCF Access Procedure"></a>DCF Access Procedure</h3><ol>
<li><p>CSMA/CA的运作方式</p>
<p>802.3中node听到是idle可以立刻送；802.11中node听到是idle不能立刻送，以为此刻可能正介于发送ACK前的时间点。</p>
<ol>
<li>station送信息前，监听medium如果听到的是idle，在一个DIFS时长后，如果还是idle就可以送消息了</li>
<li>如果station听到的busy，就听完，再听一个DIFS时长后再加一个random back-off</li>
</ol>
<p><img src="/images/network/DCFAccess.png" width="700" alt="DCFAccess"></p>
</li>
<li><p>back-off procedure</p>
<p>back-off time存在的主要目的是希望实现FCFS(first come first sercice)，达到公平的目的</p>
<ul>
<li>先计算一个CW</li>
<li>计算出back-off time之后就开始倒计时，变成0才可以开始送封包</li>
<li>如果在倒计时的过程中，侦测到medium变为busy状态，就暂停倒计时(frozen)</li>
<li>当侦测到medium再次变为idle状态，且等了1个DIFS之后，medium依然为idle，才可以再次开启倒计时</li>
<li>如果1个station刚刚发送了1个封包，准备好传送另一个，同样需要执行back-off过程(出于公平的目的)</li>
</ul>
<p><img src="/images/network/backoffTime.png" width="800" alt="backoffTime"></p>
</li>
<li><p>设定NAV(Net allocation Vector)</p>
<p>Duration filede的计算：from the end of the RTS or CTS frame until the end od the ACK frame</p>
<p><img src="/images/network/NAVsetting.png" width="800" alt="NAVsetting"></p>
</li>
<li><p>频道控制</p>
<p>抢到channel控制权的station允许进行多次传送。</p>
<p><img src="/images/network/fragmentBurst.png" width="800" alt="fragmentBurst"></p>
<p>Once a station has contended for the channel, it will continue to send fragments until <em>either</em>：</p>
<ul>
<li>all fragments(每一个fragment都对应一个ACK frame) of a station have been sent</li>
<li>an ack is not received(这种情况会在一个back-off time之后尝试重送，当过了这段时间后，sender station将在contention window中竞争控制权)</li>
<li>the station can not send any additional fragment due to a dwell time boundary(出于公平性，有控制时间的上限)</li>
</ul>
</li>
<li><p>RTS/CTS在fragmentBurst中的使用</p>
<ul>
<li>如果有多个fragment，前1个data和ACK就扮演RTS和CTS的角色，定义下一个fragment和ACK的duration field</li>
<li><p>最后一个fragment和ACK duration会被设置为0</p>
<p><img src="/images/network/fragmentBurstWithNAVsetting.png" width="800" alt="fragmentBurstWithNAVsetting"></p>
</li>
<li><p>如果目标工作站没有发出ACK，仅能听到目标工作站的station就不会再更新它们的NAV，这些station将能free to access the channel</p>
</li>
<li>起始工作站没有收到ACK必须等到NAV(来自封包1)过期才能去竞争channel</li>
<li><p>all station will be free to access the channel after the NAV from 封包1 到时间</p>
<p><img src="/images/network/fragmentBurstWithNAVsettingWhenACKnotsent.png" width="800" alt="fragmentBurstWithNAVsettingWhenACKnotsent"></p>
</li>
<li><p>如果封包的大小太短，就不需要RTS、CTS(反而浪费带宽);如果比较大，就很有用，因为802.11会将封包完全发出，发出后又发生collision就会很浪费，所以大封包使用RTS/CTS才有意义。这个区分是否使用RTS/CTS的大小被称为<em>RTS-Threshhold</em></p>
<p><img src="/images/network/DCMwithoutRTSandCTS.png" width="800" alt="DCMwithoutRTSandCTS"></p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h3><ol>
<li>The PCF provides contention free services</li>
<li>It is an option（PCF是station提供的，有的工作站有，有的没有）for a station to become the Point Coordination(PC), which genatates the Super Frame(SF)</li>
<li>PCF protocol基于polling scheme</li>
<li>PIFS小于DIFS，优先权高</li>
<li>PCF中有两类封包<ul>
<li>node =&gt; cf-up封包 =&gt; PC</li>
<li>PC =&gt; cf-down封包 =&gt; node</li>
</ul>
</li>
</ol>
<hr>
<h3 id="PCF-Access-Procedure"><a href="#PCF-Access-Procedure" class="headerlink" title="PCF Access Procedure"></a>PCF Access Procedure</h3><ol>
<li>一个SF开始，PC先侦测medium</li>
<li>如果medium是idle，PC将等1个PIFS，然后传送<ol>
<li>Data frame with CF-Poll subtype bit，这是一个cf-down类型的封包，用来问station有无数据要传送，按轮询列表的顺序挨个征询</li>
<li>都征询完毕会广播一个cf-end frame</li>
</ol>
</li>
<li>不参与contention-free的station要将NAV设定为cf-period length的最大值(在每一次SF开始的时候)</li>
<li>在PCF的结尾，所有收到cf-end frame 的station都会重置NAV，将其清零，在清零前都假设这个channel busy</li>
</ol>
<hr>
<h3 id="PCF-Transfer-Procedure"><a href="#PCF-Transfer-Procedure" class="headerlink" title="PCF Transfer Procedure"></a>PCF Transfer Procedure</h3><ol>
<li>station必须立刻(这个立刻的时间就是SIFS)回复CF-Poll，否则就会被PC认定没有信息需要发送，转而去征询下一个station</li>
<li>a burst of CF traffic：就是PC按照列表上的顺序挨个去征询station，每次都执行相同的过程：PC先发一个CF-poll给station，station在1个SIFS后回复一个封包给PC</li>
<li><p>cf-up frame带有1个bit的cf-ack，用来表明成功送到以及验证封包的正确性</p>
<p><img src="/images/network/PCFprocedure.png" width="800" alt="PCFprocedure"></p>
</li>
<li><p>当被问的station需要将封包送给第三者，第三者返回1个ACk后经过1个SIFS，PC才能拿回轮询控制权，再去征询下一个</p>
<p><img src="/images/network/PCFprocedureWithStationToStation.png" width="800" alt="PCFprocedureWithStationToStation"></p>
</li>
</ol>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE802-11标准"><span class="toc-text">IEEE802.11标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无线传输的2个重要特征"><span class="toc-text">无线传输的2个重要特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSMA-CA协议中的封包"><span class="toc-text">CSMA/CA协议中的封包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#802-11分散式系统DS-distributed-system"><span class="toc-text">802.11分散式系统DS(distributed system)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#802-11-MAC封包格式"><span class="toc-text">802.11 MAC封包格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#802-11-MAC-Archetecture"><span class="toc-text">802.11 MAC Archetecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DCF细节"><span class="toc-text">DCF细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DCF-Access-Procedure"><span class="toc-text">DCF Access Procedure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCF"><span class="toc-text">PCF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCF-Access-Procedure"><span class="toc-text">PCF Access Procedure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCF-Transfer-Procedure"><span class="toc-text">PCF Transfer Procedure</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<!-- <div class="share" style="width: 100%;">
  <img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-10-qrcode_for_gh_ffacf5722095_258.jpg" alt="Running Geek" style="margin: auto; display: block;"/>

  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">老铁们关注走一走，不迷路</div>
  
</div> -->

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/03/12/计算机网络概论学习笔记之Ethernet/" rel="next" title="《计算机网络概论》学习笔记整理之Ethernet">
          《计算机网络概论》学习笔记整理之Ethernet
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/04/03/计算机网络概论学习笔记之bridge/" rel="prev" title="《计算机网络概论》学习笔记整理之bridge">
            《计算机网络概论》学习笔记整理之bridge
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

<div id="vcomments" class="vcomments"></div>
<script>
  new Valine({
    el: '#vcomments' ,
    appId: 'Fe5TNm20tHsqA6hpF5LHADO3-gzGzoHsz',
    appKey: 'nHYuy325r0l9GBVGIm2iCr0y',
    notify:true, 
    // verify:false, 
    avatar:'mp', 
    placeholder: '耶嘿康忙北鼻~'
  })
</script>

    </div>

    
    <div class="goodle-ads-below-container">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- below -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6846579683645896" data-ad-slot="7362272783" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    </div>
  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <!-- <a class="bottom-item" href="">首页</a> |
        <a class="bottom-item" href="" target="_blank">主站</a> | -->
        <!-- <a class="bottom-item" href="" target="_blank">GitHub</a> | -->
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

</body>
</html>
